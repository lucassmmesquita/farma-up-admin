
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Farmacia
 * 
 */
export type Farmacia = $Result.DefaultSelection<Prisma.$FarmaciaPayload>
/**
 * Model FarmaciaUsuario
 * 
 */
export type FarmaciaUsuario = $Result.DefaultSelection<Prisma.$FarmaciaUsuarioPayload>
/**
 * Model Indicador
 * 
 */
export type Indicador = $Result.DefaultSelection<Prisma.$IndicadorPayload>
/**
 * Model IndicadorRelacionado
 * 
 */
export type IndicadorRelacionado = $Result.DefaultSelection<Prisma.$IndicadorRelacionadoPayload>
/**
 * Model PlanoAcao
 * 
 */
export type PlanoAcao = $Result.DefaultSelection<Prisma.$PlanoAcaoPayload>
/**
 * Model Acao
 * 
 */
export type Acao = $Result.DefaultSelection<Prisma.$AcaoPayload>
/**
 * Model Comentario
 * 
 */
export type Comentario = $Result.DefaultSelection<Prisma.$ComentarioPayload>
/**
 * Model Evidencia
 * 
 */
export type Evidencia = $Result.DefaultSelection<Prisma.$EvidenciaPayload>
/**
 * Model ComentarioEvidencia
 * 
 */
export type ComentarioEvidencia = $Result.DefaultSelection<Prisma.$ComentarioEvidenciaPayload>
/**
 * Model Medicamento
 * 
 */
export type Medicamento = $Result.DefaultSelection<Prisma.$MedicamentoPayload>
/**
 * Model Cliente
 * 
 */
export type Cliente = $Result.DefaultSelection<Prisma.$ClientePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.farmacia`: Exposes CRUD operations for the **Farmacia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Farmacias
    * const farmacias = await prisma.farmacia.findMany()
    * ```
    */
  get farmacia(): Prisma.FarmaciaDelegate<ExtArgs>;

  /**
   * `prisma.farmaciaUsuario`: Exposes CRUD operations for the **FarmaciaUsuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FarmaciaUsuarios
    * const farmaciaUsuarios = await prisma.farmaciaUsuario.findMany()
    * ```
    */
  get farmaciaUsuario(): Prisma.FarmaciaUsuarioDelegate<ExtArgs>;

  /**
   * `prisma.indicador`: Exposes CRUD operations for the **Indicador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Indicadors
    * const indicadors = await prisma.indicador.findMany()
    * ```
    */
  get indicador(): Prisma.IndicadorDelegate<ExtArgs>;

  /**
   * `prisma.indicadorRelacionado`: Exposes CRUD operations for the **IndicadorRelacionado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndicadorRelacionados
    * const indicadorRelacionados = await prisma.indicadorRelacionado.findMany()
    * ```
    */
  get indicadorRelacionado(): Prisma.IndicadorRelacionadoDelegate<ExtArgs>;

  /**
   * `prisma.planoAcao`: Exposes CRUD operations for the **PlanoAcao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanoAcaos
    * const planoAcaos = await prisma.planoAcao.findMany()
    * ```
    */
  get planoAcao(): Prisma.PlanoAcaoDelegate<ExtArgs>;

  /**
   * `prisma.acao`: Exposes CRUD operations for the **Acao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Acaos
    * const acaos = await prisma.acao.findMany()
    * ```
    */
  get acao(): Prisma.AcaoDelegate<ExtArgs>;

  /**
   * `prisma.comentario`: Exposes CRUD operations for the **Comentario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comentarios
    * const comentarios = await prisma.comentario.findMany()
    * ```
    */
  get comentario(): Prisma.ComentarioDelegate<ExtArgs>;

  /**
   * `prisma.evidencia`: Exposes CRUD operations for the **Evidencia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evidencias
    * const evidencias = await prisma.evidencia.findMany()
    * ```
    */
  get evidencia(): Prisma.EvidenciaDelegate<ExtArgs>;

  /**
   * `prisma.comentarioEvidencia`: Exposes CRUD operations for the **ComentarioEvidencia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComentarioEvidencias
    * const comentarioEvidencias = await prisma.comentarioEvidencia.findMany()
    * ```
    */
  get comentarioEvidencia(): Prisma.ComentarioEvidenciaDelegate<ExtArgs>;

  /**
   * `prisma.medicamento`: Exposes CRUD operations for the **Medicamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicamentos
    * const medicamentos = await prisma.medicamento.findMany()
    * ```
    */
  get medicamento(): Prisma.MedicamentoDelegate<ExtArgs>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Farmacia: 'Farmacia',
    FarmaciaUsuario: 'FarmaciaUsuario',
    Indicador: 'Indicador',
    IndicadorRelacionado: 'IndicadorRelacionado',
    PlanoAcao: 'PlanoAcao',
    Acao: 'Acao',
    Comentario: 'Comentario',
    Evidencia: 'Evidencia',
    ComentarioEvidencia: 'ComentarioEvidencia',
    Medicamento: 'Medicamento',
    Cliente: 'Cliente'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "farmacia" | "farmaciaUsuario" | "indicador" | "indicadorRelacionado" | "planoAcao" | "acao" | "comentario" | "evidencia" | "comentarioEvidencia" | "medicamento" | "cliente"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Farmacia: {
        payload: Prisma.$FarmaciaPayload<ExtArgs>
        fields: Prisma.FarmaciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FarmaciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FarmaciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaPayload>
          }
          findFirst: {
            args: Prisma.FarmaciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FarmaciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaPayload>
          }
          findMany: {
            args: Prisma.FarmaciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaPayload>[]
          }
          create: {
            args: Prisma.FarmaciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaPayload>
          }
          createMany: {
            args: Prisma.FarmaciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FarmaciaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaPayload>[]
          }
          delete: {
            args: Prisma.FarmaciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaPayload>
          }
          update: {
            args: Prisma.FarmaciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaPayload>
          }
          deleteMany: {
            args: Prisma.FarmaciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FarmaciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FarmaciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaPayload>
          }
          aggregate: {
            args: Prisma.FarmaciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFarmacia>
          }
          groupBy: {
            args: Prisma.FarmaciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FarmaciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FarmaciaCountArgs<ExtArgs>
            result: $Utils.Optional<FarmaciaCountAggregateOutputType> | number
          }
        }
      }
      FarmaciaUsuario: {
        payload: Prisma.$FarmaciaUsuarioPayload<ExtArgs>
        fields: Prisma.FarmaciaUsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FarmaciaUsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaUsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FarmaciaUsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaUsuarioPayload>
          }
          findFirst: {
            args: Prisma.FarmaciaUsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaUsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FarmaciaUsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaUsuarioPayload>
          }
          findMany: {
            args: Prisma.FarmaciaUsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaUsuarioPayload>[]
          }
          create: {
            args: Prisma.FarmaciaUsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaUsuarioPayload>
          }
          createMany: {
            args: Prisma.FarmaciaUsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FarmaciaUsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaUsuarioPayload>[]
          }
          delete: {
            args: Prisma.FarmaciaUsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaUsuarioPayload>
          }
          update: {
            args: Prisma.FarmaciaUsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaUsuarioPayload>
          }
          deleteMany: {
            args: Prisma.FarmaciaUsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FarmaciaUsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FarmaciaUsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmaciaUsuarioPayload>
          }
          aggregate: {
            args: Prisma.FarmaciaUsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFarmaciaUsuario>
          }
          groupBy: {
            args: Prisma.FarmaciaUsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<FarmaciaUsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.FarmaciaUsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<FarmaciaUsuarioCountAggregateOutputType> | number
          }
        }
      }
      Indicador: {
        payload: Prisma.$IndicadorPayload<ExtArgs>
        fields: Prisma.IndicadorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicadorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicadorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorPayload>
          }
          findFirst: {
            args: Prisma.IndicadorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicadorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorPayload>
          }
          findMany: {
            args: Prisma.IndicadorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorPayload>[]
          }
          create: {
            args: Prisma.IndicadorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorPayload>
          }
          createMany: {
            args: Prisma.IndicadorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicadorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorPayload>[]
          }
          delete: {
            args: Prisma.IndicadorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorPayload>
          }
          update: {
            args: Prisma.IndicadorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorPayload>
          }
          deleteMany: {
            args: Prisma.IndicadorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicadorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IndicadorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorPayload>
          }
          aggregate: {
            args: Prisma.IndicadorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicador>
          }
          groupBy: {
            args: Prisma.IndicadorGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicadorGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicadorCountArgs<ExtArgs>
            result: $Utils.Optional<IndicadorCountAggregateOutputType> | number
          }
        }
      }
      IndicadorRelacionado: {
        payload: Prisma.$IndicadorRelacionadoPayload<ExtArgs>
        fields: Prisma.IndicadorRelacionadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicadorRelacionadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorRelacionadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicadorRelacionadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorRelacionadoPayload>
          }
          findFirst: {
            args: Prisma.IndicadorRelacionadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorRelacionadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicadorRelacionadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorRelacionadoPayload>
          }
          findMany: {
            args: Prisma.IndicadorRelacionadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorRelacionadoPayload>[]
          }
          create: {
            args: Prisma.IndicadorRelacionadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorRelacionadoPayload>
          }
          createMany: {
            args: Prisma.IndicadorRelacionadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicadorRelacionadoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorRelacionadoPayload>[]
          }
          delete: {
            args: Prisma.IndicadorRelacionadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorRelacionadoPayload>
          }
          update: {
            args: Prisma.IndicadorRelacionadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorRelacionadoPayload>
          }
          deleteMany: {
            args: Prisma.IndicadorRelacionadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicadorRelacionadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IndicadorRelacionadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicadorRelacionadoPayload>
          }
          aggregate: {
            args: Prisma.IndicadorRelacionadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicadorRelacionado>
          }
          groupBy: {
            args: Prisma.IndicadorRelacionadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicadorRelacionadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicadorRelacionadoCountArgs<ExtArgs>
            result: $Utils.Optional<IndicadorRelacionadoCountAggregateOutputType> | number
          }
        }
      }
      PlanoAcao: {
        payload: Prisma.$PlanoAcaoPayload<ExtArgs>
        fields: Prisma.PlanoAcaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanoAcaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoAcaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanoAcaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoAcaoPayload>
          }
          findFirst: {
            args: Prisma.PlanoAcaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoAcaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanoAcaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoAcaoPayload>
          }
          findMany: {
            args: Prisma.PlanoAcaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoAcaoPayload>[]
          }
          create: {
            args: Prisma.PlanoAcaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoAcaoPayload>
          }
          createMany: {
            args: Prisma.PlanoAcaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanoAcaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoAcaoPayload>[]
          }
          delete: {
            args: Prisma.PlanoAcaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoAcaoPayload>
          }
          update: {
            args: Prisma.PlanoAcaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoAcaoPayload>
          }
          deleteMany: {
            args: Prisma.PlanoAcaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanoAcaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanoAcaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoAcaoPayload>
          }
          aggregate: {
            args: Prisma.PlanoAcaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanoAcao>
          }
          groupBy: {
            args: Prisma.PlanoAcaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanoAcaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanoAcaoCountArgs<ExtArgs>
            result: $Utils.Optional<PlanoAcaoCountAggregateOutputType> | number
          }
        }
      }
      Acao: {
        payload: Prisma.$AcaoPayload<ExtArgs>
        fields: Prisma.AcaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcaoPayload>
          }
          findFirst: {
            args: Prisma.AcaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcaoPayload>
          }
          findMany: {
            args: Prisma.AcaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcaoPayload>[]
          }
          create: {
            args: Prisma.AcaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcaoPayload>
          }
          createMany: {
            args: Prisma.AcaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcaoPayload>[]
          }
          delete: {
            args: Prisma.AcaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcaoPayload>
          }
          update: {
            args: Prisma.AcaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcaoPayload>
          }
          deleteMany: {
            args: Prisma.AcaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcaoPayload>
          }
          aggregate: {
            args: Prisma.AcaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcao>
          }
          groupBy: {
            args: Prisma.AcaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcaoCountArgs<ExtArgs>
            result: $Utils.Optional<AcaoCountAggregateOutputType> | number
          }
        }
      }
      Comentario: {
        payload: Prisma.$ComentarioPayload<ExtArgs>
        fields: Prisma.ComentarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComentarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComentarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          findFirst: {
            args: Prisma.ComentarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComentarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          findMany: {
            args: Prisma.ComentarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>[]
          }
          create: {
            args: Prisma.ComentarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          createMany: {
            args: Prisma.ComentarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComentarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>[]
          }
          delete: {
            args: Prisma.ComentarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          update: {
            args: Prisma.ComentarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          deleteMany: {
            args: Prisma.ComentarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComentarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComentarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          aggregate: {
            args: Prisma.ComentarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComentario>
          }
          groupBy: {
            args: Prisma.ComentarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComentarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComentarioCountArgs<ExtArgs>
            result: $Utils.Optional<ComentarioCountAggregateOutputType> | number
          }
        }
      }
      Evidencia: {
        payload: Prisma.$EvidenciaPayload<ExtArgs>
        fields: Prisma.EvidenciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvidenciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvidenciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          findFirst: {
            args: Prisma.EvidenciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvidenciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          findMany: {
            args: Prisma.EvidenciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>[]
          }
          create: {
            args: Prisma.EvidenciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          createMany: {
            args: Prisma.EvidenciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvidenciaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>[]
          }
          delete: {
            args: Prisma.EvidenciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          update: {
            args: Prisma.EvidenciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          deleteMany: {
            args: Prisma.EvidenciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvidenciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvidenciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          aggregate: {
            args: Prisma.EvidenciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvidencia>
          }
          groupBy: {
            args: Prisma.EvidenciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvidenciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvidenciaCountArgs<ExtArgs>
            result: $Utils.Optional<EvidenciaCountAggregateOutputType> | number
          }
        }
      }
      ComentarioEvidencia: {
        payload: Prisma.$ComentarioEvidenciaPayload<ExtArgs>
        fields: Prisma.ComentarioEvidenciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComentarioEvidenciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioEvidenciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComentarioEvidenciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioEvidenciaPayload>
          }
          findFirst: {
            args: Prisma.ComentarioEvidenciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioEvidenciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComentarioEvidenciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioEvidenciaPayload>
          }
          findMany: {
            args: Prisma.ComentarioEvidenciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioEvidenciaPayload>[]
          }
          create: {
            args: Prisma.ComentarioEvidenciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioEvidenciaPayload>
          }
          createMany: {
            args: Prisma.ComentarioEvidenciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComentarioEvidenciaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioEvidenciaPayload>[]
          }
          delete: {
            args: Prisma.ComentarioEvidenciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioEvidenciaPayload>
          }
          update: {
            args: Prisma.ComentarioEvidenciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioEvidenciaPayload>
          }
          deleteMany: {
            args: Prisma.ComentarioEvidenciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComentarioEvidenciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComentarioEvidenciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioEvidenciaPayload>
          }
          aggregate: {
            args: Prisma.ComentarioEvidenciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComentarioEvidencia>
          }
          groupBy: {
            args: Prisma.ComentarioEvidenciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComentarioEvidenciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComentarioEvidenciaCountArgs<ExtArgs>
            result: $Utils.Optional<ComentarioEvidenciaCountAggregateOutputType> | number
          }
        }
      }
      Medicamento: {
        payload: Prisma.$MedicamentoPayload<ExtArgs>
        fields: Prisma.MedicamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentoPayload>
          }
          findFirst: {
            args: Prisma.MedicamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentoPayload>
          }
          findMany: {
            args: Prisma.MedicamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentoPayload>[]
          }
          create: {
            args: Prisma.MedicamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentoPayload>
          }
          createMany: {
            args: Prisma.MedicamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentoPayload>[]
          }
          delete: {
            args: Prisma.MedicamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentoPayload>
          }
          update: {
            args: Prisma.MedicamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentoPayload>
          }
          deleteMany: {
            args: Prisma.MedicamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentoPayload>
          }
          aggregate: {
            args: Prisma.MedicamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicamento>
          }
          groupBy: {
            args: Prisma.MedicamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicamentoCountArgs<ExtArgs>
            result: $Utils.Optional<MedicamentoCountAggregateOutputType> | number
          }
        }
      }
      Cliente: {
        payload: Prisma.$ClientePayload<ExtArgs>
        fields: Prisma.ClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findFirst: {
            args: Prisma.ClienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findMany: {
            args: Prisma.ClienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          create: {
            args: Prisma.ClienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          createMany: {
            args: Prisma.ClienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          delete: {
            args: Prisma.ClienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          update: {
            args: Prisma.ClienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          deleteMany: {
            args: Prisma.ClienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.ClienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    farmaciasUsuario: number
    planos: number
    comentarios: number
    evidencias: number
    comentariosEvidencia: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmaciasUsuario?: boolean | UsuarioCountOutputTypeCountFarmaciasUsuarioArgs
    planos?: boolean | UsuarioCountOutputTypeCountPlanosArgs
    comentarios?: boolean | UsuarioCountOutputTypeCountComentariosArgs
    evidencias?: boolean | UsuarioCountOutputTypeCountEvidenciasArgs
    comentariosEvidencia?: boolean | UsuarioCountOutputTypeCountComentariosEvidenciaArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountFarmaciasUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FarmaciaUsuarioWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPlanosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanoAcaoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountEvidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenciaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountComentariosEvidenciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioEvidenciaWhereInput
  }


  /**
   * Count Type FarmaciaCountOutputType
   */

  export type FarmaciaCountOutputType = {
    usuariosAssociados: number
    planosAcao: number
    evidencias: number
    medicamentos: number
  }

  export type FarmaciaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuariosAssociados?: boolean | FarmaciaCountOutputTypeCountUsuariosAssociadosArgs
    planosAcao?: boolean | FarmaciaCountOutputTypeCountPlanosAcaoArgs
    evidencias?: boolean | FarmaciaCountOutputTypeCountEvidenciasArgs
    medicamentos?: boolean | FarmaciaCountOutputTypeCountMedicamentosArgs
  }

  // Custom InputTypes
  /**
   * FarmaciaCountOutputType without action
   */
  export type FarmaciaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaCountOutputType
     */
    select?: FarmaciaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FarmaciaCountOutputType without action
   */
  export type FarmaciaCountOutputTypeCountUsuariosAssociadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FarmaciaUsuarioWhereInput
  }

  /**
   * FarmaciaCountOutputType without action
   */
  export type FarmaciaCountOutputTypeCountPlanosAcaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanoAcaoWhereInput
  }

  /**
   * FarmaciaCountOutputType without action
   */
  export type FarmaciaCountOutputTypeCountEvidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenciaWhereInput
  }

  /**
   * FarmaciaCountOutputType without action
   */
  export type FarmaciaCountOutputTypeCountMedicamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicamentoWhereInput
  }


  /**
   * Count Type IndicadorCountOutputType
   */

  export type IndicadorCountOutputType = {
    planosAcao: number
    evidencias: number
    relacionados: number
    relacionadoA: number
  }

  export type IndicadorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planosAcao?: boolean | IndicadorCountOutputTypeCountPlanosAcaoArgs
    evidencias?: boolean | IndicadorCountOutputTypeCountEvidenciasArgs
    relacionados?: boolean | IndicadorCountOutputTypeCountRelacionadosArgs
    relacionadoA?: boolean | IndicadorCountOutputTypeCountRelacionadoAArgs
  }

  // Custom InputTypes
  /**
   * IndicadorCountOutputType without action
   */
  export type IndicadorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorCountOutputType
     */
    select?: IndicadorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IndicadorCountOutputType without action
   */
  export type IndicadorCountOutputTypeCountPlanosAcaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanoAcaoWhereInput
  }

  /**
   * IndicadorCountOutputType without action
   */
  export type IndicadorCountOutputTypeCountEvidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenciaWhereInput
  }

  /**
   * IndicadorCountOutputType without action
   */
  export type IndicadorCountOutputTypeCountRelacionadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicadorRelacionadoWhereInput
  }

  /**
   * IndicadorCountOutputType without action
   */
  export type IndicadorCountOutputTypeCountRelacionadoAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicadorRelacionadoWhereInput
  }


  /**
   * Count Type PlanoAcaoCountOutputType
   */

  export type PlanoAcaoCountOutputType = {
    acoes: number
    comentarios: number
    evidencias: number
  }

  export type PlanoAcaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acoes?: boolean | PlanoAcaoCountOutputTypeCountAcoesArgs
    comentarios?: boolean | PlanoAcaoCountOutputTypeCountComentariosArgs
    evidencias?: boolean | PlanoAcaoCountOutputTypeCountEvidenciasArgs
  }

  // Custom InputTypes
  /**
   * PlanoAcaoCountOutputType without action
   */
  export type PlanoAcaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcaoCountOutputType
     */
    select?: PlanoAcaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanoAcaoCountOutputType without action
   */
  export type PlanoAcaoCountOutputTypeCountAcoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcaoWhereInput
  }

  /**
   * PlanoAcaoCountOutputType without action
   */
  export type PlanoAcaoCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
  }

  /**
   * PlanoAcaoCountOutputType without action
   */
  export type PlanoAcaoCountOutputTypeCountEvidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenciaWhereInput
  }


  /**
   * Count Type EvidenciaCountOutputType
   */

  export type EvidenciaCountOutputType = {
    comentarios: number
  }

  export type EvidenciaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comentarios?: boolean | EvidenciaCountOutputTypeCountComentariosArgs
  }

  // Custom InputTypes
  /**
   * EvidenciaCountOutputType without action
   */
  export type EvidenciaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenciaCountOutputType
     */
    select?: EvidenciaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvidenciaCountOutputType without action
   */
  export type EvidenciaCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioEvidenciaWhereInput
  }


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    medicamentos: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicamentos?: boolean | ClienteCountOutputTypeCountMedicamentosArgs
  }

  // Custom InputTypes
  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountMedicamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicamentoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    nome: string | null
    email: string | null
    senha: string | null
    perfil: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    email: string | null
    senha: string | null
    perfil: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    senha: number
    perfil: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuarioMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    perfil?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    perfil?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    perfil?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    _count: UsuarioCountAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    perfil?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmaciasUsuario?: boolean | Usuario$farmaciasUsuarioArgs<ExtArgs>
    planos?: boolean | Usuario$planosArgs<ExtArgs>
    comentarios?: boolean | Usuario$comentariosArgs<ExtArgs>
    evidencias?: boolean | Usuario$evidenciasArgs<ExtArgs>
    comentariosEvidencia?: boolean | Usuario$comentariosEvidenciaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    perfil?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    perfil?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmaciasUsuario?: boolean | Usuario$farmaciasUsuarioArgs<ExtArgs>
    planos?: boolean | Usuario$planosArgs<ExtArgs>
    comentarios?: boolean | Usuario$comentariosArgs<ExtArgs>
    evidencias?: boolean | Usuario$evidenciasArgs<ExtArgs>
    comentariosEvidencia?: boolean | Usuario$comentariosEvidenciaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      farmaciasUsuario: Prisma.$FarmaciaUsuarioPayload<ExtArgs>[]
      planos: Prisma.$PlanoAcaoPayload<ExtArgs>[]
      comentarios: Prisma.$ComentarioPayload<ExtArgs>[]
      evidencias: Prisma.$EvidenciaPayload<ExtArgs>[]
      comentariosEvidencia: Prisma.$ComentarioEvidenciaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      email: string
      senha: string
      perfil: string
      ativo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    farmaciasUsuario<T extends Usuario$farmaciasUsuarioArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$farmaciasUsuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FarmaciaUsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    planos<T extends Usuario$planosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$planosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "findMany"> | Null>
    comentarios<T extends Usuario$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findMany"> | Null>
    evidencias<T extends Usuario$evidenciasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$evidenciasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findMany"> | Null>
    comentariosEvidencia<T extends Usuario$comentariosEvidenciaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$comentariosEvidenciaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioEvidenciaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'String'>
    readonly nome: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly senha: FieldRef<"Usuario", 'String'>
    readonly perfil: FieldRef<"Usuario", 'String'>
    readonly ativo: FieldRef<"Usuario", 'Boolean'>
    readonly createdAt: FieldRef<"Usuario", 'DateTime'>
    readonly updatedAt: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.farmaciasUsuario
   */
  export type Usuario$farmaciasUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioInclude<ExtArgs> | null
    where?: FarmaciaUsuarioWhereInput
    orderBy?: FarmaciaUsuarioOrderByWithRelationInput | FarmaciaUsuarioOrderByWithRelationInput[]
    cursor?: FarmaciaUsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FarmaciaUsuarioScalarFieldEnum | FarmaciaUsuarioScalarFieldEnum[]
  }

  /**
   * Usuario.planos
   */
  export type Usuario$planosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
    where?: PlanoAcaoWhereInput
    orderBy?: PlanoAcaoOrderByWithRelationInput | PlanoAcaoOrderByWithRelationInput[]
    cursor?: PlanoAcaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanoAcaoScalarFieldEnum | PlanoAcaoScalarFieldEnum[]
  }

  /**
   * Usuario.comentarios
   */
  export type Usuario$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    where?: ComentarioWhereInput
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    cursor?: ComentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Usuario.evidencias
   */
  export type Usuario$evidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    where?: EvidenciaWhereInput
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    cursor?: EvidenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Usuario.comentariosEvidencia
   */
  export type Usuario$comentariosEvidenciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaInclude<ExtArgs> | null
    where?: ComentarioEvidenciaWhereInput
    orderBy?: ComentarioEvidenciaOrderByWithRelationInput | ComentarioEvidenciaOrderByWithRelationInput[]
    cursor?: ComentarioEvidenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioEvidenciaScalarFieldEnum | ComentarioEvidenciaScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Farmacia
   */

  export type AggregateFarmacia = {
    _count: FarmaciaCountAggregateOutputType | null
    _min: FarmaciaMinAggregateOutputType | null
    _max: FarmaciaMaxAggregateOutputType | null
  }

  export type FarmaciaMinAggregateOutputType = {
    id: string | null
    nome: string | null
    cnpj: string | null
    endereco: string | null
    telefone: string | null
    email: string | null
    corPrincipal: string | null
    corSecundaria: string | null
    logo: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FarmaciaMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    cnpj: string | null
    endereco: string | null
    telefone: string | null
    email: string | null
    corPrincipal: string | null
    corSecundaria: string | null
    logo: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FarmaciaCountAggregateOutputType = {
    id: number
    nome: number
    cnpj: number
    endereco: number
    telefone: number
    email: number
    corPrincipal: number
    corSecundaria: number
    logo: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FarmaciaMinAggregateInputType = {
    id?: true
    nome?: true
    cnpj?: true
    endereco?: true
    telefone?: true
    email?: true
    corPrincipal?: true
    corSecundaria?: true
    logo?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FarmaciaMaxAggregateInputType = {
    id?: true
    nome?: true
    cnpj?: true
    endereco?: true
    telefone?: true
    email?: true
    corPrincipal?: true
    corSecundaria?: true
    logo?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FarmaciaCountAggregateInputType = {
    id?: true
    nome?: true
    cnpj?: true
    endereco?: true
    telefone?: true
    email?: true
    corPrincipal?: true
    corSecundaria?: true
    logo?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FarmaciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Farmacia to aggregate.
     */
    where?: FarmaciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Farmacias to fetch.
     */
    orderBy?: FarmaciaOrderByWithRelationInput | FarmaciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FarmaciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Farmacias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Farmacias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Farmacias
    **/
    _count?: true | FarmaciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FarmaciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FarmaciaMaxAggregateInputType
  }

  export type GetFarmaciaAggregateType<T extends FarmaciaAggregateArgs> = {
        [P in keyof T & keyof AggregateFarmacia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFarmacia[P]>
      : GetScalarType<T[P], AggregateFarmacia[P]>
  }




  export type FarmaciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FarmaciaWhereInput
    orderBy?: FarmaciaOrderByWithAggregationInput | FarmaciaOrderByWithAggregationInput[]
    by: FarmaciaScalarFieldEnum[] | FarmaciaScalarFieldEnum
    having?: FarmaciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FarmaciaCountAggregateInputType | true
    _min?: FarmaciaMinAggregateInputType
    _max?: FarmaciaMaxAggregateInputType
  }

  export type FarmaciaGroupByOutputType = {
    id: string
    nome: string
    cnpj: string
    endereco: string | null
    telefone: string | null
    email: string | null
    corPrincipal: string
    corSecundaria: string
    logo: string | null
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    _count: FarmaciaCountAggregateOutputType | null
    _min: FarmaciaMinAggregateOutputType | null
    _max: FarmaciaMaxAggregateOutputType | null
  }

  type GetFarmaciaGroupByPayload<T extends FarmaciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FarmaciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FarmaciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FarmaciaGroupByOutputType[P]>
            : GetScalarType<T[P], FarmaciaGroupByOutputType[P]>
        }
      >
    >


  export type FarmaciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cnpj?: boolean
    endereco?: boolean
    telefone?: boolean
    email?: boolean
    corPrincipal?: boolean
    corSecundaria?: boolean
    logo?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuariosAssociados?: boolean | Farmacia$usuariosAssociadosArgs<ExtArgs>
    planosAcao?: boolean | Farmacia$planosAcaoArgs<ExtArgs>
    evidencias?: boolean | Farmacia$evidenciasArgs<ExtArgs>
    medicamentos?: boolean | Farmacia$medicamentosArgs<ExtArgs>
    _count?: boolean | FarmaciaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["farmacia"]>

  export type FarmaciaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cnpj?: boolean
    endereco?: boolean
    telefone?: boolean
    email?: boolean
    corPrincipal?: boolean
    corSecundaria?: boolean
    logo?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["farmacia"]>

  export type FarmaciaSelectScalar = {
    id?: boolean
    nome?: boolean
    cnpj?: boolean
    endereco?: boolean
    telefone?: boolean
    email?: boolean
    corPrincipal?: boolean
    corSecundaria?: boolean
    logo?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FarmaciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuariosAssociados?: boolean | Farmacia$usuariosAssociadosArgs<ExtArgs>
    planosAcao?: boolean | Farmacia$planosAcaoArgs<ExtArgs>
    evidencias?: boolean | Farmacia$evidenciasArgs<ExtArgs>
    medicamentos?: boolean | Farmacia$medicamentosArgs<ExtArgs>
    _count?: boolean | FarmaciaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FarmaciaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FarmaciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Farmacia"
    objects: {
      usuariosAssociados: Prisma.$FarmaciaUsuarioPayload<ExtArgs>[]
      planosAcao: Prisma.$PlanoAcaoPayload<ExtArgs>[]
      evidencias: Prisma.$EvidenciaPayload<ExtArgs>[]
      medicamentos: Prisma.$MedicamentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      cnpj: string
      endereco: string | null
      telefone: string | null
      email: string | null
      corPrincipal: string
      corSecundaria: string
      logo: string | null
      ativo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["farmacia"]>
    composites: {}
  }

  type FarmaciaGetPayload<S extends boolean | null | undefined | FarmaciaDefaultArgs> = $Result.GetResult<Prisma.$FarmaciaPayload, S>

  type FarmaciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FarmaciaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FarmaciaCountAggregateInputType | true
    }

  export interface FarmaciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Farmacia'], meta: { name: 'Farmacia' } }
    /**
     * Find zero or one Farmacia that matches the filter.
     * @param {FarmaciaFindUniqueArgs} args - Arguments to find a Farmacia
     * @example
     * // Get one Farmacia
     * const farmacia = await prisma.farmacia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FarmaciaFindUniqueArgs>(args: SelectSubset<T, FarmaciaFindUniqueArgs<ExtArgs>>): Prisma__FarmaciaClient<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Farmacia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FarmaciaFindUniqueOrThrowArgs} args - Arguments to find a Farmacia
     * @example
     * // Get one Farmacia
     * const farmacia = await prisma.farmacia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FarmaciaFindUniqueOrThrowArgs>(args: SelectSubset<T, FarmaciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FarmaciaClient<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Farmacia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaFindFirstArgs} args - Arguments to find a Farmacia
     * @example
     * // Get one Farmacia
     * const farmacia = await prisma.farmacia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FarmaciaFindFirstArgs>(args?: SelectSubset<T, FarmaciaFindFirstArgs<ExtArgs>>): Prisma__FarmaciaClient<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Farmacia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaFindFirstOrThrowArgs} args - Arguments to find a Farmacia
     * @example
     * // Get one Farmacia
     * const farmacia = await prisma.farmacia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FarmaciaFindFirstOrThrowArgs>(args?: SelectSubset<T, FarmaciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__FarmaciaClient<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Farmacias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Farmacias
     * const farmacias = await prisma.farmacia.findMany()
     * 
     * // Get first 10 Farmacias
     * const farmacias = await prisma.farmacia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const farmaciaWithIdOnly = await prisma.farmacia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FarmaciaFindManyArgs>(args?: SelectSubset<T, FarmaciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Farmacia.
     * @param {FarmaciaCreateArgs} args - Arguments to create a Farmacia.
     * @example
     * // Create one Farmacia
     * const Farmacia = await prisma.farmacia.create({
     *   data: {
     *     // ... data to create a Farmacia
     *   }
     * })
     * 
     */
    create<T extends FarmaciaCreateArgs>(args: SelectSubset<T, FarmaciaCreateArgs<ExtArgs>>): Prisma__FarmaciaClient<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Farmacias.
     * @param {FarmaciaCreateManyArgs} args - Arguments to create many Farmacias.
     * @example
     * // Create many Farmacias
     * const farmacia = await prisma.farmacia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FarmaciaCreateManyArgs>(args?: SelectSubset<T, FarmaciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Farmacias and returns the data saved in the database.
     * @param {FarmaciaCreateManyAndReturnArgs} args - Arguments to create many Farmacias.
     * @example
     * // Create many Farmacias
     * const farmacia = await prisma.farmacia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Farmacias and only return the `id`
     * const farmaciaWithIdOnly = await prisma.farmacia.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FarmaciaCreateManyAndReturnArgs>(args?: SelectSubset<T, FarmaciaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Farmacia.
     * @param {FarmaciaDeleteArgs} args - Arguments to delete one Farmacia.
     * @example
     * // Delete one Farmacia
     * const Farmacia = await prisma.farmacia.delete({
     *   where: {
     *     // ... filter to delete one Farmacia
     *   }
     * })
     * 
     */
    delete<T extends FarmaciaDeleteArgs>(args: SelectSubset<T, FarmaciaDeleteArgs<ExtArgs>>): Prisma__FarmaciaClient<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Farmacia.
     * @param {FarmaciaUpdateArgs} args - Arguments to update one Farmacia.
     * @example
     * // Update one Farmacia
     * const farmacia = await prisma.farmacia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FarmaciaUpdateArgs>(args: SelectSubset<T, FarmaciaUpdateArgs<ExtArgs>>): Prisma__FarmaciaClient<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Farmacias.
     * @param {FarmaciaDeleteManyArgs} args - Arguments to filter Farmacias to delete.
     * @example
     * // Delete a few Farmacias
     * const { count } = await prisma.farmacia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FarmaciaDeleteManyArgs>(args?: SelectSubset<T, FarmaciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Farmacias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Farmacias
     * const farmacia = await prisma.farmacia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FarmaciaUpdateManyArgs>(args: SelectSubset<T, FarmaciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Farmacia.
     * @param {FarmaciaUpsertArgs} args - Arguments to update or create a Farmacia.
     * @example
     * // Update or create a Farmacia
     * const farmacia = await prisma.farmacia.upsert({
     *   create: {
     *     // ... data to create a Farmacia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Farmacia we want to update
     *   }
     * })
     */
    upsert<T extends FarmaciaUpsertArgs>(args: SelectSubset<T, FarmaciaUpsertArgs<ExtArgs>>): Prisma__FarmaciaClient<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Farmacias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaCountArgs} args - Arguments to filter Farmacias to count.
     * @example
     * // Count the number of Farmacias
     * const count = await prisma.farmacia.count({
     *   where: {
     *     // ... the filter for the Farmacias we want to count
     *   }
     * })
    **/
    count<T extends FarmaciaCountArgs>(
      args?: Subset<T, FarmaciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FarmaciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Farmacia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FarmaciaAggregateArgs>(args: Subset<T, FarmaciaAggregateArgs>): Prisma.PrismaPromise<GetFarmaciaAggregateType<T>>

    /**
     * Group by Farmacia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FarmaciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FarmaciaGroupByArgs['orderBy'] }
        : { orderBy?: FarmaciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FarmaciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFarmaciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Farmacia model
   */
  readonly fields: FarmaciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Farmacia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FarmaciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuariosAssociados<T extends Farmacia$usuariosAssociadosArgs<ExtArgs> = {}>(args?: Subset<T, Farmacia$usuariosAssociadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FarmaciaUsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    planosAcao<T extends Farmacia$planosAcaoArgs<ExtArgs> = {}>(args?: Subset<T, Farmacia$planosAcaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "findMany"> | Null>
    evidencias<T extends Farmacia$evidenciasArgs<ExtArgs> = {}>(args?: Subset<T, Farmacia$evidenciasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findMany"> | Null>
    medicamentos<T extends Farmacia$medicamentosArgs<ExtArgs> = {}>(args?: Subset<T, Farmacia$medicamentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicamentoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Farmacia model
   */ 
  interface FarmaciaFieldRefs {
    readonly id: FieldRef<"Farmacia", 'String'>
    readonly nome: FieldRef<"Farmacia", 'String'>
    readonly cnpj: FieldRef<"Farmacia", 'String'>
    readonly endereco: FieldRef<"Farmacia", 'String'>
    readonly telefone: FieldRef<"Farmacia", 'String'>
    readonly email: FieldRef<"Farmacia", 'String'>
    readonly corPrincipal: FieldRef<"Farmacia", 'String'>
    readonly corSecundaria: FieldRef<"Farmacia", 'String'>
    readonly logo: FieldRef<"Farmacia", 'String'>
    readonly ativo: FieldRef<"Farmacia", 'Boolean'>
    readonly createdAt: FieldRef<"Farmacia", 'DateTime'>
    readonly updatedAt: FieldRef<"Farmacia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Farmacia findUnique
   */
  export type FarmaciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmacia
     */
    select?: FarmaciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaInclude<ExtArgs> | null
    /**
     * Filter, which Farmacia to fetch.
     */
    where: FarmaciaWhereUniqueInput
  }

  /**
   * Farmacia findUniqueOrThrow
   */
  export type FarmaciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmacia
     */
    select?: FarmaciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaInclude<ExtArgs> | null
    /**
     * Filter, which Farmacia to fetch.
     */
    where: FarmaciaWhereUniqueInput
  }

  /**
   * Farmacia findFirst
   */
  export type FarmaciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmacia
     */
    select?: FarmaciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaInclude<ExtArgs> | null
    /**
     * Filter, which Farmacia to fetch.
     */
    where?: FarmaciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Farmacias to fetch.
     */
    orderBy?: FarmaciaOrderByWithRelationInput | FarmaciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Farmacias.
     */
    cursor?: FarmaciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Farmacias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Farmacias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Farmacias.
     */
    distinct?: FarmaciaScalarFieldEnum | FarmaciaScalarFieldEnum[]
  }

  /**
   * Farmacia findFirstOrThrow
   */
  export type FarmaciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmacia
     */
    select?: FarmaciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaInclude<ExtArgs> | null
    /**
     * Filter, which Farmacia to fetch.
     */
    where?: FarmaciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Farmacias to fetch.
     */
    orderBy?: FarmaciaOrderByWithRelationInput | FarmaciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Farmacias.
     */
    cursor?: FarmaciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Farmacias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Farmacias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Farmacias.
     */
    distinct?: FarmaciaScalarFieldEnum | FarmaciaScalarFieldEnum[]
  }

  /**
   * Farmacia findMany
   */
  export type FarmaciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmacia
     */
    select?: FarmaciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaInclude<ExtArgs> | null
    /**
     * Filter, which Farmacias to fetch.
     */
    where?: FarmaciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Farmacias to fetch.
     */
    orderBy?: FarmaciaOrderByWithRelationInput | FarmaciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Farmacias.
     */
    cursor?: FarmaciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Farmacias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Farmacias.
     */
    skip?: number
    distinct?: FarmaciaScalarFieldEnum | FarmaciaScalarFieldEnum[]
  }

  /**
   * Farmacia create
   */
  export type FarmaciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmacia
     */
    select?: FarmaciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaInclude<ExtArgs> | null
    /**
     * The data needed to create a Farmacia.
     */
    data: XOR<FarmaciaCreateInput, FarmaciaUncheckedCreateInput>
  }

  /**
   * Farmacia createMany
   */
  export type FarmaciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Farmacias.
     */
    data: FarmaciaCreateManyInput | FarmaciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Farmacia createManyAndReturn
   */
  export type FarmaciaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmacia
     */
    select?: FarmaciaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Farmacias.
     */
    data: FarmaciaCreateManyInput | FarmaciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Farmacia update
   */
  export type FarmaciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmacia
     */
    select?: FarmaciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaInclude<ExtArgs> | null
    /**
     * The data needed to update a Farmacia.
     */
    data: XOR<FarmaciaUpdateInput, FarmaciaUncheckedUpdateInput>
    /**
     * Choose, which Farmacia to update.
     */
    where: FarmaciaWhereUniqueInput
  }

  /**
   * Farmacia updateMany
   */
  export type FarmaciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Farmacias.
     */
    data: XOR<FarmaciaUpdateManyMutationInput, FarmaciaUncheckedUpdateManyInput>
    /**
     * Filter which Farmacias to update
     */
    where?: FarmaciaWhereInput
  }

  /**
   * Farmacia upsert
   */
  export type FarmaciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmacia
     */
    select?: FarmaciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaInclude<ExtArgs> | null
    /**
     * The filter to search for the Farmacia to update in case it exists.
     */
    where: FarmaciaWhereUniqueInput
    /**
     * In case the Farmacia found by the `where` argument doesn't exist, create a new Farmacia with this data.
     */
    create: XOR<FarmaciaCreateInput, FarmaciaUncheckedCreateInput>
    /**
     * In case the Farmacia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FarmaciaUpdateInput, FarmaciaUncheckedUpdateInput>
  }

  /**
   * Farmacia delete
   */
  export type FarmaciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmacia
     */
    select?: FarmaciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaInclude<ExtArgs> | null
    /**
     * Filter which Farmacia to delete.
     */
    where: FarmaciaWhereUniqueInput
  }

  /**
   * Farmacia deleteMany
   */
  export type FarmaciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Farmacias to delete
     */
    where?: FarmaciaWhereInput
  }

  /**
   * Farmacia.usuariosAssociados
   */
  export type Farmacia$usuariosAssociadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioInclude<ExtArgs> | null
    where?: FarmaciaUsuarioWhereInput
    orderBy?: FarmaciaUsuarioOrderByWithRelationInput | FarmaciaUsuarioOrderByWithRelationInput[]
    cursor?: FarmaciaUsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FarmaciaUsuarioScalarFieldEnum | FarmaciaUsuarioScalarFieldEnum[]
  }

  /**
   * Farmacia.planosAcao
   */
  export type Farmacia$planosAcaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
    where?: PlanoAcaoWhereInput
    orderBy?: PlanoAcaoOrderByWithRelationInput | PlanoAcaoOrderByWithRelationInput[]
    cursor?: PlanoAcaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanoAcaoScalarFieldEnum | PlanoAcaoScalarFieldEnum[]
  }

  /**
   * Farmacia.evidencias
   */
  export type Farmacia$evidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    where?: EvidenciaWhereInput
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    cursor?: EvidenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Farmacia.medicamentos
   */
  export type Farmacia$medicamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoInclude<ExtArgs> | null
    where?: MedicamentoWhereInput
    orderBy?: MedicamentoOrderByWithRelationInput | MedicamentoOrderByWithRelationInput[]
    cursor?: MedicamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicamentoScalarFieldEnum | MedicamentoScalarFieldEnum[]
  }

  /**
   * Farmacia without action
   */
  export type FarmaciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmacia
     */
    select?: FarmaciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaInclude<ExtArgs> | null
  }


  /**
   * Model FarmaciaUsuario
   */

  export type AggregateFarmaciaUsuario = {
    _count: FarmaciaUsuarioCountAggregateOutputType | null
    _min: FarmaciaUsuarioMinAggregateOutputType | null
    _max: FarmaciaUsuarioMaxAggregateOutputType | null
  }

  export type FarmaciaUsuarioMinAggregateOutputType = {
    id: string | null
    farmaciaId: string | null
    usuarioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FarmaciaUsuarioMaxAggregateOutputType = {
    id: string | null
    farmaciaId: string | null
    usuarioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FarmaciaUsuarioCountAggregateOutputType = {
    id: number
    farmaciaId: number
    usuarioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FarmaciaUsuarioMinAggregateInputType = {
    id?: true
    farmaciaId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FarmaciaUsuarioMaxAggregateInputType = {
    id?: true
    farmaciaId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FarmaciaUsuarioCountAggregateInputType = {
    id?: true
    farmaciaId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FarmaciaUsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FarmaciaUsuario to aggregate.
     */
    where?: FarmaciaUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FarmaciaUsuarios to fetch.
     */
    orderBy?: FarmaciaUsuarioOrderByWithRelationInput | FarmaciaUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FarmaciaUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FarmaciaUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FarmaciaUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FarmaciaUsuarios
    **/
    _count?: true | FarmaciaUsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FarmaciaUsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FarmaciaUsuarioMaxAggregateInputType
  }

  export type GetFarmaciaUsuarioAggregateType<T extends FarmaciaUsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateFarmaciaUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFarmaciaUsuario[P]>
      : GetScalarType<T[P], AggregateFarmaciaUsuario[P]>
  }




  export type FarmaciaUsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FarmaciaUsuarioWhereInput
    orderBy?: FarmaciaUsuarioOrderByWithAggregationInput | FarmaciaUsuarioOrderByWithAggregationInput[]
    by: FarmaciaUsuarioScalarFieldEnum[] | FarmaciaUsuarioScalarFieldEnum
    having?: FarmaciaUsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FarmaciaUsuarioCountAggregateInputType | true
    _min?: FarmaciaUsuarioMinAggregateInputType
    _max?: FarmaciaUsuarioMaxAggregateInputType
  }

  export type FarmaciaUsuarioGroupByOutputType = {
    id: string
    farmaciaId: string
    usuarioId: string
    createdAt: Date
    updatedAt: Date
    _count: FarmaciaUsuarioCountAggregateOutputType | null
    _min: FarmaciaUsuarioMinAggregateOutputType | null
    _max: FarmaciaUsuarioMaxAggregateOutputType | null
  }

  type GetFarmaciaUsuarioGroupByPayload<T extends FarmaciaUsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FarmaciaUsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FarmaciaUsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FarmaciaUsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], FarmaciaUsuarioGroupByOutputType[P]>
        }
      >
    >


  export type FarmaciaUsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    farmaciaId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["farmaciaUsuario"]>

  export type FarmaciaUsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    farmaciaId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["farmaciaUsuario"]>

  export type FarmaciaUsuarioSelectScalar = {
    id?: boolean
    farmaciaId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FarmaciaUsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type FarmaciaUsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $FarmaciaUsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FarmaciaUsuario"
    objects: {
      farmacia: Prisma.$FarmaciaPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      farmaciaId: string
      usuarioId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["farmaciaUsuario"]>
    composites: {}
  }

  type FarmaciaUsuarioGetPayload<S extends boolean | null | undefined | FarmaciaUsuarioDefaultArgs> = $Result.GetResult<Prisma.$FarmaciaUsuarioPayload, S>

  type FarmaciaUsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FarmaciaUsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FarmaciaUsuarioCountAggregateInputType | true
    }

  export interface FarmaciaUsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FarmaciaUsuario'], meta: { name: 'FarmaciaUsuario' } }
    /**
     * Find zero or one FarmaciaUsuario that matches the filter.
     * @param {FarmaciaUsuarioFindUniqueArgs} args - Arguments to find a FarmaciaUsuario
     * @example
     * // Get one FarmaciaUsuario
     * const farmaciaUsuario = await prisma.farmaciaUsuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FarmaciaUsuarioFindUniqueArgs>(args: SelectSubset<T, FarmaciaUsuarioFindUniqueArgs<ExtArgs>>): Prisma__FarmaciaUsuarioClient<$Result.GetResult<Prisma.$FarmaciaUsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FarmaciaUsuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FarmaciaUsuarioFindUniqueOrThrowArgs} args - Arguments to find a FarmaciaUsuario
     * @example
     * // Get one FarmaciaUsuario
     * const farmaciaUsuario = await prisma.farmaciaUsuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FarmaciaUsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, FarmaciaUsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FarmaciaUsuarioClient<$Result.GetResult<Prisma.$FarmaciaUsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FarmaciaUsuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaUsuarioFindFirstArgs} args - Arguments to find a FarmaciaUsuario
     * @example
     * // Get one FarmaciaUsuario
     * const farmaciaUsuario = await prisma.farmaciaUsuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FarmaciaUsuarioFindFirstArgs>(args?: SelectSubset<T, FarmaciaUsuarioFindFirstArgs<ExtArgs>>): Prisma__FarmaciaUsuarioClient<$Result.GetResult<Prisma.$FarmaciaUsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FarmaciaUsuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaUsuarioFindFirstOrThrowArgs} args - Arguments to find a FarmaciaUsuario
     * @example
     * // Get one FarmaciaUsuario
     * const farmaciaUsuario = await prisma.farmaciaUsuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FarmaciaUsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, FarmaciaUsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__FarmaciaUsuarioClient<$Result.GetResult<Prisma.$FarmaciaUsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FarmaciaUsuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaUsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FarmaciaUsuarios
     * const farmaciaUsuarios = await prisma.farmaciaUsuario.findMany()
     * 
     * // Get first 10 FarmaciaUsuarios
     * const farmaciaUsuarios = await prisma.farmaciaUsuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const farmaciaUsuarioWithIdOnly = await prisma.farmaciaUsuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FarmaciaUsuarioFindManyArgs>(args?: SelectSubset<T, FarmaciaUsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FarmaciaUsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FarmaciaUsuario.
     * @param {FarmaciaUsuarioCreateArgs} args - Arguments to create a FarmaciaUsuario.
     * @example
     * // Create one FarmaciaUsuario
     * const FarmaciaUsuario = await prisma.farmaciaUsuario.create({
     *   data: {
     *     // ... data to create a FarmaciaUsuario
     *   }
     * })
     * 
     */
    create<T extends FarmaciaUsuarioCreateArgs>(args: SelectSubset<T, FarmaciaUsuarioCreateArgs<ExtArgs>>): Prisma__FarmaciaUsuarioClient<$Result.GetResult<Prisma.$FarmaciaUsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FarmaciaUsuarios.
     * @param {FarmaciaUsuarioCreateManyArgs} args - Arguments to create many FarmaciaUsuarios.
     * @example
     * // Create many FarmaciaUsuarios
     * const farmaciaUsuario = await prisma.farmaciaUsuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FarmaciaUsuarioCreateManyArgs>(args?: SelectSubset<T, FarmaciaUsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FarmaciaUsuarios and returns the data saved in the database.
     * @param {FarmaciaUsuarioCreateManyAndReturnArgs} args - Arguments to create many FarmaciaUsuarios.
     * @example
     * // Create many FarmaciaUsuarios
     * const farmaciaUsuario = await prisma.farmaciaUsuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FarmaciaUsuarios and only return the `id`
     * const farmaciaUsuarioWithIdOnly = await prisma.farmaciaUsuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FarmaciaUsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, FarmaciaUsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FarmaciaUsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FarmaciaUsuario.
     * @param {FarmaciaUsuarioDeleteArgs} args - Arguments to delete one FarmaciaUsuario.
     * @example
     * // Delete one FarmaciaUsuario
     * const FarmaciaUsuario = await prisma.farmaciaUsuario.delete({
     *   where: {
     *     // ... filter to delete one FarmaciaUsuario
     *   }
     * })
     * 
     */
    delete<T extends FarmaciaUsuarioDeleteArgs>(args: SelectSubset<T, FarmaciaUsuarioDeleteArgs<ExtArgs>>): Prisma__FarmaciaUsuarioClient<$Result.GetResult<Prisma.$FarmaciaUsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FarmaciaUsuario.
     * @param {FarmaciaUsuarioUpdateArgs} args - Arguments to update one FarmaciaUsuario.
     * @example
     * // Update one FarmaciaUsuario
     * const farmaciaUsuario = await prisma.farmaciaUsuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FarmaciaUsuarioUpdateArgs>(args: SelectSubset<T, FarmaciaUsuarioUpdateArgs<ExtArgs>>): Prisma__FarmaciaUsuarioClient<$Result.GetResult<Prisma.$FarmaciaUsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FarmaciaUsuarios.
     * @param {FarmaciaUsuarioDeleteManyArgs} args - Arguments to filter FarmaciaUsuarios to delete.
     * @example
     * // Delete a few FarmaciaUsuarios
     * const { count } = await prisma.farmaciaUsuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FarmaciaUsuarioDeleteManyArgs>(args?: SelectSubset<T, FarmaciaUsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FarmaciaUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaUsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FarmaciaUsuarios
     * const farmaciaUsuario = await prisma.farmaciaUsuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FarmaciaUsuarioUpdateManyArgs>(args: SelectSubset<T, FarmaciaUsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FarmaciaUsuario.
     * @param {FarmaciaUsuarioUpsertArgs} args - Arguments to update or create a FarmaciaUsuario.
     * @example
     * // Update or create a FarmaciaUsuario
     * const farmaciaUsuario = await prisma.farmaciaUsuario.upsert({
     *   create: {
     *     // ... data to create a FarmaciaUsuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FarmaciaUsuario we want to update
     *   }
     * })
     */
    upsert<T extends FarmaciaUsuarioUpsertArgs>(args: SelectSubset<T, FarmaciaUsuarioUpsertArgs<ExtArgs>>): Prisma__FarmaciaUsuarioClient<$Result.GetResult<Prisma.$FarmaciaUsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FarmaciaUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaUsuarioCountArgs} args - Arguments to filter FarmaciaUsuarios to count.
     * @example
     * // Count the number of FarmaciaUsuarios
     * const count = await prisma.farmaciaUsuario.count({
     *   where: {
     *     // ... the filter for the FarmaciaUsuarios we want to count
     *   }
     * })
    **/
    count<T extends FarmaciaUsuarioCountArgs>(
      args?: Subset<T, FarmaciaUsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FarmaciaUsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FarmaciaUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaUsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FarmaciaUsuarioAggregateArgs>(args: Subset<T, FarmaciaUsuarioAggregateArgs>): Prisma.PrismaPromise<GetFarmaciaUsuarioAggregateType<T>>

    /**
     * Group by FarmaciaUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmaciaUsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FarmaciaUsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FarmaciaUsuarioGroupByArgs['orderBy'] }
        : { orderBy?: FarmaciaUsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FarmaciaUsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFarmaciaUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FarmaciaUsuario model
   */
  readonly fields: FarmaciaUsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FarmaciaUsuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FarmaciaUsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    farmacia<T extends FarmaciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FarmaciaDefaultArgs<ExtArgs>>): Prisma__FarmaciaClient<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FarmaciaUsuario model
   */ 
  interface FarmaciaUsuarioFieldRefs {
    readonly id: FieldRef<"FarmaciaUsuario", 'String'>
    readonly farmaciaId: FieldRef<"FarmaciaUsuario", 'String'>
    readonly usuarioId: FieldRef<"FarmaciaUsuario", 'String'>
    readonly createdAt: FieldRef<"FarmaciaUsuario", 'DateTime'>
    readonly updatedAt: FieldRef<"FarmaciaUsuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FarmaciaUsuario findUnique
   */
  export type FarmaciaUsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which FarmaciaUsuario to fetch.
     */
    where: FarmaciaUsuarioWhereUniqueInput
  }

  /**
   * FarmaciaUsuario findUniqueOrThrow
   */
  export type FarmaciaUsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which FarmaciaUsuario to fetch.
     */
    where: FarmaciaUsuarioWhereUniqueInput
  }

  /**
   * FarmaciaUsuario findFirst
   */
  export type FarmaciaUsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which FarmaciaUsuario to fetch.
     */
    where?: FarmaciaUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FarmaciaUsuarios to fetch.
     */
    orderBy?: FarmaciaUsuarioOrderByWithRelationInput | FarmaciaUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FarmaciaUsuarios.
     */
    cursor?: FarmaciaUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FarmaciaUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FarmaciaUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FarmaciaUsuarios.
     */
    distinct?: FarmaciaUsuarioScalarFieldEnum | FarmaciaUsuarioScalarFieldEnum[]
  }

  /**
   * FarmaciaUsuario findFirstOrThrow
   */
  export type FarmaciaUsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which FarmaciaUsuario to fetch.
     */
    where?: FarmaciaUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FarmaciaUsuarios to fetch.
     */
    orderBy?: FarmaciaUsuarioOrderByWithRelationInput | FarmaciaUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FarmaciaUsuarios.
     */
    cursor?: FarmaciaUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FarmaciaUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FarmaciaUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FarmaciaUsuarios.
     */
    distinct?: FarmaciaUsuarioScalarFieldEnum | FarmaciaUsuarioScalarFieldEnum[]
  }

  /**
   * FarmaciaUsuario findMany
   */
  export type FarmaciaUsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which FarmaciaUsuarios to fetch.
     */
    where?: FarmaciaUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FarmaciaUsuarios to fetch.
     */
    orderBy?: FarmaciaUsuarioOrderByWithRelationInput | FarmaciaUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FarmaciaUsuarios.
     */
    cursor?: FarmaciaUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FarmaciaUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FarmaciaUsuarios.
     */
    skip?: number
    distinct?: FarmaciaUsuarioScalarFieldEnum | FarmaciaUsuarioScalarFieldEnum[]
  }

  /**
   * FarmaciaUsuario create
   */
  export type FarmaciaUsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a FarmaciaUsuario.
     */
    data: XOR<FarmaciaUsuarioCreateInput, FarmaciaUsuarioUncheckedCreateInput>
  }

  /**
   * FarmaciaUsuario createMany
   */
  export type FarmaciaUsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FarmaciaUsuarios.
     */
    data: FarmaciaUsuarioCreateManyInput | FarmaciaUsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FarmaciaUsuario createManyAndReturn
   */
  export type FarmaciaUsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FarmaciaUsuarios.
     */
    data: FarmaciaUsuarioCreateManyInput | FarmaciaUsuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FarmaciaUsuario update
   */
  export type FarmaciaUsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a FarmaciaUsuario.
     */
    data: XOR<FarmaciaUsuarioUpdateInput, FarmaciaUsuarioUncheckedUpdateInput>
    /**
     * Choose, which FarmaciaUsuario to update.
     */
    where: FarmaciaUsuarioWhereUniqueInput
  }

  /**
   * FarmaciaUsuario updateMany
   */
  export type FarmaciaUsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FarmaciaUsuarios.
     */
    data: XOR<FarmaciaUsuarioUpdateManyMutationInput, FarmaciaUsuarioUncheckedUpdateManyInput>
    /**
     * Filter which FarmaciaUsuarios to update
     */
    where?: FarmaciaUsuarioWhereInput
  }

  /**
   * FarmaciaUsuario upsert
   */
  export type FarmaciaUsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the FarmaciaUsuario to update in case it exists.
     */
    where: FarmaciaUsuarioWhereUniqueInput
    /**
     * In case the FarmaciaUsuario found by the `where` argument doesn't exist, create a new FarmaciaUsuario with this data.
     */
    create: XOR<FarmaciaUsuarioCreateInput, FarmaciaUsuarioUncheckedCreateInput>
    /**
     * In case the FarmaciaUsuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FarmaciaUsuarioUpdateInput, FarmaciaUsuarioUncheckedUpdateInput>
  }

  /**
   * FarmaciaUsuario delete
   */
  export type FarmaciaUsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioInclude<ExtArgs> | null
    /**
     * Filter which FarmaciaUsuario to delete.
     */
    where: FarmaciaUsuarioWhereUniqueInput
  }

  /**
   * FarmaciaUsuario deleteMany
   */
  export type FarmaciaUsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FarmaciaUsuarios to delete
     */
    where?: FarmaciaUsuarioWhereInput
  }

  /**
   * FarmaciaUsuario without action
   */
  export type FarmaciaUsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmaciaUsuario
     */
    select?: FarmaciaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmaciaUsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Indicador
   */

  export type AggregateIndicador = {
    _count: IndicadorCountAggregateOutputType | null
    _min: IndicadorMinAggregateOutputType | null
    _max: IndicadorMaxAggregateOutputType | null
  }

  export type IndicadorMinAggregateOutputType = {
    id: string | null
    codigo: string | null
    nome: string | null
    categoria: string | null
    unidade: string | null
    metaPadrao: string | null
    temImpacto: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicadorMaxAggregateOutputType = {
    id: string | null
    codigo: string | null
    nome: string | null
    categoria: string | null
    unidade: string | null
    metaPadrao: string | null
    temImpacto: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicadorCountAggregateOutputType = {
    id: number
    codigo: number
    nome: number
    categoria: number
    unidade: number
    metaPadrao: number
    temImpacto: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IndicadorMinAggregateInputType = {
    id?: true
    codigo?: true
    nome?: true
    categoria?: true
    unidade?: true
    metaPadrao?: true
    temImpacto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicadorMaxAggregateInputType = {
    id?: true
    codigo?: true
    nome?: true
    categoria?: true
    unidade?: true
    metaPadrao?: true
    temImpacto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicadorCountAggregateInputType = {
    id?: true
    codigo?: true
    nome?: true
    categoria?: true
    unidade?: true
    metaPadrao?: true
    temImpacto?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IndicadorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Indicador to aggregate.
     */
    where?: IndicadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicadors to fetch.
     */
    orderBy?: IndicadorOrderByWithRelationInput | IndicadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Indicadors
    **/
    _count?: true | IndicadorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicadorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicadorMaxAggregateInputType
  }

  export type GetIndicadorAggregateType<T extends IndicadorAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicador[P]>
      : GetScalarType<T[P], AggregateIndicador[P]>
  }




  export type IndicadorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicadorWhereInput
    orderBy?: IndicadorOrderByWithAggregationInput | IndicadorOrderByWithAggregationInput[]
    by: IndicadorScalarFieldEnum[] | IndicadorScalarFieldEnum
    having?: IndicadorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicadorCountAggregateInputType | true
    _min?: IndicadorMinAggregateInputType
    _max?: IndicadorMaxAggregateInputType
  }

  export type IndicadorGroupByOutputType = {
    id: string
    codigo: string
    nome: string
    categoria: string
    unidade: string
    metaPadrao: string
    temImpacto: boolean
    createdAt: Date
    updatedAt: Date
    _count: IndicadorCountAggregateOutputType | null
    _min: IndicadorMinAggregateOutputType | null
    _max: IndicadorMaxAggregateOutputType | null
  }

  type GetIndicadorGroupByPayload<T extends IndicadorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicadorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicadorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicadorGroupByOutputType[P]>
            : GetScalarType<T[P], IndicadorGroupByOutputType[P]>
        }
      >
    >


  export type IndicadorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nome?: boolean
    categoria?: boolean
    unidade?: boolean
    metaPadrao?: boolean
    temImpacto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planosAcao?: boolean | Indicador$planosAcaoArgs<ExtArgs>
    evidencias?: boolean | Indicador$evidenciasArgs<ExtArgs>
    relacionados?: boolean | Indicador$relacionadosArgs<ExtArgs>
    relacionadoA?: boolean | Indicador$relacionadoAArgs<ExtArgs>
    _count?: boolean | IndicadorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicador"]>

  export type IndicadorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nome?: boolean
    categoria?: boolean
    unidade?: boolean
    metaPadrao?: boolean
    temImpacto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["indicador"]>

  export type IndicadorSelectScalar = {
    id?: boolean
    codigo?: boolean
    nome?: boolean
    categoria?: boolean
    unidade?: boolean
    metaPadrao?: boolean
    temImpacto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IndicadorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planosAcao?: boolean | Indicador$planosAcaoArgs<ExtArgs>
    evidencias?: boolean | Indicador$evidenciasArgs<ExtArgs>
    relacionados?: boolean | Indicador$relacionadosArgs<ExtArgs>
    relacionadoA?: boolean | Indicador$relacionadoAArgs<ExtArgs>
    _count?: boolean | IndicadorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IndicadorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IndicadorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Indicador"
    objects: {
      planosAcao: Prisma.$PlanoAcaoPayload<ExtArgs>[]
      evidencias: Prisma.$EvidenciaPayload<ExtArgs>[]
      relacionados: Prisma.$IndicadorRelacionadoPayload<ExtArgs>[]
      relacionadoA: Prisma.$IndicadorRelacionadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      codigo: string
      nome: string
      categoria: string
      unidade: string
      metaPadrao: string
      temImpacto: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["indicador"]>
    composites: {}
  }

  type IndicadorGetPayload<S extends boolean | null | undefined | IndicadorDefaultArgs> = $Result.GetResult<Prisma.$IndicadorPayload, S>

  type IndicadorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IndicadorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IndicadorCountAggregateInputType | true
    }

  export interface IndicadorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Indicador'], meta: { name: 'Indicador' } }
    /**
     * Find zero or one Indicador that matches the filter.
     * @param {IndicadorFindUniqueArgs} args - Arguments to find a Indicador
     * @example
     * // Get one Indicador
     * const indicador = await prisma.indicador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicadorFindUniqueArgs>(args: SelectSubset<T, IndicadorFindUniqueArgs<ExtArgs>>): Prisma__IndicadorClient<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Indicador that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IndicadorFindUniqueOrThrowArgs} args - Arguments to find a Indicador
     * @example
     * // Get one Indicador
     * const indicador = await prisma.indicador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicadorFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicadorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicadorClient<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Indicador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorFindFirstArgs} args - Arguments to find a Indicador
     * @example
     * // Get one Indicador
     * const indicador = await prisma.indicador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicadorFindFirstArgs>(args?: SelectSubset<T, IndicadorFindFirstArgs<ExtArgs>>): Prisma__IndicadorClient<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Indicador that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorFindFirstOrThrowArgs} args - Arguments to find a Indicador
     * @example
     * // Get one Indicador
     * const indicador = await prisma.indicador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicadorFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicadorFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicadorClient<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Indicadors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Indicadors
     * const indicadors = await prisma.indicador.findMany()
     * 
     * // Get first 10 Indicadors
     * const indicadors = await prisma.indicador.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicadorWithIdOnly = await prisma.indicador.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicadorFindManyArgs>(args?: SelectSubset<T, IndicadorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Indicador.
     * @param {IndicadorCreateArgs} args - Arguments to create a Indicador.
     * @example
     * // Create one Indicador
     * const Indicador = await prisma.indicador.create({
     *   data: {
     *     // ... data to create a Indicador
     *   }
     * })
     * 
     */
    create<T extends IndicadorCreateArgs>(args: SelectSubset<T, IndicadorCreateArgs<ExtArgs>>): Prisma__IndicadorClient<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Indicadors.
     * @param {IndicadorCreateManyArgs} args - Arguments to create many Indicadors.
     * @example
     * // Create many Indicadors
     * const indicador = await prisma.indicador.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicadorCreateManyArgs>(args?: SelectSubset<T, IndicadorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Indicadors and returns the data saved in the database.
     * @param {IndicadorCreateManyAndReturnArgs} args - Arguments to create many Indicadors.
     * @example
     * // Create many Indicadors
     * const indicador = await prisma.indicador.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Indicadors and only return the `id`
     * const indicadorWithIdOnly = await prisma.indicador.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicadorCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicadorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Indicador.
     * @param {IndicadorDeleteArgs} args - Arguments to delete one Indicador.
     * @example
     * // Delete one Indicador
     * const Indicador = await prisma.indicador.delete({
     *   where: {
     *     // ... filter to delete one Indicador
     *   }
     * })
     * 
     */
    delete<T extends IndicadorDeleteArgs>(args: SelectSubset<T, IndicadorDeleteArgs<ExtArgs>>): Prisma__IndicadorClient<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Indicador.
     * @param {IndicadorUpdateArgs} args - Arguments to update one Indicador.
     * @example
     * // Update one Indicador
     * const indicador = await prisma.indicador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicadorUpdateArgs>(args: SelectSubset<T, IndicadorUpdateArgs<ExtArgs>>): Prisma__IndicadorClient<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Indicadors.
     * @param {IndicadorDeleteManyArgs} args - Arguments to filter Indicadors to delete.
     * @example
     * // Delete a few Indicadors
     * const { count } = await prisma.indicador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicadorDeleteManyArgs>(args?: SelectSubset<T, IndicadorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Indicadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Indicadors
     * const indicador = await prisma.indicador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicadorUpdateManyArgs>(args: SelectSubset<T, IndicadorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Indicador.
     * @param {IndicadorUpsertArgs} args - Arguments to update or create a Indicador.
     * @example
     * // Update or create a Indicador
     * const indicador = await prisma.indicador.upsert({
     *   create: {
     *     // ... data to create a Indicador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Indicador we want to update
     *   }
     * })
     */
    upsert<T extends IndicadorUpsertArgs>(args: SelectSubset<T, IndicadorUpsertArgs<ExtArgs>>): Prisma__IndicadorClient<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Indicadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorCountArgs} args - Arguments to filter Indicadors to count.
     * @example
     * // Count the number of Indicadors
     * const count = await prisma.indicador.count({
     *   where: {
     *     // ... the filter for the Indicadors we want to count
     *   }
     * })
    **/
    count<T extends IndicadorCountArgs>(
      args?: Subset<T, IndicadorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicadorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Indicador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicadorAggregateArgs>(args: Subset<T, IndicadorAggregateArgs>): Prisma.PrismaPromise<GetIndicadorAggregateType<T>>

    /**
     * Group by Indicador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicadorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicadorGroupByArgs['orderBy'] }
        : { orderBy?: IndicadorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicadorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicadorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Indicador model
   */
  readonly fields: IndicadorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Indicador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicadorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planosAcao<T extends Indicador$planosAcaoArgs<ExtArgs> = {}>(args?: Subset<T, Indicador$planosAcaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "findMany"> | Null>
    evidencias<T extends Indicador$evidenciasArgs<ExtArgs> = {}>(args?: Subset<T, Indicador$evidenciasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findMany"> | Null>
    relacionados<T extends Indicador$relacionadosArgs<ExtArgs> = {}>(args?: Subset<T, Indicador$relacionadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicadorRelacionadoPayload<ExtArgs>, T, "findMany"> | Null>
    relacionadoA<T extends Indicador$relacionadoAArgs<ExtArgs> = {}>(args?: Subset<T, Indicador$relacionadoAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicadorRelacionadoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Indicador model
   */ 
  interface IndicadorFieldRefs {
    readonly id: FieldRef<"Indicador", 'String'>
    readonly codigo: FieldRef<"Indicador", 'String'>
    readonly nome: FieldRef<"Indicador", 'String'>
    readonly categoria: FieldRef<"Indicador", 'String'>
    readonly unidade: FieldRef<"Indicador", 'String'>
    readonly metaPadrao: FieldRef<"Indicador", 'String'>
    readonly temImpacto: FieldRef<"Indicador", 'Boolean'>
    readonly createdAt: FieldRef<"Indicador", 'DateTime'>
    readonly updatedAt: FieldRef<"Indicador", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Indicador findUnique
   */
  export type IndicadorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicador
     */
    select?: IndicadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorInclude<ExtArgs> | null
    /**
     * Filter, which Indicador to fetch.
     */
    where: IndicadorWhereUniqueInput
  }

  /**
   * Indicador findUniqueOrThrow
   */
  export type IndicadorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicador
     */
    select?: IndicadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorInclude<ExtArgs> | null
    /**
     * Filter, which Indicador to fetch.
     */
    where: IndicadorWhereUniqueInput
  }

  /**
   * Indicador findFirst
   */
  export type IndicadorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicador
     */
    select?: IndicadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorInclude<ExtArgs> | null
    /**
     * Filter, which Indicador to fetch.
     */
    where?: IndicadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicadors to fetch.
     */
    orderBy?: IndicadorOrderByWithRelationInput | IndicadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Indicadors.
     */
    cursor?: IndicadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Indicadors.
     */
    distinct?: IndicadorScalarFieldEnum | IndicadorScalarFieldEnum[]
  }

  /**
   * Indicador findFirstOrThrow
   */
  export type IndicadorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicador
     */
    select?: IndicadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorInclude<ExtArgs> | null
    /**
     * Filter, which Indicador to fetch.
     */
    where?: IndicadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicadors to fetch.
     */
    orderBy?: IndicadorOrderByWithRelationInput | IndicadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Indicadors.
     */
    cursor?: IndicadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Indicadors.
     */
    distinct?: IndicadorScalarFieldEnum | IndicadorScalarFieldEnum[]
  }

  /**
   * Indicador findMany
   */
  export type IndicadorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicador
     */
    select?: IndicadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorInclude<ExtArgs> | null
    /**
     * Filter, which Indicadors to fetch.
     */
    where?: IndicadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicadors to fetch.
     */
    orderBy?: IndicadorOrderByWithRelationInput | IndicadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Indicadors.
     */
    cursor?: IndicadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicadors.
     */
    skip?: number
    distinct?: IndicadorScalarFieldEnum | IndicadorScalarFieldEnum[]
  }

  /**
   * Indicador create
   */
  export type IndicadorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicador
     */
    select?: IndicadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorInclude<ExtArgs> | null
    /**
     * The data needed to create a Indicador.
     */
    data: XOR<IndicadorCreateInput, IndicadorUncheckedCreateInput>
  }

  /**
   * Indicador createMany
   */
  export type IndicadorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Indicadors.
     */
    data: IndicadorCreateManyInput | IndicadorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Indicador createManyAndReturn
   */
  export type IndicadorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicador
     */
    select?: IndicadorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Indicadors.
     */
    data: IndicadorCreateManyInput | IndicadorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Indicador update
   */
  export type IndicadorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicador
     */
    select?: IndicadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorInclude<ExtArgs> | null
    /**
     * The data needed to update a Indicador.
     */
    data: XOR<IndicadorUpdateInput, IndicadorUncheckedUpdateInput>
    /**
     * Choose, which Indicador to update.
     */
    where: IndicadorWhereUniqueInput
  }

  /**
   * Indicador updateMany
   */
  export type IndicadorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Indicadors.
     */
    data: XOR<IndicadorUpdateManyMutationInput, IndicadorUncheckedUpdateManyInput>
    /**
     * Filter which Indicadors to update
     */
    where?: IndicadorWhereInput
  }

  /**
   * Indicador upsert
   */
  export type IndicadorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicador
     */
    select?: IndicadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorInclude<ExtArgs> | null
    /**
     * The filter to search for the Indicador to update in case it exists.
     */
    where: IndicadorWhereUniqueInput
    /**
     * In case the Indicador found by the `where` argument doesn't exist, create a new Indicador with this data.
     */
    create: XOR<IndicadorCreateInput, IndicadorUncheckedCreateInput>
    /**
     * In case the Indicador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicadorUpdateInput, IndicadorUncheckedUpdateInput>
  }

  /**
   * Indicador delete
   */
  export type IndicadorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicador
     */
    select?: IndicadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorInclude<ExtArgs> | null
    /**
     * Filter which Indicador to delete.
     */
    where: IndicadorWhereUniqueInput
  }

  /**
   * Indicador deleteMany
   */
  export type IndicadorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Indicadors to delete
     */
    where?: IndicadorWhereInput
  }

  /**
   * Indicador.planosAcao
   */
  export type Indicador$planosAcaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
    where?: PlanoAcaoWhereInput
    orderBy?: PlanoAcaoOrderByWithRelationInput | PlanoAcaoOrderByWithRelationInput[]
    cursor?: PlanoAcaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanoAcaoScalarFieldEnum | PlanoAcaoScalarFieldEnum[]
  }

  /**
   * Indicador.evidencias
   */
  export type Indicador$evidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    where?: EvidenciaWhereInput
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    cursor?: EvidenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Indicador.relacionados
   */
  export type Indicador$relacionadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoInclude<ExtArgs> | null
    where?: IndicadorRelacionadoWhereInput
    orderBy?: IndicadorRelacionadoOrderByWithRelationInput | IndicadorRelacionadoOrderByWithRelationInput[]
    cursor?: IndicadorRelacionadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicadorRelacionadoScalarFieldEnum | IndicadorRelacionadoScalarFieldEnum[]
  }

  /**
   * Indicador.relacionadoA
   */
  export type Indicador$relacionadoAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoInclude<ExtArgs> | null
    where?: IndicadorRelacionadoWhereInput
    orderBy?: IndicadorRelacionadoOrderByWithRelationInput | IndicadorRelacionadoOrderByWithRelationInput[]
    cursor?: IndicadorRelacionadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicadorRelacionadoScalarFieldEnum | IndicadorRelacionadoScalarFieldEnum[]
  }

  /**
   * Indicador without action
   */
  export type IndicadorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicador
     */
    select?: IndicadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorInclude<ExtArgs> | null
  }


  /**
   * Model IndicadorRelacionado
   */

  export type AggregateIndicadorRelacionado = {
    _count: IndicadorRelacionadoCountAggregateOutputType | null
    _min: IndicadorRelacionadoMinAggregateOutputType | null
    _max: IndicadorRelacionadoMaxAggregateOutputType | null
  }

  export type IndicadorRelacionadoMinAggregateOutputType = {
    id: string | null
    indicadorOrigemId: string | null
    indicadorDestinoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicadorRelacionadoMaxAggregateOutputType = {
    id: string | null
    indicadorOrigemId: string | null
    indicadorDestinoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicadorRelacionadoCountAggregateOutputType = {
    id: number
    indicadorOrigemId: number
    indicadorDestinoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IndicadorRelacionadoMinAggregateInputType = {
    id?: true
    indicadorOrigemId?: true
    indicadorDestinoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicadorRelacionadoMaxAggregateInputType = {
    id?: true
    indicadorOrigemId?: true
    indicadorDestinoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicadorRelacionadoCountAggregateInputType = {
    id?: true
    indicadorOrigemId?: true
    indicadorDestinoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IndicadorRelacionadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicadorRelacionado to aggregate.
     */
    where?: IndicadorRelacionadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicadorRelacionados to fetch.
     */
    orderBy?: IndicadorRelacionadoOrderByWithRelationInput | IndicadorRelacionadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicadorRelacionadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicadorRelacionados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicadorRelacionados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndicadorRelacionados
    **/
    _count?: true | IndicadorRelacionadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicadorRelacionadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicadorRelacionadoMaxAggregateInputType
  }

  export type GetIndicadorRelacionadoAggregateType<T extends IndicadorRelacionadoAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicadorRelacionado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicadorRelacionado[P]>
      : GetScalarType<T[P], AggregateIndicadorRelacionado[P]>
  }




  export type IndicadorRelacionadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicadorRelacionadoWhereInput
    orderBy?: IndicadorRelacionadoOrderByWithAggregationInput | IndicadorRelacionadoOrderByWithAggregationInput[]
    by: IndicadorRelacionadoScalarFieldEnum[] | IndicadorRelacionadoScalarFieldEnum
    having?: IndicadorRelacionadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicadorRelacionadoCountAggregateInputType | true
    _min?: IndicadorRelacionadoMinAggregateInputType
    _max?: IndicadorRelacionadoMaxAggregateInputType
  }

  export type IndicadorRelacionadoGroupByOutputType = {
    id: string
    indicadorOrigemId: string
    indicadorDestinoId: string
    createdAt: Date
    updatedAt: Date
    _count: IndicadorRelacionadoCountAggregateOutputType | null
    _min: IndicadorRelacionadoMinAggregateOutputType | null
    _max: IndicadorRelacionadoMaxAggregateOutputType | null
  }

  type GetIndicadorRelacionadoGroupByPayload<T extends IndicadorRelacionadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicadorRelacionadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicadorRelacionadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicadorRelacionadoGroupByOutputType[P]>
            : GetScalarType<T[P], IndicadorRelacionadoGroupByOutputType[P]>
        }
      >
    >


  export type IndicadorRelacionadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicadorOrigemId?: boolean
    indicadorDestinoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    indicadorOrigem?: boolean | IndicadorDefaultArgs<ExtArgs>
    indicadorDestino?: boolean | IndicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicadorRelacionado"]>

  export type IndicadorRelacionadoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicadorOrigemId?: boolean
    indicadorDestinoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    indicadorOrigem?: boolean | IndicadorDefaultArgs<ExtArgs>
    indicadorDestino?: boolean | IndicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicadorRelacionado"]>

  export type IndicadorRelacionadoSelectScalar = {
    id?: boolean
    indicadorOrigemId?: boolean
    indicadorDestinoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IndicadorRelacionadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicadorOrigem?: boolean | IndicadorDefaultArgs<ExtArgs>
    indicadorDestino?: boolean | IndicadorDefaultArgs<ExtArgs>
  }
  export type IndicadorRelacionadoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicadorOrigem?: boolean | IndicadorDefaultArgs<ExtArgs>
    indicadorDestino?: boolean | IndicadorDefaultArgs<ExtArgs>
  }

  export type $IndicadorRelacionadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndicadorRelacionado"
    objects: {
      indicadorOrigem: Prisma.$IndicadorPayload<ExtArgs>
      indicadorDestino: Prisma.$IndicadorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      indicadorOrigemId: string
      indicadorDestinoId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["indicadorRelacionado"]>
    composites: {}
  }

  type IndicadorRelacionadoGetPayload<S extends boolean | null | undefined | IndicadorRelacionadoDefaultArgs> = $Result.GetResult<Prisma.$IndicadorRelacionadoPayload, S>

  type IndicadorRelacionadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IndicadorRelacionadoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IndicadorRelacionadoCountAggregateInputType | true
    }

  export interface IndicadorRelacionadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndicadorRelacionado'], meta: { name: 'IndicadorRelacionado' } }
    /**
     * Find zero or one IndicadorRelacionado that matches the filter.
     * @param {IndicadorRelacionadoFindUniqueArgs} args - Arguments to find a IndicadorRelacionado
     * @example
     * // Get one IndicadorRelacionado
     * const indicadorRelacionado = await prisma.indicadorRelacionado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicadorRelacionadoFindUniqueArgs>(args: SelectSubset<T, IndicadorRelacionadoFindUniqueArgs<ExtArgs>>): Prisma__IndicadorRelacionadoClient<$Result.GetResult<Prisma.$IndicadorRelacionadoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IndicadorRelacionado that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IndicadorRelacionadoFindUniqueOrThrowArgs} args - Arguments to find a IndicadorRelacionado
     * @example
     * // Get one IndicadorRelacionado
     * const indicadorRelacionado = await prisma.indicadorRelacionado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicadorRelacionadoFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicadorRelacionadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicadorRelacionadoClient<$Result.GetResult<Prisma.$IndicadorRelacionadoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IndicadorRelacionado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorRelacionadoFindFirstArgs} args - Arguments to find a IndicadorRelacionado
     * @example
     * // Get one IndicadorRelacionado
     * const indicadorRelacionado = await prisma.indicadorRelacionado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicadorRelacionadoFindFirstArgs>(args?: SelectSubset<T, IndicadorRelacionadoFindFirstArgs<ExtArgs>>): Prisma__IndicadorRelacionadoClient<$Result.GetResult<Prisma.$IndicadorRelacionadoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IndicadorRelacionado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorRelacionadoFindFirstOrThrowArgs} args - Arguments to find a IndicadorRelacionado
     * @example
     * // Get one IndicadorRelacionado
     * const indicadorRelacionado = await prisma.indicadorRelacionado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicadorRelacionadoFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicadorRelacionadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicadorRelacionadoClient<$Result.GetResult<Prisma.$IndicadorRelacionadoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IndicadorRelacionados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorRelacionadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndicadorRelacionados
     * const indicadorRelacionados = await prisma.indicadorRelacionado.findMany()
     * 
     * // Get first 10 IndicadorRelacionados
     * const indicadorRelacionados = await prisma.indicadorRelacionado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicadorRelacionadoWithIdOnly = await prisma.indicadorRelacionado.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicadorRelacionadoFindManyArgs>(args?: SelectSubset<T, IndicadorRelacionadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicadorRelacionadoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IndicadorRelacionado.
     * @param {IndicadorRelacionadoCreateArgs} args - Arguments to create a IndicadorRelacionado.
     * @example
     * // Create one IndicadorRelacionado
     * const IndicadorRelacionado = await prisma.indicadorRelacionado.create({
     *   data: {
     *     // ... data to create a IndicadorRelacionado
     *   }
     * })
     * 
     */
    create<T extends IndicadorRelacionadoCreateArgs>(args: SelectSubset<T, IndicadorRelacionadoCreateArgs<ExtArgs>>): Prisma__IndicadorRelacionadoClient<$Result.GetResult<Prisma.$IndicadorRelacionadoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IndicadorRelacionados.
     * @param {IndicadorRelacionadoCreateManyArgs} args - Arguments to create many IndicadorRelacionados.
     * @example
     * // Create many IndicadorRelacionados
     * const indicadorRelacionado = await prisma.indicadorRelacionado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicadorRelacionadoCreateManyArgs>(args?: SelectSubset<T, IndicadorRelacionadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IndicadorRelacionados and returns the data saved in the database.
     * @param {IndicadorRelacionadoCreateManyAndReturnArgs} args - Arguments to create many IndicadorRelacionados.
     * @example
     * // Create many IndicadorRelacionados
     * const indicadorRelacionado = await prisma.indicadorRelacionado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IndicadorRelacionados and only return the `id`
     * const indicadorRelacionadoWithIdOnly = await prisma.indicadorRelacionado.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicadorRelacionadoCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicadorRelacionadoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicadorRelacionadoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IndicadorRelacionado.
     * @param {IndicadorRelacionadoDeleteArgs} args - Arguments to delete one IndicadorRelacionado.
     * @example
     * // Delete one IndicadorRelacionado
     * const IndicadorRelacionado = await prisma.indicadorRelacionado.delete({
     *   where: {
     *     // ... filter to delete one IndicadorRelacionado
     *   }
     * })
     * 
     */
    delete<T extends IndicadorRelacionadoDeleteArgs>(args: SelectSubset<T, IndicadorRelacionadoDeleteArgs<ExtArgs>>): Prisma__IndicadorRelacionadoClient<$Result.GetResult<Prisma.$IndicadorRelacionadoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IndicadorRelacionado.
     * @param {IndicadorRelacionadoUpdateArgs} args - Arguments to update one IndicadorRelacionado.
     * @example
     * // Update one IndicadorRelacionado
     * const indicadorRelacionado = await prisma.indicadorRelacionado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicadorRelacionadoUpdateArgs>(args: SelectSubset<T, IndicadorRelacionadoUpdateArgs<ExtArgs>>): Prisma__IndicadorRelacionadoClient<$Result.GetResult<Prisma.$IndicadorRelacionadoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IndicadorRelacionados.
     * @param {IndicadorRelacionadoDeleteManyArgs} args - Arguments to filter IndicadorRelacionados to delete.
     * @example
     * // Delete a few IndicadorRelacionados
     * const { count } = await prisma.indicadorRelacionado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicadorRelacionadoDeleteManyArgs>(args?: SelectSubset<T, IndicadorRelacionadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndicadorRelacionados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorRelacionadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndicadorRelacionados
     * const indicadorRelacionado = await prisma.indicadorRelacionado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicadorRelacionadoUpdateManyArgs>(args: SelectSubset<T, IndicadorRelacionadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IndicadorRelacionado.
     * @param {IndicadorRelacionadoUpsertArgs} args - Arguments to update or create a IndicadorRelacionado.
     * @example
     * // Update or create a IndicadorRelacionado
     * const indicadorRelacionado = await prisma.indicadorRelacionado.upsert({
     *   create: {
     *     // ... data to create a IndicadorRelacionado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndicadorRelacionado we want to update
     *   }
     * })
     */
    upsert<T extends IndicadorRelacionadoUpsertArgs>(args: SelectSubset<T, IndicadorRelacionadoUpsertArgs<ExtArgs>>): Prisma__IndicadorRelacionadoClient<$Result.GetResult<Prisma.$IndicadorRelacionadoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IndicadorRelacionados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorRelacionadoCountArgs} args - Arguments to filter IndicadorRelacionados to count.
     * @example
     * // Count the number of IndicadorRelacionados
     * const count = await prisma.indicadorRelacionado.count({
     *   where: {
     *     // ... the filter for the IndicadorRelacionados we want to count
     *   }
     * })
    **/
    count<T extends IndicadorRelacionadoCountArgs>(
      args?: Subset<T, IndicadorRelacionadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicadorRelacionadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndicadorRelacionado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorRelacionadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicadorRelacionadoAggregateArgs>(args: Subset<T, IndicadorRelacionadoAggregateArgs>): Prisma.PrismaPromise<GetIndicadorRelacionadoAggregateType<T>>

    /**
     * Group by IndicadorRelacionado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorRelacionadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicadorRelacionadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicadorRelacionadoGroupByArgs['orderBy'] }
        : { orderBy?: IndicadorRelacionadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicadorRelacionadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicadorRelacionadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndicadorRelacionado model
   */
  readonly fields: IndicadorRelacionadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndicadorRelacionado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicadorRelacionadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    indicadorOrigem<T extends IndicadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicadorDefaultArgs<ExtArgs>>): Prisma__IndicadorClient<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    indicadorDestino<T extends IndicadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicadorDefaultArgs<ExtArgs>>): Prisma__IndicadorClient<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IndicadorRelacionado model
   */ 
  interface IndicadorRelacionadoFieldRefs {
    readonly id: FieldRef<"IndicadorRelacionado", 'String'>
    readonly indicadorOrigemId: FieldRef<"IndicadorRelacionado", 'String'>
    readonly indicadorDestinoId: FieldRef<"IndicadorRelacionado", 'String'>
    readonly createdAt: FieldRef<"IndicadorRelacionado", 'DateTime'>
    readonly updatedAt: FieldRef<"IndicadorRelacionado", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IndicadorRelacionado findUnique
   */
  export type IndicadorRelacionadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoInclude<ExtArgs> | null
    /**
     * Filter, which IndicadorRelacionado to fetch.
     */
    where: IndicadorRelacionadoWhereUniqueInput
  }

  /**
   * IndicadorRelacionado findUniqueOrThrow
   */
  export type IndicadorRelacionadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoInclude<ExtArgs> | null
    /**
     * Filter, which IndicadorRelacionado to fetch.
     */
    where: IndicadorRelacionadoWhereUniqueInput
  }

  /**
   * IndicadorRelacionado findFirst
   */
  export type IndicadorRelacionadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoInclude<ExtArgs> | null
    /**
     * Filter, which IndicadorRelacionado to fetch.
     */
    where?: IndicadorRelacionadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicadorRelacionados to fetch.
     */
    orderBy?: IndicadorRelacionadoOrderByWithRelationInput | IndicadorRelacionadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicadorRelacionados.
     */
    cursor?: IndicadorRelacionadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicadorRelacionados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicadorRelacionados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicadorRelacionados.
     */
    distinct?: IndicadorRelacionadoScalarFieldEnum | IndicadorRelacionadoScalarFieldEnum[]
  }

  /**
   * IndicadorRelacionado findFirstOrThrow
   */
  export type IndicadorRelacionadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoInclude<ExtArgs> | null
    /**
     * Filter, which IndicadorRelacionado to fetch.
     */
    where?: IndicadorRelacionadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicadorRelacionados to fetch.
     */
    orderBy?: IndicadorRelacionadoOrderByWithRelationInput | IndicadorRelacionadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicadorRelacionados.
     */
    cursor?: IndicadorRelacionadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicadorRelacionados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicadorRelacionados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicadorRelacionados.
     */
    distinct?: IndicadorRelacionadoScalarFieldEnum | IndicadorRelacionadoScalarFieldEnum[]
  }

  /**
   * IndicadorRelacionado findMany
   */
  export type IndicadorRelacionadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoInclude<ExtArgs> | null
    /**
     * Filter, which IndicadorRelacionados to fetch.
     */
    where?: IndicadorRelacionadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicadorRelacionados to fetch.
     */
    orderBy?: IndicadorRelacionadoOrderByWithRelationInput | IndicadorRelacionadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndicadorRelacionados.
     */
    cursor?: IndicadorRelacionadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicadorRelacionados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicadorRelacionados.
     */
    skip?: number
    distinct?: IndicadorRelacionadoScalarFieldEnum | IndicadorRelacionadoScalarFieldEnum[]
  }

  /**
   * IndicadorRelacionado create
   */
  export type IndicadorRelacionadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoInclude<ExtArgs> | null
    /**
     * The data needed to create a IndicadorRelacionado.
     */
    data: XOR<IndicadorRelacionadoCreateInput, IndicadorRelacionadoUncheckedCreateInput>
  }

  /**
   * IndicadorRelacionado createMany
   */
  export type IndicadorRelacionadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndicadorRelacionados.
     */
    data: IndicadorRelacionadoCreateManyInput | IndicadorRelacionadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndicadorRelacionado createManyAndReturn
   */
  export type IndicadorRelacionadoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IndicadorRelacionados.
     */
    data: IndicadorRelacionadoCreateManyInput | IndicadorRelacionadoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IndicadorRelacionado update
   */
  export type IndicadorRelacionadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoInclude<ExtArgs> | null
    /**
     * The data needed to update a IndicadorRelacionado.
     */
    data: XOR<IndicadorRelacionadoUpdateInput, IndicadorRelacionadoUncheckedUpdateInput>
    /**
     * Choose, which IndicadorRelacionado to update.
     */
    where: IndicadorRelacionadoWhereUniqueInput
  }

  /**
   * IndicadorRelacionado updateMany
   */
  export type IndicadorRelacionadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndicadorRelacionados.
     */
    data: XOR<IndicadorRelacionadoUpdateManyMutationInput, IndicadorRelacionadoUncheckedUpdateManyInput>
    /**
     * Filter which IndicadorRelacionados to update
     */
    where?: IndicadorRelacionadoWhereInput
  }

  /**
   * IndicadorRelacionado upsert
   */
  export type IndicadorRelacionadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoInclude<ExtArgs> | null
    /**
     * The filter to search for the IndicadorRelacionado to update in case it exists.
     */
    where: IndicadorRelacionadoWhereUniqueInput
    /**
     * In case the IndicadorRelacionado found by the `where` argument doesn't exist, create a new IndicadorRelacionado with this data.
     */
    create: XOR<IndicadorRelacionadoCreateInput, IndicadorRelacionadoUncheckedCreateInput>
    /**
     * In case the IndicadorRelacionado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicadorRelacionadoUpdateInput, IndicadorRelacionadoUncheckedUpdateInput>
  }

  /**
   * IndicadorRelacionado delete
   */
  export type IndicadorRelacionadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoInclude<ExtArgs> | null
    /**
     * Filter which IndicadorRelacionado to delete.
     */
    where: IndicadorRelacionadoWhereUniqueInput
  }

  /**
   * IndicadorRelacionado deleteMany
   */
  export type IndicadorRelacionadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicadorRelacionados to delete
     */
    where?: IndicadorRelacionadoWhereInput
  }

  /**
   * IndicadorRelacionado without action
   */
  export type IndicadorRelacionadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorRelacionado
     */
    select?: IndicadorRelacionadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicadorRelacionadoInclude<ExtArgs> | null
  }


  /**
   * Model PlanoAcao
   */

  export type AggregatePlanoAcao = {
    _count: PlanoAcaoCountAggregateOutputType | null
    _avg: PlanoAcaoAvgAggregateOutputType | null
    _sum: PlanoAcaoSumAggregateOutputType | null
    _min: PlanoAcaoMinAggregateOutputType | null
    _max: PlanoAcaoMaxAggregateOutputType | null
  }

  export type PlanoAcaoAvgAggregateOutputType = {
    percentualConcluido: number | null
  }

  export type PlanoAcaoSumAggregateOutputType = {
    percentualConcluido: number | null
  }

  export type PlanoAcaoMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    descricao: string | null
    farmaciaId: string | null
    indicadorId: string | null
    responsavelId: string | null
    dataCriacao: Date | null
    prazo: Date | null
    status: string | null
    percentualConcluido: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanoAcaoMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    descricao: string | null
    farmaciaId: string | null
    indicadorId: string | null
    responsavelId: string | null
    dataCriacao: Date | null
    prazo: Date | null
    status: string | null
    percentualConcluido: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanoAcaoCountAggregateOutputType = {
    id: number
    titulo: number
    descricao: number
    farmaciaId: number
    indicadorId: number
    responsavelId: number
    dataCriacao: number
    prazo: number
    status: number
    percentualConcluido: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanoAcaoAvgAggregateInputType = {
    percentualConcluido?: true
  }

  export type PlanoAcaoSumAggregateInputType = {
    percentualConcluido?: true
  }

  export type PlanoAcaoMinAggregateInputType = {
    id?: true
    titulo?: true
    descricao?: true
    farmaciaId?: true
    indicadorId?: true
    responsavelId?: true
    dataCriacao?: true
    prazo?: true
    status?: true
    percentualConcluido?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanoAcaoMaxAggregateInputType = {
    id?: true
    titulo?: true
    descricao?: true
    farmaciaId?: true
    indicadorId?: true
    responsavelId?: true
    dataCriacao?: true
    prazo?: true
    status?: true
    percentualConcluido?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanoAcaoCountAggregateInputType = {
    id?: true
    titulo?: true
    descricao?: true
    farmaciaId?: true
    indicadorId?: true
    responsavelId?: true
    dataCriacao?: true
    prazo?: true
    status?: true
    percentualConcluido?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanoAcaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanoAcao to aggregate.
     */
    where?: PlanoAcaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanoAcaos to fetch.
     */
    orderBy?: PlanoAcaoOrderByWithRelationInput | PlanoAcaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanoAcaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanoAcaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanoAcaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanoAcaos
    **/
    _count?: true | PlanoAcaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanoAcaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanoAcaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanoAcaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanoAcaoMaxAggregateInputType
  }

  export type GetPlanoAcaoAggregateType<T extends PlanoAcaoAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanoAcao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanoAcao[P]>
      : GetScalarType<T[P], AggregatePlanoAcao[P]>
  }




  export type PlanoAcaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanoAcaoWhereInput
    orderBy?: PlanoAcaoOrderByWithAggregationInput | PlanoAcaoOrderByWithAggregationInput[]
    by: PlanoAcaoScalarFieldEnum[] | PlanoAcaoScalarFieldEnum
    having?: PlanoAcaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanoAcaoCountAggregateInputType | true
    _avg?: PlanoAcaoAvgAggregateInputType
    _sum?: PlanoAcaoSumAggregateInputType
    _min?: PlanoAcaoMinAggregateInputType
    _max?: PlanoAcaoMaxAggregateInputType
  }

  export type PlanoAcaoGroupByOutputType = {
    id: string
    titulo: string
    descricao: string
    farmaciaId: string
    indicadorId: string
    responsavelId: string
    dataCriacao: Date
    prazo: Date
    status: string
    percentualConcluido: number
    createdAt: Date
    updatedAt: Date
    _count: PlanoAcaoCountAggregateOutputType | null
    _avg: PlanoAcaoAvgAggregateOutputType | null
    _sum: PlanoAcaoSumAggregateOutputType | null
    _min: PlanoAcaoMinAggregateOutputType | null
    _max: PlanoAcaoMaxAggregateOutputType | null
  }

  type GetPlanoAcaoGroupByPayload<T extends PlanoAcaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanoAcaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanoAcaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanoAcaoGroupByOutputType[P]>
            : GetScalarType<T[P], PlanoAcaoGroupByOutputType[P]>
        }
      >
    >


  export type PlanoAcaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descricao?: boolean
    farmaciaId?: boolean
    indicadorId?: boolean
    responsavelId?: boolean
    dataCriacao?: boolean
    prazo?: boolean
    status?: boolean
    percentualConcluido?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    indicador?: boolean | IndicadorDefaultArgs<ExtArgs>
    responsavel?: boolean | UsuarioDefaultArgs<ExtArgs>
    acoes?: boolean | PlanoAcao$acoesArgs<ExtArgs>
    comentarios?: boolean | PlanoAcao$comentariosArgs<ExtArgs>
    evidencias?: boolean | PlanoAcao$evidenciasArgs<ExtArgs>
    _count?: boolean | PlanoAcaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planoAcao"]>

  export type PlanoAcaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descricao?: boolean
    farmaciaId?: boolean
    indicadorId?: boolean
    responsavelId?: boolean
    dataCriacao?: boolean
    prazo?: boolean
    status?: boolean
    percentualConcluido?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    indicador?: boolean | IndicadorDefaultArgs<ExtArgs>
    responsavel?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planoAcao"]>

  export type PlanoAcaoSelectScalar = {
    id?: boolean
    titulo?: boolean
    descricao?: boolean
    farmaciaId?: boolean
    indicadorId?: boolean
    responsavelId?: boolean
    dataCriacao?: boolean
    prazo?: boolean
    status?: boolean
    percentualConcluido?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanoAcaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    indicador?: boolean | IndicadorDefaultArgs<ExtArgs>
    responsavel?: boolean | UsuarioDefaultArgs<ExtArgs>
    acoes?: boolean | PlanoAcao$acoesArgs<ExtArgs>
    comentarios?: boolean | PlanoAcao$comentariosArgs<ExtArgs>
    evidencias?: boolean | PlanoAcao$evidenciasArgs<ExtArgs>
    _count?: boolean | PlanoAcaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanoAcaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    indicador?: boolean | IndicadorDefaultArgs<ExtArgs>
    responsavel?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $PlanoAcaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanoAcao"
    objects: {
      farmacia: Prisma.$FarmaciaPayload<ExtArgs>
      indicador: Prisma.$IndicadorPayload<ExtArgs>
      responsavel: Prisma.$UsuarioPayload<ExtArgs>
      acoes: Prisma.$AcaoPayload<ExtArgs>[]
      comentarios: Prisma.$ComentarioPayload<ExtArgs>[]
      evidencias: Prisma.$EvidenciaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      descricao: string
      farmaciaId: string
      indicadorId: string
      responsavelId: string
      dataCriacao: Date
      prazo: Date
      status: string
      percentualConcluido: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planoAcao"]>
    composites: {}
  }

  type PlanoAcaoGetPayload<S extends boolean | null | undefined | PlanoAcaoDefaultArgs> = $Result.GetResult<Prisma.$PlanoAcaoPayload, S>

  type PlanoAcaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanoAcaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanoAcaoCountAggregateInputType | true
    }

  export interface PlanoAcaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanoAcao'], meta: { name: 'PlanoAcao' } }
    /**
     * Find zero or one PlanoAcao that matches the filter.
     * @param {PlanoAcaoFindUniqueArgs} args - Arguments to find a PlanoAcao
     * @example
     * // Get one PlanoAcao
     * const planoAcao = await prisma.planoAcao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanoAcaoFindUniqueArgs>(args: SelectSubset<T, PlanoAcaoFindUniqueArgs<ExtArgs>>): Prisma__PlanoAcaoClient<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlanoAcao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanoAcaoFindUniqueOrThrowArgs} args - Arguments to find a PlanoAcao
     * @example
     * // Get one PlanoAcao
     * const planoAcao = await prisma.planoAcao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanoAcaoFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanoAcaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanoAcaoClient<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlanoAcao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoAcaoFindFirstArgs} args - Arguments to find a PlanoAcao
     * @example
     * // Get one PlanoAcao
     * const planoAcao = await prisma.planoAcao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanoAcaoFindFirstArgs>(args?: SelectSubset<T, PlanoAcaoFindFirstArgs<ExtArgs>>): Prisma__PlanoAcaoClient<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlanoAcao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoAcaoFindFirstOrThrowArgs} args - Arguments to find a PlanoAcao
     * @example
     * // Get one PlanoAcao
     * const planoAcao = await prisma.planoAcao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanoAcaoFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanoAcaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanoAcaoClient<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlanoAcaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoAcaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanoAcaos
     * const planoAcaos = await prisma.planoAcao.findMany()
     * 
     * // Get first 10 PlanoAcaos
     * const planoAcaos = await prisma.planoAcao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planoAcaoWithIdOnly = await prisma.planoAcao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanoAcaoFindManyArgs>(args?: SelectSubset<T, PlanoAcaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlanoAcao.
     * @param {PlanoAcaoCreateArgs} args - Arguments to create a PlanoAcao.
     * @example
     * // Create one PlanoAcao
     * const PlanoAcao = await prisma.planoAcao.create({
     *   data: {
     *     // ... data to create a PlanoAcao
     *   }
     * })
     * 
     */
    create<T extends PlanoAcaoCreateArgs>(args: SelectSubset<T, PlanoAcaoCreateArgs<ExtArgs>>): Prisma__PlanoAcaoClient<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlanoAcaos.
     * @param {PlanoAcaoCreateManyArgs} args - Arguments to create many PlanoAcaos.
     * @example
     * // Create many PlanoAcaos
     * const planoAcao = await prisma.planoAcao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanoAcaoCreateManyArgs>(args?: SelectSubset<T, PlanoAcaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanoAcaos and returns the data saved in the database.
     * @param {PlanoAcaoCreateManyAndReturnArgs} args - Arguments to create many PlanoAcaos.
     * @example
     * // Create many PlanoAcaos
     * const planoAcao = await prisma.planoAcao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanoAcaos and only return the `id`
     * const planoAcaoWithIdOnly = await prisma.planoAcao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanoAcaoCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanoAcaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlanoAcao.
     * @param {PlanoAcaoDeleteArgs} args - Arguments to delete one PlanoAcao.
     * @example
     * // Delete one PlanoAcao
     * const PlanoAcao = await prisma.planoAcao.delete({
     *   where: {
     *     // ... filter to delete one PlanoAcao
     *   }
     * })
     * 
     */
    delete<T extends PlanoAcaoDeleteArgs>(args: SelectSubset<T, PlanoAcaoDeleteArgs<ExtArgs>>): Prisma__PlanoAcaoClient<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlanoAcao.
     * @param {PlanoAcaoUpdateArgs} args - Arguments to update one PlanoAcao.
     * @example
     * // Update one PlanoAcao
     * const planoAcao = await prisma.planoAcao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanoAcaoUpdateArgs>(args: SelectSubset<T, PlanoAcaoUpdateArgs<ExtArgs>>): Prisma__PlanoAcaoClient<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlanoAcaos.
     * @param {PlanoAcaoDeleteManyArgs} args - Arguments to filter PlanoAcaos to delete.
     * @example
     * // Delete a few PlanoAcaos
     * const { count } = await prisma.planoAcao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanoAcaoDeleteManyArgs>(args?: SelectSubset<T, PlanoAcaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanoAcaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoAcaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanoAcaos
     * const planoAcao = await prisma.planoAcao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanoAcaoUpdateManyArgs>(args: SelectSubset<T, PlanoAcaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanoAcao.
     * @param {PlanoAcaoUpsertArgs} args - Arguments to update or create a PlanoAcao.
     * @example
     * // Update or create a PlanoAcao
     * const planoAcao = await prisma.planoAcao.upsert({
     *   create: {
     *     // ... data to create a PlanoAcao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanoAcao we want to update
     *   }
     * })
     */
    upsert<T extends PlanoAcaoUpsertArgs>(args: SelectSubset<T, PlanoAcaoUpsertArgs<ExtArgs>>): Prisma__PlanoAcaoClient<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlanoAcaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoAcaoCountArgs} args - Arguments to filter PlanoAcaos to count.
     * @example
     * // Count the number of PlanoAcaos
     * const count = await prisma.planoAcao.count({
     *   where: {
     *     // ... the filter for the PlanoAcaos we want to count
     *   }
     * })
    **/
    count<T extends PlanoAcaoCountArgs>(
      args?: Subset<T, PlanoAcaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanoAcaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanoAcao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoAcaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanoAcaoAggregateArgs>(args: Subset<T, PlanoAcaoAggregateArgs>): Prisma.PrismaPromise<GetPlanoAcaoAggregateType<T>>

    /**
     * Group by PlanoAcao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoAcaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanoAcaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanoAcaoGroupByArgs['orderBy'] }
        : { orderBy?: PlanoAcaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanoAcaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanoAcaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanoAcao model
   */
  readonly fields: PlanoAcaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanoAcao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanoAcaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    farmacia<T extends FarmaciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FarmaciaDefaultArgs<ExtArgs>>): Prisma__FarmaciaClient<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    indicador<T extends IndicadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicadorDefaultArgs<ExtArgs>>): Prisma__IndicadorClient<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responsavel<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    acoes<T extends PlanoAcao$acoesArgs<ExtArgs> = {}>(args?: Subset<T, PlanoAcao$acoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcaoPayload<ExtArgs>, T, "findMany"> | Null>
    comentarios<T extends PlanoAcao$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, PlanoAcao$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findMany"> | Null>
    evidencias<T extends PlanoAcao$evidenciasArgs<ExtArgs> = {}>(args?: Subset<T, PlanoAcao$evidenciasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanoAcao model
   */ 
  interface PlanoAcaoFieldRefs {
    readonly id: FieldRef<"PlanoAcao", 'String'>
    readonly titulo: FieldRef<"PlanoAcao", 'String'>
    readonly descricao: FieldRef<"PlanoAcao", 'String'>
    readonly farmaciaId: FieldRef<"PlanoAcao", 'String'>
    readonly indicadorId: FieldRef<"PlanoAcao", 'String'>
    readonly responsavelId: FieldRef<"PlanoAcao", 'String'>
    readonly dataCriacao: FieldRef<"PlanoAcao", 'DateTime'>
    readonly prazo: FieldRef<"PlanoAcao", 'DateTime'>
    readonly status: FieldRef<"PlanoAcao", 'String'>
    readonly percentualConcluido: FieldRef<"PlanoAcao", 'Int'>
    readonly createdAt: FieldRef<"PlanoAcao", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanoAcao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanoAcao findUnique
   */
  export type PlanoAcaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
    /**
     * Filter, which PlanoAcao to fetch.
     */
    where: PlanoAcaoWhereUniqueInput
  }

  /**
   * PlanoAcao findUniqueOrThrow
   */
  export type PlanoAcaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
    /**
     * Filter, which PlanoAcao to fetch.
     */
    where: PlanoAcaoWhereUniqueInput
  }

  /**
   * PlanoAcao findFirst
   */
  export type PlanoAcaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
    /**
     * Filter, which PlanoAcao to fetch.
     */
    where?: PlanoAcaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanoAcaos to fetch.
     */
    orderBy?: PlanoAcaoOrderByWithRelationInput | PlanoAcaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanoAcaos.
     */
    cursor?: PlanoAcaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanoAcaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanoAcaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanoAcaos.
     */
    distinct?: PlanoAcaoScalarFieldEnum | PlanoAcaoScalarFieldEnum[]
  }

  /**
   * PlanoAcao findFirstOrThrow
   */
  export type PlanoAcaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
    /**
     * Filter, which PlanoAcao to fetch.
     */
    where?: PlanoAcaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanoAcaos to fetch.
     */
    orderBy?: PlanoAcaoOrderByWithRelationInput | PlanoAcaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanoAcaos.
     */
    cursor?: PlanoAcaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanoAcaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanoAcaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanoAcaos.
     */
    distinct?: PlanoAcaoScalarFieldEnum | PlanoAcaoScalarFieldEnum[]
  }

  /**
   * PlanoAcao findMany
   */
  export type PlanoAcaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
    /**
     * Filter, which PlanoAcaos to fetch.
     */
    where?: PlanoAcaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanoAcaos to fetch.
     */
    orderBy?: PlanoAcaoOrderByWithRelationInput | PlanoAcaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanoAcaos.
     */
    cursor?: PlanoAcaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanoAcaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanoAcaos.
     */
    skip?: number
    distinct?: PlanoAcaoScalarFieldEnum | PlanoAcaoScalarFieldEnum[]
  }

  /**
   * PlanoAcao create
   */
  export type PlanoAcaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanoAcao.
     */
    data: XOR<PlanoAcaoCreateInput, PlanoAcaoUncheckedCreateInput>
  }

  /**
   * PlanoAcao createMany
   */
  export type PlanoAcaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanoAcaos.
     */
    data: PlanoAcaoCreateManyInput | PlanoAcaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanoAcao createManyAndReturn
   */
  export type PlanoAcaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlanoAcaos.
     */
    data: PlanoAcaoCreateManyInput | PlanoAcaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanoAcao update
   */
  export type PlanoAcaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanoAcao.
     */
    data: XOR<PlanoAcaoUpdateInput, PlanoAcaoUncheckedUpdateInput>
    /**
     * Choose, which PlanoAcao to update.
     */
    where: PlanoAcaoWhereUniqueInput
  }

  /**
   * PlanoAcao updateMany
   */
  export type PlanoAcaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanoAcaos.
     */
    data: XOR<PlanoAcaoUpdateManyMutationInput, PlanoAcaoUncheckedUpdateManyInput>
    /**
     * Filter which PlanoAcaos to update
     */
    where?: PlanoAcaoWhereInput
  }

  /**
   * PlanoAcao upsert
   */
  export type PlanoAcaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanoAcao to update in case it exists.
     */
    where: PlanoAcaoWhereUniqueInput
    /**
     * In case the PlanoAcao found by the `where` argument doesn't exist, create a new PlanoAcao with this data.
     */
    create: XOR<PlanoAcaoCreateInput, PlanoAcaoUncheckedCreateInput>
    /**
     * In case the PlanoAcao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanoAcaoUpdateInput, PlanoAcaoUncheckedUpdateInput>
  }

  /**
   * PlanoAcao delete
   */
  export type PlanoAcaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
    /**
     * Filter which PlanoAcao to delete.
     */
    where: PlanoAcaoWhereUniqueInput
  }

  /**
   * PlanoAcao deleteMany
   */
  export type PlanoAcaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanoAcaos to delete
     */
    where?: PlanoAcaoWhereInput
  }

  /**
   * PlanoAcao.acoes
   */
  export type PlanoAcao$acoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acao
     */
    select?: AcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcaoInclude<ExtArgs> | null
    where?: AcaoWhereInput
    orderBy?: AcaoOrderByWithRelationInput | AcaoOrderByWithRelationInput[]
    cursor?: AcaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcaoScalarFieldEnum | AcaoScalarFieldEnum[]
  }

  /**
   * PlanoAcao.comentarios
   */
  export type PlanoAcao$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    where?: ComentarioWhereInput
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    cursor?: ComentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * PlanoAcao.evidencias
   */
  export type PlanoAcao$evidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    where?: EvidenciaWhereInput
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    cursor?: EvidenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * PlanoAcao without action
   */
  export type PlanoAcaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanoAcao
     */
    select?: PlanoAcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanoAcaoInclude<ExtArgs> | null
  }


  /**
   * Model Acao
   */

  export type AggregateAcao = {
    _count: AcaoCountAggregateOutputType | null
    _min: AcaoMinAggregateOutputType | null
    _max: AcaoMaxAggregateOutputType | null
  }

  export type AcaoMinAggregateOutputType = {
    id: string | null
    descricao: string | null
    prazo: Date | null
    concluida: boolean | null
    atrasada: boolean | null
    planoAcaoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcaoMaxAggregateOutputType = {
    id: string | null
    descricao: string | null
    prazo: Date | null
    concluida: boolean | null
    atrasada: boolean | null
    planoAcaoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcaoCountAggregateOutputType = {
    id: number
    descricao: number
    prazo: number
    concluida: number
    atrasada: number
    planoAcaoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcaoMinAggregateInputType = {
    id?: true
    descricao?: true
    prazo?: true
    concluida?: true
    atrasada?: true
    planoAcaoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcaoMaxAggregateInputType = {
    id?: true
    descricao?: true
    prazo?: true
    concluida?: true
    atrasada?: true
    planoAcaoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcaoCountAggregateInputType = {
    id?: true
    descricao?: true
    prazo?: true
    concluida?: true
    atrasada?: true
    planoAcaoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Acao to aggregate.
     */
    where?: AcaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acaos to fetch.
     */
    orderBy?: AcaoOrderByWithRelationInput | AcaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Acaos
    **/
    _count?: true | AcaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcaoMaxAggregateInputType
  }

  export type GetAcaoAggregateType<T extends AcaoAggregateArgs> = {
        [P in keyof T & keyof AggregateAcao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcao[P]>
      : GetScalarType<T[P], AggregateAcao[P]>
  }




  export type AcaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcaoWhereInput
    orderBy?: AcaoOrderByWithAggregationInput | AcaoOrderByWithAggregationInput[]
    by: AcaoScalarFieldEnum[] | AcaoScalarFieldEnum
    having?: AcaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcaoCountAggregateInputType | true
    _min?: AcaoMinAggregateInputType
    _max?: AcaoMaxAggregateInputType
  }

  export type AcaoGroupByOutputType = {
    id: string
    descricao: string
    prazo: Date
    concluida: boolean
    atrasada: boolean
    planoAcaoId: string
    createdAt: Date
    updatedAt: Date
    _count: AcaoCountAggregateOutputType | null
    _min: AcaoMinAggregateOutputType | null
    _max: AcaoMaxAggregateOutputType | null
  }

  type GetAcaoGroupByPayload<T extends AcaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcaoGroupByOutputType[P]>
            : GetScalarType<T[P], AcaoGroupByOutputType[P]>
        }
      >
    >


  export type AcaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    prazo?: boolean
    concluida?: boolean
    atrasada?: boolean
    planoAcaoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planoAcao?: boolean | PlanoAcaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["acao"]>

  export type AcaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    prazo?: boolean
    concluida?: boolean
    atrasada?: boolean
    planoAcaoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planoAcao?: boolean | PlanoAcaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["acao"]>

  export type AcaoSelectScalar = {
    id?: boolean
    descricao?: boolean
    prazo?: boolean
    concluida?: boolean
    atrasada?: boolean
    planoAcaoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planoAcao?: boolean | PlanoAcaoDefaultArgs<ExtArgs>
  }
  export type AcaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planoAcao?: boolean | PlanoAcaoDefaultArgs<ExtArgs>
  }

  export type $AcaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Acao"
    objects: {
      planoAcao: Prisma.$PlanoAcaoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      descricao: string
      prazo: Date
      concluida: boolean
      atrasada: boolean
      planoAcaoId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["acao"]>
    composites: {}
  }

  type AcaoGetPayload<S extends boolean | null | undefined | AcaoDefaultArgs> = $Result.GetResult<Prisma.$AcaoPayload, S>

  type AcaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcaoCountAggregateInputType | true
    }

  export interface AcaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Acao'], meta: { name: 'Acao' } }
    /**
     * Find zero or one Acao that matches the filter.
     * @param {AcaoFindUniqueArgs} args - Arguments to find a Acao
     * @example
     * // Get one Acao
     * const acao = await prisma.acao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcaoFindUniqueArgs>(args: SelectSubset<T, AcaoFindUniqueArgs<ExtArgs>>): Prisma__AcaoClient<$Result.GetResult<Prisma.$AcaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Acao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AcaoFindUniqueOrThrowArgs} args - Arguments to find a Acao
     * @example
     * // Get one Acao
     * const acao = await prisma.acao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcaoFindUniqueOrThrowArgs>(args: SelectSubset<T, AcaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcaoClient<$Result.GetResult<Prisma.$AcaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Acao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcaoFindFirstArgs} args - Arguments to find a Acao
     * @example
     * // Get one Acao
     * const acao = await prisma.acao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcaoFindFirstArgs>(args?: SelectSubset<T, AcaoFindFirstArgs<ExtArgs>>): Prisma__AcaoClient<$Result.GetResult<Prisma.$AcaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Acao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcaoFindFirstOrThrowArgs} args - Arguments to find a Acao
     * @example
     * // Get one Acao
     * const acao = await prisma.acao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcaoFindFirstOrThrowArgs>(args?: SelectSubset<T, AcaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcaoClient<$Result.GetResult<Prisma.$AcaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Acaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Acaos
     * const acaos = await prisma.acao.findMany()
     * 
     * // Get first 10 Acaos
     * const acaos = await prisma.acao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const acaoWithIdOnly = await prisma.acao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcaoFindManyArgs>(args?: SelectSubset<T, AcaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Acao.
     * @param {AcaoCreateArgs} args - Arguments to create a Acao.
     * @example
     * // Create one Acao
     * const Acao = await prisma.acao.create({
     *   data: {
     *     // ... data to create a Acao
     *   }
     * })
     * 
     */
    create<T extends AcaoCreateArgs>(args: SelectSubset<T, AcaoCreateArgs<ExtArgs>>): Prisma__AcaoClient<$Result.GetResult<Prisma.$AcaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Acaos.
     * @param {AcaoCreateManyArgs} args - Arguments to create many Acaos.
     * @example
     * // Create many Acaos
     * const acao = await prisma.acao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcaoCreateManyArgs>(args?: SelectSubset<T, AcaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Acaos and returns the data saved in the database.
     * @param {AcaoCreateManyAndReturnArgs} args - Arguments to create many Acaos.
     * @example
     * // Create many Acaos
     * const acao = await prisma.acao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Acaos and only return the `id`
     * const acaoWithIdOnly = await prisma.acao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcaoCreateManyAndReturnArgs>(args?: SelectSubset<T, AcaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Acao.
     * @param {AcaoDeleteArgs} args - Arguments to delete one Acao.
     * @example
     * // Delete one Acao
     * const Acao = await prisma.acao.delete({
     *   where: {
     *     // ... filter to delete one Acao
     *   }
     * })
     * 
     */
    delete<T extends AcaoDeleteArgs>(args: SelectSubset<T, AcaoDeleteArgs<ExtArgs>>): Prisma__AcaoClient<$Result.GetResult<Prisma.$AcaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Acao.
     * @param {AcaoUpdateArgs} args - Arguments to update one Acao.
     * @example
     * // Update one Acao
     * const acao = await prisma.acao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcaoUpdateArgs>(args: SelectSubset<T, AcaoUpdateArgs<ExtArgs>>): Prisma__AcaoClient<$Result.GetResult<Prisma.$AcaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Acaos.
     * @param {AcaoDeleteManyArgs} args - Arguments to filter Acaos to delete.
     * @example
     * // Delete a few Acaos
     * const { count } = await prisma.acao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcaoDeleteManyArgs>(args?: SelectSubset<T, AcaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Acaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Acaos
     * const acao = await prisma.acao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcaoUpdateManyArgs>(args: SelectSubset<T, AcaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Acao.
     * @param {AcaoUpsertArgs} args - Arguments to update or create a Acao.
     * @example
     * // Update or create a Acao
     * const acao = await prisma.acao.upsert({
     *   create: {
     *     // ... data to create a Acao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Acao we want to update
     *   }
     * })
     */
    upsert<T extends AcaoUpsertArgs>(args: SelectSubset<T, AcaoUpsertArgs<ExtArgs>>): Prisma__AcaoClient<$Result.GetResult<Prisma.$AcaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Acaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcaoCountArgs} args - Arguments to filter Acaos to count.
     * @example
     * // Count the number of Acaos
     * const count = await prisma.acao.count({
     *   where: {
     *     // ... the filter for the Acaos we want to count
     *   }
     * })
    **/
    count<T extends AcaoCountArgs>(
      args?: Subset<T, AcaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Acao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcaoAggregateArgs>(args: Subset<T, AcaoAggregateArgs>): Prisma.PrismaPromise<GetAcaoAggregateType<T>>

    /**
     * Group by Acao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcaoGroupByArgs['orderBy'] }
        : { orderBy?: AcaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Acao model
   */
  readonly fields: AcaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Acao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planoAcao<T extends PlanoAcaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanoAcaoDefaultArgs<ExtArgs>>): Prisma__PlanoAcaoClient<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Acao model
   */ 
  interface AcaoFieldRefs {
    readonly id: FieldRef<"Acao", 'String'>
    readonly descricao: FieldRef<"Acao", 'String'>
    readonly prazo: FieldRef<"Acao", 'DateTime'>
    readonly concluida: FieldRef<"Acao", 'Boolean'>
    readonly atrasada: FieldRef<"Acao", 'Boolean'>
    readonly planoAcaoId: FieldRef<"Acao", 'String'>
    readonly createdAt: FieldRef<"Acao", 'DateTime'>
    readonly updatedAt: FieldRef<"Acao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Acao findUnique
   */
  export type AcaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acao
     */
    select?: AcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcaoInclude<ExtArgs> | null
    /**
     * Filter, which Acao to fetch.
     */
    where: AcaoWhereUniqueInput
  }

  /**
   * Acao findUniqueOrThrow
   */
  export type AcaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acao
     */
    select?: AcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcaoInclude<ExtArgs> | null
    /**
     * Filter, which Acao to fetch.
     */
    where: AcaoWhereUniqueInput
  }

  /**
   * Acao findFirst
   */
  export type AcaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acao
     */
    select?: AcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcaoInclude<ExtArgs> | null
    /**
     * Filter, which Acao to fetch.
     */
    where?: AcaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acaos to fetch.
     */
    orderBy?: AcaoOrderByWithRelationInput | AcaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Acaos.
     */
    cursor?: AcaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Acaos.
     */
    distinct?: AcaoScalarFieldEnum | AcaoScalarFieldEnum[]
  }

  /**
   * Acao findFirstOrThrow
   */
  export type AcaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acao
     */
    select?: AcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcaoInclude<ExtArgs> | null
    /**
     * Filter, which Acao to fetch.
     */
    where?: AcaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acaos to fetch.
     */
    orderBy?: AcaoOrderByWithRelationInput | AcaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Acaos.
     */
    cursor?: AcaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Acaos.
     */
    distinct?: AcaoScalarFieldEnum | AcaoScalarFieldEnum[]
  }

  /**
   * Acao findMany
   */
  export type AcaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acao
     */
    select?: AcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcaoInclude<ExtArgs> | null
    /**
     * Filter, which Acaos to fetch.
     */
    where?: AcaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acaos to fetch.
     */
    orderBy?: AcaoOrderByWithRelationInput | AcaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Acaos.
     */
    cursor?: AcaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acaos.
     */
    skip?: number
    distinct?: AcaoScalarFieldEnum | AcaoScalarFieldEnum[]
  }

  /**
   * Acao create
   */
  export type AcaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acao
     */
    select?: AcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Acao.
     */
    data: XOR<AcaoCreateInput, AcaoUncheckedCreateInput>
  }

  /**
   * Acao createMany
   */
  export type AcaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Acaos.
     */
    data: AcaoCreateManyInput | AcaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Acao createManyAndReturn
   */
  export type AcaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acao
     */
    select?: AcaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Acaos.
     */
    data: AcaoCreateManyInput | AcaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Acao update
   */
  export type AcaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acao
     */
    select?: AcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Acao.
     */
    data: XOR<AcaoUpdateInput, AcaoUncheckedUpdateInput>
    /**
     * Choose, which Acao to update.
     */
    where: AcaoWhereUniqueInput
  }

  /**
   * Acao updateMany
   */
  export type AcaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Acaos.
     */
    data: XOR<AcaoUpdateManyMutationInput, AcaoUncheckedUpdateManyInput>
    /**
     * Filter which Acaos to update
     */
    where?: AcaoWhereInput
  }

  /**
   * Acao upsert
   */
  export type AcaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acao
     */
    select?: AcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Acao to update in case it exists.
     */
    where: AcaoWhereUniqueInput
    /**
     * In case the Acao found by the `where` argument doesn't exist, create a new Acao with this data.
     */
    create: XOR<AcaoCreateInput, AcaoUncheckedCreateInput>
    /**
     * In case the Acao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcaoUpdateInput, AcaoUncheckedUpdateInput>
  }

  /**
   * Acao delete
   */
  export type AcaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acao
     */
    select?: AcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcaoInclude<ExtArgs> | null
    /**
     * Filter which Acao to delete.
     */
    where: AcaoWhereUniqueInput
  }

  /**
   * Acao deleteMany
   */
  export type AcaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Acaos to delete
     */
    where?: AcaoWhereInput
  }

  /**
   * Acao without action
   */
  export type AcaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acao
     */
    select?: AcaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcaoInclude<ExtArgs> | null
  }


  /**
   * Model Comentario
   */

  export type AggregateComentario = {
    _count: ComentarioCountAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  export type ComentarioMinAggregateOutputType = {
    id: string | null
    texto: string | null
    data: Date | null
    planoAcaoId: string | null
    usuarioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComentarioMaxAggregateOutputType = {
    id: string | null
    texto: string | null
    data: Date | null
    planoAcaoId: string | null
    usuarioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComentarioCountAggregateOutputType = {
    id: number
    texto: number
    data: number
    planoAcaoId: number
    usuarioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComentarioMinAggregateInputType = {
    id?: true
    texto?: true
    data?: true
    planoAcaoId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComentarioMaxAggregateInputType = {
    id?: true
    texto?: true
    data?: true
    planoAcaoId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComentarioCountAggregateInputType = {
    id?: true
    texto?: true
    data?: true
    planoAcaoId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComentarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comentario to aggregate.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comentarios
    **/
    _count?: true | ComentarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentarioMaxAggregateInputType
  }

  export type GetComentarioAggregateType<T extends ComentarioAggregateArgs> = {
        [P in keyof T & keyof AggregateComentario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentario[P]>
      : GetScalarType<T[P], AggregateComentario[P]>
  }




  export type ComentarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
    orderBy?: ComentarioOrderByWithAggregationInput | ComentarioOrderByWithAggregationInput[]
    by: ComentarioScalarFieldEnum[] | ComentarioScalarFieldEnum
    having?: ComentarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentarioCountAggregateInputType | true
    _min?: ComentarioMinAggregateInputType
    _max?: ComentarioMaxAggregateInputType
  }

  export type ComentarioGroupByOutputType = {
    id: string
    texto: string
    data: Date
    planoAcaoId: string
    usuarioId: string
    createdAt: Date
    updatedAt: Date
    _count: ComentarioCountAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  type GetComentarioGroupByPayload<T extends ComentarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComentarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
            : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
        }
      >
    >


  export type ComentarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    texto?: boolean
    data?: boolean
    planoAcaoId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planoAcao?: boolean | PlanoAcaoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentario"]>

  export type ComentarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    texto?: boolean
    data?: boolean
    planoAcaoId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planoAcao?: boolean | PlanoAcaoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentario"]>

  export type ComentarioSelectScalar = {
    id?: boolean
    texto?: boolean
    data?: boolean
    planoAcaoId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComentarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planoAcao?: boolean | PlanoAcaoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ComentarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planoAcao?: boolean | PlanoAcaoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ComentarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comentario"
    objects: {
      planoAcao: Prisma.$PlanoAcaoPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      texto: string
      data: Date
      planoAcaoId: string
      usuarioId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comentario"]>
    composites: {}
  }

  type ComentarioGetPayload<S extends boolean | null | undefined | ComentarioDefaultArgs> = $Result.GetResult<Prisma.$ComentarioPayload, S>

  type ComentarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComentarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComentarioCountAggregateInputType | true
    }

  export interface ComentarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comentario'], meta: { name: 'Comentario' } }
    /**
     * Find zero or one Comentario that matches the filter.
     * @param {ComentarioFindUniqueArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComentarioFindUniqueArgs>(args: SelectSubset<T, ComentarioFindUniqueArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comentario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComentarioFindUniqueOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComentarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ComentarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comentario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindFirstArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComentarioFindFirstArgs>(args?: SelectSubset<T, ComentarioFindFirstArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comentario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindFirstOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComentarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ComentarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comentarios
     * const comentarios = await prisma.comentario.findMany()
     * 
     * // Get first 10 Comentarios
     * const comentarios = await prisma.comentario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comentarioWithIdOnly = await prisma.comentario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComentarioFindManyArgs>(args?: SelectSubset<T, ComentarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comentario.
     * @param {ComentarioCreateArgs} args - Arguments to create a Comentario.
     * @example
     * // Create one Comentario
     * const Comentario = await prisma.comentario.create({
     *   data: {
     *     // ... data to create a Comentario
     *   }
     * })
     * 
     */
    create<T extends ComentarioCreateArgs>(args: SelectSubset<T, ComentarioCreateArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comentarios.
     * @param {ComentarioCreateManyArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentario = await prisma.comentario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComentarioCreateManyArgs>(args?: SelectSubset<T, ComentarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comentarios and returns the data saved in the database.
     * @param {ComentarioCreateManyAndReturnArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentario = await prisma.comentario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comentarios and only return the `id`
     * const comentarioWithIdOnly = await prisma.comentario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComentarioCreateManyAndReturnArgs>(args?: SelectSubset<T, ComentarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comentario.
     * @param {ComentarioDeleteArgs} args - Arguments to delete one Comentario.
     * @example
     * // Delete one Comentario
     * const Comentario = await prisma.comentario.delete({
     *   where: {
     *     // ... filter to delete one Comentario
     *   }
     * })
     * 
     */
    delete<T extends ComentarioDeleteArgs>(args: SelectSubset<T, ComentarioDeleteArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comentario.
     * @param {ComentarioUpdateArgs} args - Arguments to update one Comentario.
     * @example
     * // Update one Comentario
     * const comentario = await prisma.comentario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComentarioUpdateArgs>(args: SelectSubset<T, ComentarioUpdateArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comentarios.
     * @param {ComentarioDeleteManyArgs} args - Arguments to filter Comentarios to delete.
     * @example
     * // Delete a few Comentarios
     * const { count } = await prisma.comentario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComentarioDeleteManyArgs>(args?: SelectSubset<T, ComentarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comentarios
     * const comentario = await prisma.comentario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComentarioUpdateManyArgs>(args: SelectSubset<T, ComentarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comentario.
     * @param {ComentarioUpsertArgs} args - Arguments to update or create a Comentario.
     * @example
     * // Update or create a Comentario
     * const comentario = await prisma.comentario.upsert({
     *   create: {
     *     // ... data to create a Comentario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comentario we want to update
     *   }
     * })
     */
    upsert<T extends ComentarioUpsertArgs>(args: SelectSubset<T, ComentarioUpsertArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioCountArgs} args - Arguments to filter Comentarios to count.
     * @example
     * // Count the number of Comentarios
     * const count = await prisma.comentario.count({
     *   where: {
     *     // ... the filter for the Comentarios we want to count
     *   }
     * })
    **/
    count<T extends ComentarioCountArgs>(
      args?: Subset<T, ComentarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentarioAggregateArgs>(args: Subset<T, ComentarioAggregateArgs>): Prisma.PrismaPromise<GetComentarioAggregateType<T>>

    /**
     * Group by Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComentarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComentarioGroupByArgs['orderBy'] }
        : { orderBy?: ComentarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComentarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comentario model
   */
  readonly fields: ComentarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comentario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComentarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planoAcao<T extends PlanoAcaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanoAcaoDefaultArgs<ExtArgs>>): Prisma__PlanoAcaoClient<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comentario model
   */ 
  interface ComentarioFieldRefs {
    readonly id: FieldRef<"Comentario", 'String'>
    readonly texto: FieldRef<"Comentario", 'String'>
    readonly data: FieldRef<"Comentario", 'DateTime'>
    readonly planoAcaoId: FieldRef<"Comentario", 'String'>
    readonly usuarioId: FieldRef<"Comentario", 'String'>
    readonly createdAt: FieldRef<"Comentario", 'DateTime'>
    readonly updatedAt: FieldRef<"Comentario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comentario findUnique
   */
  export type ComentarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario findUniqueOrThrow
   */
  export type ComentarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario findFirst
   */
  export type ComentarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comentarios.
     */
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Comentario findFirstOrThrow
   */
  export type ComentarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comentarios.
     */
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Comentario findMany
   */
  export type ComentarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentarios to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Comentario create
   */
  export type ComentarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Comentario.
     */
    data: XOR<ComentarioCreateInput, ComentarioUncheckedCreateInput>
  }

  /**
   * Comentario createMany
   */
  export type ComentarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comentarios.
     */
    data: ComentarioCreateManyInput | ComentarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comentario createManyAndReturn
   */
  export type ComentarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comentarios.
     */
    data: ComentarioCreateManyInput | ComentarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comentario update
   */
  export type ComentarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Comentario.
     */
    data: XOR<ComentarioUpdateInput, ComentarioUncheckedUpdateInput>
    /**
     * Choose, which Comentario to update.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario updateMany
   */
  export type ComentarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comentarios.
     */
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyInput>
    /**
     * Filter which Comentarios to update
     */
    where?: ComentarioWhereInput
  }

  /**
   * Comentario upsert
   */
  export type ComentarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Comentario to update in case it exists.
     */
    where: ComentarioWhereUniqueInput
    /**
     * In case the Comentario found by the `where` argument doesn't exist, create a new Comentario with this data.
     */
    create: XOR<ComentarioCreateInput, ComentarioUncheckedCreateInput>
    /**
     * In case the Comentario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComentarioUpdateInput, ComentarioUncheckedUpdateInput>
  }

  /**
   * Comentario delete
   */
  export type ComentarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter which Comentario to delete.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario deleteMany
   */
  export type ComentarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comentarios to delete
     */
    where?: ComentarioWhereInput
  }

  /**
   * Comentario without action
   */
  export type ComentarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
  }


  /**
   * Model Evidencia
   */

  export type AggregateEvidencia = {
    _count: EvidenciaCountAggregateOutputType | null
    _min: EvidenciaMinAggregateOutputType | null
    _max: EvidenciaMaxAggregateOutputType | null
  }

  export type EvidenciaMinAggregateOutputType = {
    id: string | null
    url: string | null
    descricao: string | null
    dataCriacao: Date | null
    status: string | null
    dataValidacao: Date | null
    validadoPorId: string | null
    motivoReprovacao: string | null
    planoId: string | null
    farmaciaId: string | null
    indicadorId: string | null
    usuarioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvidenciaMaxAggregateOutputType = {
    id: string | null
    url: string | null
    descricao: string | null
    dataCriacao: Date | null
    status: string | null
    dataValidacao: Date | null
    validadoPorId: string | null
    motivoReprovacao: string | null
    planoId: string | null
    farmaciaId: string | null
    indicadorId: string | null
    usuarioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvidenciaCountAggregateOutputType = {
    id: number
    url: number
    descricao: number
    dataCriacao: number
    status: number
    dataValidacao: number
    validadoPorId: number
    motivoReprovacao: number
    planoId: number
    farmaciaId: number
    indicadorId: number
    usuarioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvidenciaMinAggregateInputType = {
    id?: true
    url?: true
    descricao?: true
    dataCriacao?: true
    status?: true
    dataValidacao?: true
    validadoPorId?: true
    motivoReprovacao?: true
    planoId?: true
    farmaciaId?: true
    indicadorId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvidenciaMaxAggregateInputType = {
    id?: true
    url?: true
    descricao?: true
    dataCriacao?: true
    status?: true
    dataValidacao?: true
    validadoPorId?: true
    motivoReprovacao?: true
    planoId?: true
    farmaciaId?: true
    indicadorId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvidenciaCountAggregateInputType = {
    id?: true
    url?: true
    descricao?: true
    dataCriacao?: true
    status?: true
    dataValidacao?: true
    validadoPorId?: true
    motivoReprovacao?: true
    planoId?: true
    farmaciaId?: true
    indicadorId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvidenciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidencia to aggregate.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evidencias
    **/
    _count?: true | EvidenciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvidenciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvidenciaMaxAggregateInputType
  }

  export type GetEvidenciaAggregateType<T extends EvidenciaAggregateArgs> = {
        [P in keyof T & keyof AggregateEvidencia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvidencia[P]>
      : GetScalarType<T[P], AggregateEvidencia[P]>
  }




  export type EvidenciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenciaWhereInput
    orderBy?: EvidenciaOrderByWithAggregationInput | EvidenciaOrderByWithAggregationInput[]
    by: EvidenciaScalarFieldEnum[] | EvidenciaScalarFieldEnum
    having?: EvidenciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvidenciaCountAggregateInputType | true
    _min?: EvidenciaMinAggregateInputType
    _max?: EvidenciaMaxAggregateInputType
  }

  export type EvidenciaGroupByOutputType = {
    id: string
    url: string
    descricao: string | null
    dataCriacao: Date
    status: string
    dataValidacao: Date | null
    validadoPorId: string | null
    motivoReprovacao: string | null
    planoId: string
    farmaciaId: string
    indicadorId: string
    usuarioId: string
    createdAt: Date
    updatedAt: Date
    _count: EvidenciaCountAggregateOutputType | null
    _min: EvidenciaMinAggregateOutputType | null
    _max: EvidenciaMaxAggregateOutputType | null
  }

  type GetEvidenciaGroupByPayload<T extends EvidenciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvidenciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvidenciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvidenciaGroupByOutputType[P]>
            : GetScalarType<T[P], EvidenciaGroupByOutputType[P]>
        }
      >
    >


  export type EvidenciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    descricao?: boolean
    dataCriacao?: boolean
    status?: boolean
    dataValidacao?: boolean
    validadoPorId?: boolean
    motivoReprovacao?: boolean
    planoId?: boolean
    farmaciaId?: boolean
    indicadorId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plano?: boolean | PlanoAcaoDefaultArgs<ExtArgs>
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    indicador?: boolean | IndicadorDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    comentarios?: boolean | Evidencia$comentariosArgs<ExtArgs>
    _count?: boolean | EvidenciaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidencia"]>

  export type EvidenciaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    descricao?: boolean
    dataCriacao?: boolean
    status?: boolean
    dataValidacao?: boolean
    validadoPorId?: boolean
    motivoReprovacao?: boolean
    planoId?: boolean
    farmaciaId?: boolean
    indicadorId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plano?: boolean | PlanoAcaoDefaultArgs<ExtArgs>
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    indicador?: boolean | IndicadorDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidencia"]>

  export type EvidenciaSelectScalar = {
    id?: boolean
    url?: boolean
    descricao?: boolean
    dataCriacao?: boolean
    status?: boolean
    dataValidacao?: boolean
    validadoPorId?: boolean
    motivoReprovacao?: boolean
    planoId?: boolean
    farmaciaId?: boolean
    indicadorId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EvidenciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plano?: boolean | PlanoAcaoDefaultArgs<ExtArgs>
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    indicador?: boolean | IndicadorDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    comentarios?: boolean | Evidencia$comentariosArgs<ExtArgs>
    _count?: boolean | EvidenciaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EvidenciaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plano?: boolean | PlanoAcaoDefaultArgs<ExtArgs>
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    indicador?: boolean | IndicadorDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $EvidenciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evidencia"
    objects: {
      plano: Prisma.$PlanoAcaoPayload<ExtArgs>
      farmacia: Prisma.$FarmaciaPayload<ExtArgs>
      indicador: Prisma.$IndicadorPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      comentarios: Prisma.$ComentarioEvidenciaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      descricao: string | null
      dataCriacao: Date
      status: string
      dataValidacao: Date | null
      validadoPorId: string | null
      motivoReprovacao: string | null
      planoId: string
      farmaciaId: string
      indicadorId: string
      usuarioId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evidencia"]>
    composites: {}
  }

  type EvidenciaGetPayload<S extends boolean | null | undefined | EvidenciaDefaultArgs> = $Result.GetResult<Prisma.$EvidenciaPayload, S>

  type EvidenciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvidenciaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvidenciaCountAggregateInputType | true
    }

  export interface EvidenciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evidencia'], meta: { name: 'Evidencia' } }
    /**
     * Find zero or one Evidencia that matches the filter.
     * @param {EvidenciaFindUniqueArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvidenciaFindUniqueArgs>(args: SelectSubset<T, EvidenciaFindUniqueArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Evidencia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvidenciaFindUniqueOrThrowArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvidenciaFindUniqueOrThrowArgs>(args: SelectSubset<T, EvidenciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Evidencia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaFindFirstArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvidenciaFindFirstArgs>(args?: SelectSubset<T, EvidenciaFindFirstArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Evidencia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaFindFirstOrThrowArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvidenciaFindFirstOrThrowArgs>(args?: SelectSubset<T, EvidenciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Evidencias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evidencias
     * const evidencias = await prisma.evidencia.findMany()
     * 
     * // Get first 10 Evidencias
     * const evidencias = await prisma.evidencia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evidenciaWithIdOnly = await prisma.evidencia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvidenciaFindManyArgs>(args?: SelectSubset<T, EvidenciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Evidencia.
     * @param {EvidenciaCreateArgs} args - Arguments to create a Evidencia.
     * @example
     * // Create one Evidencia
     * const Evidencia = await prisma.evidencia.create({
     *   data: {
     *     // ... data to create a Evidencia
     *   }
     * })
     * 
     */
    create<T extends EvidenciaCreateArgs>(args: SelectSubset<T, EvidenciaCreateArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Evidencias.
     * @param {EvidenciaCreateManyArgs} args - Arguments to create many Evidencias.
     * @example
     * // Create many Evidencias
     * const evidencia = await prisma.evidencia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvidenciaCreateManyArgs>(args?: SelectSubset<T, EvidenciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evidencias and returns the data saved in the database.
     * @param {EvidenciaCreateManyAndReturnArgs} args - Arguments to create many Evidencias.
     * @example
     * // Create many Evidencias
     * const evidencia = await prisma.evidencia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evidencias and only return the `id`
     * const evidenciaWithIdOnly = await prisma.evidencia.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvidenciaCreateManyAndReturnArgs>(args?: SelectSubset<T, EvidenciaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Evidencia.
     * @param {EvidenciaDeleteArgs} args - Arguments to delete one Evidencia.
     * @example
     * // Delete one Evidencia
     * const Evidencia = await prisma.evidencia.delete({
     *   where: {
     *     // ... filter to delete one Evidencia
     *   }
     * })
     * 
     */
    delete<T extends EvidenciaDeleteArgs>(args: SelectSubset<T, EvidenciaDeleteArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Evidencia.
     * @param {EvidenciaUpdateArgs} args - Arguments to update one Evidencia.
     * @example
     * // Update one Evidencia
     * const evidencia = await prisma.evidencia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvidenciaUpdateArgs>(args: SelectSubset<T, EvidenciaUpdateArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Evidencias.
     * @param {EvidenciaDeleteManyArgs} args - Arguments to filter Evidencias to delete.
     * @example
     * // Delete a few Evidencias
     * const { count } = await prisma.evidencia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvidenciaDeleteManyArgs>(args?: SelectSubset<T, EvidenciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evidencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evidencias
     * const evidencia = await prisma.evidencia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvidenciaUpdateManyArgs>(args: SelectSubset<T, EvidenciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evidencia.
     * @param {EvidenciaUpsertArgs} args - Arguments to update or create a Evidencia.
     * @example
     * // Update or create a Evidencia
     * const evidencia = await prisma.evidencia.upsert({
     *   create: {
     *     // ... data to create a Evidencia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evidencia we want to update
     *   }
     * })
     */
    upsert<T extends EvidenciaUpsertArgs>(args: SelectSubset<T, EvidenciaUpsertArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Evidencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaCountArgs} args - Arguments to filter Evidencias to count.
     * @example
     * // Count the number of Evidencias
     * const count = await prisma.evidencia.count({
     *   where: {
     *     // ... the filter for the Evidencias we want to count
     *   }
     * })
    **/
    count<T extends EvidenciaCountArgs>(
      args?: Subset<T, EvidenciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvidenciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evidencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvidenciaAggregateArgs>(args: Subset<T, EvidenciaAggregateArgs>): Prisma.PrismaPromise<GetEvidenciaAggregateType<T>>

    /**
     * Group by Evidencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvidenciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvidenciaGroupByArgs['orderBy'] }
        : { orderBy?: EvidenciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvidenciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvidenciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evidencia model
   */
  readonly fields: EvidenciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evidencia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvidenciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plano<T extends PlanoAcaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanoAcaoDefaultArgs<ExtArgs>>): Prisma__PlanoAcaoClient<$Result.GetResult<Prisma.$PlanoAcaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    farmacia<T extends FarmaciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FarmaciaDefaultArgs<ExtArgs>>): Prisma__FarmaciaClient<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    indicador<T extends IndicadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicadorDefaultArgs<ExtArgs>>): Prisma__IndicadorClient<$Result.GetResult<Prisma.$IndicadorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comentarios<T extends Evidencia$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, Evidencia$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioEvidenciaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evidencia model
   */ 
  interface EvidenciaFieldRefs {
    readonly id: FieldRef<"Evidencia", 'String'>
    readonly url: FieldRef<"Evidencia", 'String'>
    readonly descricao: FieldRef<"Evidencia", 'String'>
    readonly dataCriacao: FieldRef<"Evidencia", 'DateTime'>
    readonly status: FieldRef<"Evidencia", 'String'>
    readonly dataValidacao: FieldRef<"Evidencia", 'DateTime'>
    readonly validadoPorId: FieldRef<"Evidencia", 'String'>
    readonly motivoReprovacao: FieldRef<"Evidencia", 'String'>
    readonly planoId: FieldRef<"Evidencia", 'String'>
    readonly farmaciaId: FieldRef<"Evidencia", 'String'>
    readonly indicadorId: FieldRef<"Evidencia", 'String'>
    readonly usuarioId: FieldRef<"Evidencia", 'String'>
    readonly createdAt: FieldRef<"Evidencia", 'DateTime'>
    readonly updatedAt: FieldRef<"Evidencia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evidencia findUnique
   */
  export type EvidenciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia findUniqueOrThrow
   */
  export type EvidenciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia findFirst
   */
  export type EvidenciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidencias.
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidencias.
     */
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia findFirstOrThrow
   */
  export type EvidenciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidencias.
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidencias.
     */
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia findMany
   */
  export type EvidenciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencias to fetch.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evidencias.
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia create
   */
  export type EvidenciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * The data needed to create a Evidencia.
     */
    data: XOR<EvidenciaCreateInput, EvidenciaUncheckedCreateInput>
  }

  /**
   * Evidencia createMany
   */
  export type EvidenciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evidencias.
     */
    data: EvidenciaCreateManyInput | EvidenciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evidencia createManyAndReturn
   */
  export type EvidenciaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Evidencias.
     */
    data: EvidenciaCreateManyInput | EvidenciaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evidencia update
   */
  export type EvidenciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * The data needed to update a Evidencia.
     */
    data: XOR<EvidenciaUpdateInput, EvidenciaUncheckedUpdateInput>
    /**
     * Choose, which Evidencia to update.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia updateMany
   */
  export type EvidenciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evidencias.
     */
    data: XOR<EvidenciaUpdateManyMutationInput, EvidenciaUncheckedUpdateManyInput>
    /**
     * Filter which Evidencias to update
     */
    where?: EvidenciaWhereInput
  }

  /**
   * Evidencia upsert
   */
  export type EvidenciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * The filter to search for the Evidencia to update in case it exists.
     */
    where: EvidenciaWhereUniqueInput
    /**
     * In case the Evidencia found by the `where` argument doesn't exist, create a new Evidencia with this data.
     */
    create: XOR<EvidenciaCreateInput, EvidenciaUncheckedCreateInput>
    /**
     * In case the Evidencia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvidenciaUpdateInput, EvidenciaUncheckedUpdateInput>
  }

  /**
   * Evidencia delete
   */
  export type EvidenciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter which Evidencia to delete.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia deleteMany
   */
  export type EvidenciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidencias to delete
     */
    where?: EvidenciaWhereInput
  }

  /**
   * Evidencia.comentarios
   */
  export type Evidencia$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaInclude<ExtArgs> | null
    where?: ComentarioEvidenciaWhereInput
    orderBy?: ComentarioEvidenciaOrderByWithRelationInput | ComentarioEvidenciaOrderByWithRelationInput[]
    cursor?: ComentarioEvidenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioEvidenciaScalarFieldEnum | ComentarioEvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia without action
   */
  export type EvidenciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
  }


  /**
   * Model ComentarioEvidencia
   */

  export type AggregateComentarioEvidencia = {
    _count: ComentarioEvidenciaCountAggregateOutputType | null
    _min: ComentarioEvidenciaMinAggregateOutputType | null
    _max: ComentarioEvidenciaMaxAggregateOutputType | null
  }

  export type ComentarioEvidenciaMinAggregateOutputType = {
    id: string | null
    texto: string | null
    data: Date | null
    evidenciaId: string | null
    usuarioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComentarioEvidenciaMaxAggregateOutputType = {
    id: string | null
    texto: string | null
    data: Date | null
    evidenciaId: string | null
    usuarioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComentarioEvidenciaCountAggregateOutputType = {
    id: number
    texto: number
    data: number
    evidenciaId: number
    usuarioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComentarioEvidenciaMinAggregateInputType = {
    id?: true
    texto?: true
    data?: true
    evidenciaId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComentarioEvidenciaMaxAggregateInputType = {
    id?: true
    texto?: true
    data?: true
    evidenciaId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComentarioEvidenciaCountAggregateInputType = {
    id?: true
    texto?: true
    data?: true
    evidenciaId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComentarioEvidenciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComentarioEvidencia to aggregate.
     */
    where?: ComentarioEvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComentarioEvidencias to fetch.
     */
    orderBy?: ComentarioEvidenciaOrderByWithRelationInput | ComentarioEvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComentarioEvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComentarioEvidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComentarioEvidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComentarioEvidencias
    **/
    _count?: true | ComentarioEvidenciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentarioEvidenciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentarioEvidenciaMaxAggregateInputType
  }

  export type GetComentarioEvidenciaAggregateType<T extends ComentarioEvidenciaAggregateArgs> = {
        [P in keyof T & keyof AggregateComentarioEvidencia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentarioEvidencia[P]>
      : GetScalarType<T[P], AggregateComentarioEvidencia[P]>
  }




  export type ComentarioEvidenciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioEvidenciaWhereInput
    orderBy?: ComentarioEvidenciaOrderByWithAggregationInput | ComentarioEvidenciaOrderByWithAggregationInput[]
    by: ComentarioEvidenciaScalarFieldEnum[] | ComentarioEvidenciaScalarFieldEnum
    having?: ComentarioEvidenciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentarioEvidenciaCountAggregateInputType | true
    _min?: ComentarioEvidenciaMinAggregateInputType
    _max?: ComentarioEvidenciaMaxAggregateInputType
  }

  export type ComentarioEvidenciaGroupByOutputType = {
    id: string
    texto: string
    data: Date
    evidenciaId: string
    usuarioId: string
    createdAt: Date
    updatedAt: Date
    _count: ComentarioEvidenciaCountAggregateOutputType | null
    _min: ComentarioEvidenciaMinAggregateOutputType | null
    _max: ComentarioEvidenciaMaxAggregateOutputType | null
  }

  type GetComentarioEvidenciaGroupByPayload<T extends ComentarioEvidenciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComentarioEvidenciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentarioEvidenciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentarioEvidenciaGroupByOutputType[P]>
            : GetScalarType<T[P], ComentarioEvidenciaGroupByOutputType[P]>
        }
      >
    >


  export type ComentarioEvidenciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    texto?: boolean
    data?: boolean
    evidenciaId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evidencia?: boolean | EvidenciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentarioEvidencia"]>

  export type ComentarioEvidenciaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    texto?: boolean
    data?: boolean
    evidenciaId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evidencia?: boolean | EvidenciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentarioEvidencia"]>

  export type ComentarioEvidenciaSelectScalar = {
    id?: boolean
    texto?: boolean
    data?: boolean
    evidenciaId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComentarioEvidenciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidencia?: boolean | EvidenciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ComentarioEvidenciaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidencia?: boolean | EvidenciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ComentarioEvidenciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComentarioEvidencia"
    objects: {
      evidencia: Prisma.$EvidenciaPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      texto: string
      data: Date
      evidenciaId: string
      usuarioId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comentarioEvidencia"]>
    composites: {}
  }

  type ComentarioEvidenciaGetPayload<S extends boolean | null | undefined | ComentarioEvidenciaDefaultArgs> = $Result.GetResult<Prisma.$ComentarioEvidenciaPayload, S>

  type ComentarioEvidenciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComentarioEvidenciaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComentarioEvidenciaCountAggregateInputType | true
    }

  export interface ComentarioEvidenciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComentarioEvidencia'], meta: { name: 'ComentarioEvidencia' } }
    /**
     * Find zero or one ComentarioEvidencia that matches the filter.
     * @param {ComentarioEvidenciaFindUniqueArgs} args - Arguments to find a ComentarioEvidencia
     * @example
     * // Get one ComentarioEvidencia
     * const comentarioEvidencia = await prisma.comentarioEvidencia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComentarioEvidenciaFindUniqueArgs>(args: SelectSubset<T, ComentarioEvidenciaFindUniqueArgs<ExtArgs>>): Prisma__ComentarioEvidenciaClient<$Result.GetResult<Prisma.$ComentarioEvidenciaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComentarioEvidencia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComentarioEvidenciaFindUniqueOrThrowArgs} args - Arguments to find a ComentarioEvidencia
     * @example
     * // Get one ComentarioEvidencia
     * const comentarioEvidencia = await prisma.comentarioEvidencia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComentarioEvidenciaFindUniqueOrThrowArgs>(args: SelectSubset<T, ComentarioEvidenciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComentarioEvidenciaClient<$Result.GetResult<Prisma.$ComentarioEvidenciaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComentarioEvidencia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioEvidenciaFindFirstArgs} args - Arguments to find a ComentarioEvidencia
     * @example
     * // Get one ComentarioEvidencia
     * const comentarioEvidencia = await prisma.comentarioEvidencia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComentarioEvidenciaFindFirstArgs>(args?: SelectSubset<T, ComentarioEvidenciaFindFirstArgs<ExtArgs>>): Prisma__ComentarioEvidenciaClient<$Result.GetResult<Prisma.$ComentarioEvidenciaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComentarioEvidencia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioEvidenciaFindFirstOrThrowArgs} args - Arguments to find a ComentarioEvidencia
     * @example
     * // Get one ComentarioEvidencia
     * const comentarioEvidencia = await prisma.comentarioEvidencia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComentarioEvidenciaFindFirstOrThrowArgs>(args?: SelectSubset<T, ComentarioEvidenciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComentarioEvidenciaClient<$Result.GetResult<Prisma.$ComentarioEvidenciaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComentarioEvidencias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioEvidenciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComentarioEvidencias
     * const comentarioEvidencias = await prisma.comentarioEvidencia.findMany()
     * 
     * // Get first 10 ComentarioEvidencias
     * const comentarioEvidencias = await prisma.comentarioEvidencia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comentarioEvidenciaWithIdOnly = await prisma.comentarioEvidencia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComentarioEvidenciaFindManyArgs>(args?: SelectSubset<T, ComentarioEvidenciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioEvidenciaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComentarioEvidencia.
     * @param {ComentarioEvidenciaCreateArgs} args - Arguments to create a ComentarioEvidencia.
     * @example
     * // Create one ComentarioEvidencia
     * const ComentarioEvidencia = await prisma.comentarioEvidencia.create({
     *   data: {
     *     // ... data to create a ComentarioEvidencia
     *   }
     * })
     * 
     */
    create<T extends ComentarioEvidenciaCreateArgs>(args: SelectSubset<T, ComentarioEvidenciaCreateArgs<ExtArgs>>): Prisma__ComentarioEvidenciaClient<$Result.GetResult<Prisma.$ComentarioEvidenciaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComentarioEvidencias.
     * @param {ComentarioEvidenciaCreateManyArgs} args - Arguments to create many ComentarioEvidencias.
     * @example
     * // Create many ComentarioEvidencias
     * const comentarioEvidencia = await prisma.comentarioEvidencia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComentarioEvidenciaCreateManyArgs>(args?: SelectSubset<T, ComentarioEvidenciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComentarioEvidencias and returns the data saved in the database.
     * @param {ComentarioEvidenciaCreateManyAndReturnArgs} args - Arguments to create many ComentarioEvidencias.
     * @example
     * // Create many ComentarioEvidencias
     * const comentarioEvidencia = await prisma.comentarioEvidencia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComentarioEvidencias and only return the `id`
     * const comentarioEvidenciaWithIdOnly = await prisma.comentarioEvidencia.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComentarioEvidenciaCreateManyAndReturnArgs>(args?: SelectSubset<T, ComentarioEvidenciaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioEvidenciaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComentarioEvidencia.
     * @param {ComentarioEvidenciaDeleteArgs} args - Arguments to delete one ComentarioEvidencia.
     * @example
     * // Delete one ComentarioEvidencia
     * const ComentarioEvidencia = await prisma.comentarioEvidencia.delete({
     *   where: {
     *     // ... filter to delete one ComentarioEvidencia
     *   }
     * })
     * 
     */
    delete<T extends ComentarioEvidenciaDeleteArgs>(args: SelectSubset<T, ComentarioEvidenciaDeleteArgs<ExtArgs>>): Prisma__ComentarioEvidenciaClient<$Result.GetResult<Prisma.$ComentarioEvidenciaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComentarioEvidencia.
     * @param {ComentarioEvidenciaUpdateArgs} args - Arguments to update one ComentarioEvidencia.
     * @example
     * // Update one ComentarioEvidencia
     * const comentarioEvidencia = await prisma.comentarioEvidencia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComentarioEvidenciaUpdateArgs>(args: SelectSubset<T, ComentarioEvidenciaUpdateArgs<ExtArgs>>): Prisma__ComentarioEvidenciaClient<$Result.GetResult<Prisma.$ComentarioEvidenciaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComentarioEvidencias.
     * @param {ComentarioEvidenciaDeleteManyArgs} args - Arguments to filter ComentarioEvidencias to delete.
     * @example
     * // Delete a few ComentarioEvidencias
     * const { count } = await prisma.comentarioEvidencia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComentarioEvidenciaDeleteManyArgs>(args?: SelectSubset<T, ComentarioEvidenciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComentarioEvidencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioEvidenciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComentarioEvidencias
     * const comentarioEvidencia = await prisma.comentarioEvidencia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComentarioEvidenciaUpdateManyArgs>(args: SelectSubset<T, ComentarioEvidenciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComentarioEvidencia.
     * @param {ComentarioEvidenciaUpsertArgs} args - Arguments to update or create a ComentarioEvidencia.
     * @example
     * // Update or create a ComentarioEvidencia
     * const comentarioEvidencia = await prisma.comentarioEvidencia.upsert({
     *   create: {
     *     // ... data to create a ComentarioEvidencia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComentarioEvidencia we want to update
     *   }
     * })
     */
    upsert<T extends ComentarioEvidenciaUpsertArgs>(args: SelectSubset<T, ComentarioEvidenciaUpsertArgs<ExtArgs>>): Prisma__ComentarioEvidenciaClient<$Result.GetResult<Prisma.$ComentarioEvidenciaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComentarioEvidencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioEvidenciaCountArgs} args - Arguments to filter ComentarioEvidencias to count.
     * @example
     * // Count the number of ComentarioEvidencias
     * const count = await prisma.comentarioEvidencia.count({
     *   where: {
     *     // ... the filter for the ComentarioEvidencias we want to count
     *   }
     * })
    **/
    count<T extends ComentarioEvidenciaCountArgs>(
      args?: Subset<T, ComentarioEvidenciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentarioEvidenciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComentarioEvidencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioEvidenciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentarioEvidenciaAggregateArgs>(args: Subset<T, ComentarioEvidenciaAggregateArgs>): Prisma.PrismaPromise<GetComentarioEvidenciaAggregateType<T>>

    /**
     * Group by ComentarioEvidencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioEvidenciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComentarioEvidenciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComentarioEvidenciaGroupByArgs['orderBy'] }
        : { orderBy?: ComentarioEvidenciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComentarioEvidenciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentarioEvidenciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComentarioEvidencia model
   */
  readonly fields: ComentarioEvidenciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComentarioEvidencia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComentarioEvidenciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evidencia<T extends EvidenciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvidenciaDefaultArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComentarioEvidencia model
   */ 
  interface ComentarioEvidenciaFieldRefs {
    readonly id: FieldRef<"ComentarioEvidencia", 'String'>
    readonly texto: FieldRef<"ComentarioEvidencia", 'String'>
    readonly data: FieldRef<"ComentarioEvidencia", 'DateTime'>
    readonly evidenciaId: FieldRef<"ComentarioEvidencia", 'String'>
    readonly usuarioId: FieldRef<"ComentarioEvidencia", 'String'>
    readonly createdAt: FieldRef<"ComentarioEvidencia", 'DateTime'>
    readonly updatedAt: FieldRef<"ComentarioEvidencia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComentarioEvidencia findUnique
   */
  export type ComentarioEvidenciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which ComentarioEvidencia to fetch.
     */
    where: ComentarioEvidenciaWhereUniqueInput
  }

  /**
   * ComentarioEvidencia findUniqueOrThrow
   */
  export type ComentarioEvidenciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which ComentarioEvidencia to fetch.
     */
    where: ComentarioEvidenciaWhereUniqueInput
  }

  /**
   * ComentarioEvidencia findFirst
   */
  export type ComentarioEvidenciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which ComentarioEvidencia to fetch.
     */
    where?: ComentarioEvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComentarioEvidencias to fetch.
     */
    orderBy?: ComentarioEvidenciaOrderByWithRelationInput | ComentarioEvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComentarioEvidencias.
     */
    cursor?: ComentarioEvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComentarioEvidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComentarioEvidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComentarioEvidencias.
     */
    distinct?: ComentarioEvidenciaScalarFieldEnum | ComentarioEvidenciaScalarFieldEnum[]
  }

  /**
   * ComentarioEvidencia findFirstOrThrow
   */
  export type ComentarioEvidenciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which ComentarioEvidencia to fetch.
     */
    where?: ComentarioEvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComentarioEvidencias to fetch.
     */
    orderBy?: ComentarioEvidenciaOrderByWithRelationInput | ComentarioEvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComentarioEvidencias.
     */
    cursor?: ComentarioEvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComentarioEvidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComentarioEvidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComentarioEvidencias.
     */
    distinct?: ComentarioEvidenciaScalarFieldEnum | ComentarioEvidenciaScalarFieldEnum[]
  }

  /**
   * ComentarioEvidencia findMany
   */
  export type ComentarioEvidenciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which ComentarioEvidencias to fetch.
     */
    where?: ComentarioEvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComentarioEvidencias to fetch.
     */
    orderBy?: ComentarioEvidenciaOrderByWithRelationInput | ComentarioEvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComentarioEvidencias.
     */
    cursor?: ComentarioEvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComentarioEvidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComentarioEvidencias.
     */
    skip?: number
    distinct?: ComentarioEvidenciaScalarFieldEnum | ComentarioEvidenciaScalarFieldEnum[]
  }

  /**
   * ComentarioEvidencia create
   */
  export type ComentarioEvidenciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaInclude<ExtArgs> | null
    /**
     * The data needed to create a ComentarioEvidencia.
     */
    data: XOR<ComentarioEvidenciaCreateInput, ComentarioEvidenciaUncheckedCreateInput>
  }

  /**
   * ComentarioEvidencia createMany
   */
  export type ComentarioEvidenciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComentarioEvidencias.
     */
    data: ComentarioEvidenciaCreateManyInput | ComentarioEvidenciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComentarioEvidencia createManyAndReturn
   */
  export type ComentarioEvidenciaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComentarioEvidencias.
     */
    data: ComentarioEvidenciaCreateManyInput | ComentarioEvidenciaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComentarioEvidencia update
   */
  export type ComentarioEvidenciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaInclude<ExtArgs> | null
    /**
     * The data needed to update a ComentarioEvidencia.
     */
    data: XOR<ComentarioEvidenciaUpdateInput, ComentarioEvidenciaUncheckedUpdateInput>
    /**
     * Choose, which ComentarioEvidencia to update.
     */
    where: ComentarioEvidenciaWhereUniqueInput
  }

  /**
   * ComentarioEvidencia updateMany
   */
  export type ComentarioEvidenciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComentarioEvidencias.
     */
    data: XOR<ComentarioEvidenciaUpdateManyMutationInput, ComentarioEvidenciaUncheckedUpdateManyInput>
    /**
     * Filter which ComentarioEvidencias to update
     */
    where?: ComentarioEvidenciaWhereInput
  }

  /**
   * ComentarioEvidencia upsert
   */
  export type ComentarioEvidenciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaInclude<ExtArgs> | null
    /**
     * The filter to search for the ComentarioEvidencia to update in case it exists.
     */
    where: ComentarioEvidenciaWhereUniqueInput
    /**
     * In case the ComentarioEvidencia found by the `where` argument doesn't exist, create a new ComentarioEvidencia with this data.
     */
    create: XOR<ComentarioEvidenciaCreateInput, ComentarioEvidenciaUncheckedCreateInput>
    /**
     * In case the ComentarioEvidencia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComentarioEvidenciaUpdateInput, ComentarioEvidenciaUncheckedUpdateInput>
  }

  /**
   * ComentarioEvidencia delete
   */
  export type ComentarioEvidenciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaInclude<ExtArgs> | null
    /**
     * Filter which ComentarioEvidencia to delete.
     */
    where: ComentarioEvidenciaWhereUniqueInput
  }

  /**
   * ComentarioEvidencia deleteMany
   */
  export type ComentarioEvidenciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComentarioEvidencias to delete
     */
    where?: ComentarioEvidenciaWhereInput
  }

  /**
   * ComentarioEvidencia without action
   */
  export type ComentarioEvidenciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioEvidencia
     */
    select?: ComentarioEvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioEvidenciaInclude<ExtArgs> | null
  }


  /**
   * Model Medicamento
   */

  export type AggregateMedicamento = {
    _count: MedicamentoCountAggregateOutputType | null
    _avg: MedicamentoAvgAggregateOutputType | null
    _sum: MedicamentoSumAggregateOutputType | null
    _min: MedicamentoMinAggregateOutputType | null
    _max: MedicamentoMaxAggregateOutputType | null
  }

  export type MedicamentoAvgAggregateOutputType = {
    duracaoDias: number | null
  }

  export type MedicamentoSumAggregateOutputType = {
    duracaoDias: number | null
  }

  export type MedicamentoMinAggregateOutputType = {
    id: string | null
    codigo: string | null
    nome: string | null
    tipo: string | null
    ultimaCompra: Date | null
    proximaCompra: Date | null
    duracaoDias: number | null
    lembreteEnviado: boolean | null
    farmaciaId: string | null
    clienteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicamentoMaxAggregateOutputType = {
    id: string | null
    codigo: string | null
    nome: string | null
    tipo: string | null
    ultimaCompra: Date | null
    proximaCompra: Date | null
    duracaoDias: number | null
    lembreteEnviado: boolean | null
    farmaciaId: string | null
    clienteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicamentoCountAggregateOutputType = {
    id: number
    codigo: number
    nome: number
    tipo: number
    ultimaCompra: number
    proximaCompra: number
    duracaoDias: number
    lembreteEnviado: number
    farmaciaId: number
    clienteId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicamentoAvgAggregateInputType = {
    duracaoDias?: true
  }

  export type MedicamentoSumAggregateInputType = {
    duracaoDias?: true
  }

  export type MedicamentoMinAggregateInputType = {
    id?: true
    codigo?: true
    nome?: true
    tipo?: true
    ultimaCompra?: true
    proximaCompra?: true
    duracaoDias?: true
    lembreteEnviado?: true
    farmaciaId?: true
    clienteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicamentoMaxAggregateInputType = {
    id?: true
    codigo?: true
    nome?: true
    tipo?: true
    ultimaCompra?: true
    proximaCompra?: true
    duracaoDias?: true
    lembreteEnviado?: true
    farmaciaId?: true
    clienteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicamentoCountAggregateInputType = {
    id?: true
    codigo?: true
    nome?: true
    tipo?: true
    ultimaCompra?: true
    proximaCompra?: true
    duracaoDias?: true
    lembreteEnviado?: true
    farmaciaId?: true
    clienteId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicamento to aggregate.
     */
    where?: MedicamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicamentos to fetch.
     */
    orderBy?: MedicamentoOrderByWithRelationInput | MedicamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medicamentos
    **/
    _count?: true | MedicamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicamentoMaxAggregateInputType
  }

  export type GetMedicamentoAggregateType<T extends MedicamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicamento[P]>
      : GetScalarType<T[P], AggregateMedicamento[P]>
  }




  export type MedicamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicamentoWhereInput
    orderBy?: MedicamentoOrderByWithAggregationInput | MedicamentoOrderByWithAggregationInput[]
    by: MedicamentoScalarFieldEnum[] | MedicamentoScalarFieldEnum
    having?: MedicamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicamentoCountAggregateInputType | true
    _avg?: MedicamentoAvgAggregateInputType
    _sum?: MedicamentoSumAggregateInputType
    _min?: MedicamentoMinAggregateInputType
    _max?: MedicamentoMaxAggregateInputType
  }

  export type MedicamentoGroupByOutputType = {
    id: string
    codigo: string
    nome: string
    tipo: string
    ultimaCompra: Date
    proximaCompra: Date
    duracaoDias: number
    lembreteEnviado: boolean
    farmaciaId: string
    clienteId: string
    createdAt: Date
    updatedAt: Date
    _count: MedicamentoCountAggregateOutputType | null
    _avg: MedicamentoAvgAggregateOutputType | null
    _sum: MedicamentoSumAggregateOutputType | null
    _min: MedicamentoMinAggregateOutputType | null
    _max: MedicamentoMaxAggregateOutputType | null
  }

  type GetMedicamentoGroupByPayload<T extends MedicamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicamentoGroupByOutputType[P]>
            : GetScalarType<T[P], MedicamentoGroupByOutputType[P]>
        }
      >
    >


  export type MedicamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nome?: boolean
    tipo?: boolean
    ultimaCompra?: boolean
    proximaCompra?: boolean
    duracaoDias?: boolean
    lembreteEnviado?: boolean
    farmaciaId?: boolean
    clienteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicamento"]>

  export type MedicamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nome?: boolean
    tipo?: boolean
    ultimaCompra?: boolean
    proximaCompra?: boolean
    duracaoDias?: boolean
    lembreteEnviado?: boolean
    farmaciaId?: boolean
    clienteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicamento"]>

  export type MedicamentoSelectScalar = {
    id?: boolean
    codigo?: boolean
    nome?: boolean
    tipo?: boolean
    ultimaCompra?: boolean
    proximaCompra?: boolean
    duracaoDias?: boolean
    lembreteEnviado?: boolean
    farmaciaId?: boolean
    clienteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type MedicamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmacia?: boolean | FarmaciaDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }

  export type $MedicamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medicamento"
    objects: {
      farmacia: Prisma.$FarmaciaPayload<ExtArgs>
      cliente: Prisma.$ClientePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      codigo: string
      nome: string
      tipo: string
      ultimaCompra: Date
      proximaCompra: Date
      duracaoDias: number
      lembreteEnviado: boolean
      farmaciaId: string
      clienteId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicamento"]>
    composites: {}
  }

  type MedicamentoGetPayload<S extends boolean | null | undefined | MedicamentoDefaultArgs> = $Result.GetResult<Prisma.$MedicamentoPayload, S>

  type MedicamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicamentoCountAggregateInputType | true
    }

  export interface MedicamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medicamento'], meta: { name: 'Medicamento' } }
    /**
     * Find zero or one Medicamento that matches the filter.
     * @param {MedicamentoFindUniqueArgs} args - Arguments to find a Medicamento
     * @example
     * // Get one Medicamento
     * const medicamento = await prisma.medicamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicamentoFindUniqueArgs>(args: SelectSubset<T, MedicamentoFindUniqueArgs<ExtArgs>>): Prisma__MedicamentoClient<$Result.GetResult<Prisma.$MedicamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medicamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicamentoFindUniqueOrThrowArgs} args - Arguments to find a Medicamento
     * @example
     * // Get one Medicamento
     * const medicamento = await prisma.medicamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicamentoClient<$Result.GetResult<Prisma.$MedicamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medicamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentoFindFirstArgs} args - Arguments to find a Medicamento
     * @example
     * // Get one Medicamento
     * const medicamento = await prisma.medicamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicamentoFindFirstArgs>(args?: SelectSubset<T, MedicamentoFindFirstArgs<ExtArgs>>): Prisma__MedicamentoClient<$Result.GetResult<Prisma.$MedicamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medicamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentoFindFirstOrThrowArgs} args - Arguments to find a Medicamento
     * @example
     * // Get one Medicamento
     * const medicamento = await prisma.medicamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicamentoClient<$Result.GetResult<Prisma.$MedicamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medicamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicamentos
     * const medicamentos = await prisma.medicamento.findMany()
     * 
     * // Get first 10 Medicamentos
     * const medicamentos = await prisma.medicamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicamentoWithIdOnly = await prisma.medicamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicamentoFindManyArgs>(args?: SelectSubset<T, MedicamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medicamento.
     * @param {MedicamentoCreateArgs} args - Arguments to create a Medicamento.
     * @example
     * // Create one Medicamento
     * const Medicamento = await prisma.medicamento.create({
     *   data: {
     *     // ... data to create a Medicamento
     *   }
     * })
     * 
     */
    create<T extends MedicamentoCreateArgs>(args: SelectSubset<T, MedicamentoCreateArgs<ExtArgs>>): Prisma__MedicamentoClient<$Result.GetResult<Prisma.$MedicamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medicamentos.
     * @param {MedicamentoCreateManyArgs} args - Arguments to create many Medicamentos.
     * @example
     * // Create many Medicamentos
     * const medicamento = await prisma.medicamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicamentoCreateManyArgs>(args?: SelectSubset<T, MedicamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medicamentos and returns the data saved in the database.
     * @param {MedicamentoCreateManyAndReturnArgs} args - Arguments to create many Medicamentos.
     * @example
     * // Create many Medicamentos
     * const medicamento = await prisma.medicamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medicamentos and only return the `id`
     * const medicamentoWithIdOnly = await prisma.medicamento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicamentoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Medicamento.
     * @param {MedicamentoDeleteArgs} args - Arguments to delete one Medicamento.
     * @example
     * // Delete one Medicamento
     * const Medicamento = await prisma.medicamento.delete({
     *   where: {
     *     // ... filter to delete one Medicamento
     *   }
     * })
     * 
     */
    delete<T extends MedicamentoDeleteArgs>(args: SelectSubset<T, MedicamentoDeleteArgs<ExtArgs>>): Prisma__MedicamentoClient<$Result.GetResult<Prisma.$MedicamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medicamento.
     * @param {MedicamentoUpdateArgs} args - Arguments to update one Medicamento.
     * @example
     * // Update one Medicamento
     * const medicamento = await prisma.medicamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicamentoUpdateArgs>(args: SelectSubset<T, MedicamentoUpdateArgs<ExtArgs>>): Prisma__MedicamentoClient<$Result.GetResult<Prisma.$MedicamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medicamentos.
     * @param {MedicamentoDeleteManyArgs} args - Arguments to filter Medicamentos to delete.
     * @example
     * // Delete a few Medicamentos
     * const { count } = await prisma.medicamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicamentoDeleteManyArgs>(args?: SelectSubset<T, MedicamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicamentos
     * const medicamento = await prisma.medicamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicamentoUpdateManyArgs>(args: SelectSubset<T, MedicamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medicamento.
     * @param {MedicamentoUpsertArgs} args - Arguments to update or create a Medicamento.
     * @example
     * // Update or create a Medicamento
     * const medicamento = await prisma.medicamento.upsert({
     *   create: {
     *     // ... data to create a Medicamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicamento we want to update
     *   }
     * })
     */
    upsert<T extends MedicamentoUpsertArgs>(args: SelectSubset<T, MedicamentoUpsertArgs<ExtArgs>>): Prisma__MedicamentoClient<$Result.GetResult<Prisma.$MedicamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medicamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentoCountArgs} args - Arguments to filter Medicamentos to count.
     * @example
     * // Count the number of Medicamentos
     * const count = await prisma.medicamento.count({
     *   where: {
     *     // ... the filter for the Medicamentos we want to count
     *   }
     * })
    **/
    count<T extends MedicamentoCountArgs>(
      args?: Subset<T, MedicamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicamentoAggregateArgs>(args: Subset<T, MedicamentoAggregateArgs>): Prisma.PrismaPromise<GetMedicamentoAggregateType<T>>

    /**
     * Group by Medicamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicamentoGroupByArgs['orderBy'] }
        : { orderBy?: MedicamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medicamento model
   */
  readonly fields: MedicamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medicamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    farmacia<T extends FarmaciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FarmaciaDefaultArgs<ExtArgs>>): Prisma__FarmaciaClient<$Result.GetResult<Prisma.$FarmaciaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medicamento model
   */ 
  interface MedicamentoFieldRefs {
    readonly id: FieldRef<"Medicamento", 'String'>
    readonly codigo: FieldRef<"Medicamento", 'String'>
    readonly nome: FieldRef<"Medicamento", 'String'>
    readonly tipo: FieldRef<"Medicamento", 'String'>
    readonly ultimaCompra: FieldRef<"Medicamento", 'DateTime'>
    readonly proximaCompra: FieldRef<"Medicamento", 'DateTime'>
    readonly duracaoDias: FieldRef<"Medicamento", 'Int'>
    readonly lembreteEnviado: FieldRef<"Medicamento", 'Boolean'>
    readonly farmaciaId: FieldRef<"Medicamento", 'String'>
    readonly clienteId: FieldRef<"Medicamento", 'String'>
    readonly createdAt: FieldRef<"Medicamento", 'DateTime'>
    readonly updatedAt: FieldRef<"Medicamento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Medicamento findUnique
   */
  export type MedicamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoInclude<ExtArgs> | null
    /**
     * Filter, which Medicamento to fetch.
     */
    where: MedicamentoWhereUniqueInput
  }

  /**
   * Medicamento findUniqueOrThrow
   */
  export type MedicamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoInclude<ExtArgs> | null
    /**
     * Filter, which Medicamento to fetch.
     */
    where: MedicamentoWhereUniqueInput
  }

  /**
   * Medicamento findFirst
   */
  export type MedicamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoInclude<ExtArgs> | null
    /**
     * Filter, which Medicamento to fetch.
     */
    where?: MedicamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicamentos to fetch.
     */
    orderBy?: MedicamentoOrderByWithRelationInput | MedicamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicamentos.
     */
    cursor?: MedicamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicamentos.
     */
    distinct?: MedicamentoScalarFieldEnum | MedicamentoScalarFieldEnum[]
  }

  /**
   * Medicamento findFirstOrThrow
   */
  export type MedicamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoInclude<ExtArgs> | null
    /**
     * Filter, which Medicamento to fetch.
     */
    where?: MedicamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicamentos to fetch.
     */
    orderBy?: MedicamentoOrderByWithRelationInput | MedicamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicamentos.
     */
    cursor?: MedicamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicamentos.
     */
    distinct?: MedicamentoScalarFieldEnum | MedicamentoScalarFieldEnum[]
  }

  /**
   * Medicamento findMany
   */
  export type MedicamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoInclude<ExtArgs> | null
    /**
     * Filter, which Medicamentos to fetch.
     */
    where?: MedicamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicamentos to fetch.
     */
    orderBy?: MedicamentoOrderByWithRelationInput | MedicamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medicamentos.
     */
    cursor?: MedicamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicamentos.
     */
    skip?: number
    distinct?: MedicamentoScalarFieldEnum | MedicamentoScalarFieldEnum[]
  }

  /**
   * Medicamento create
   */
  export type MedicamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Medicamento.
     */
    data: XOR<MedicamentoCreateInput, MedicamentoUncheckedCreateInput>
  }

  /**
   * Medicamento createMany
   */
  export type MedicamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medicamentos.
     */
    data: MedicamentoCreateManyInput | MedicamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medicamento createManyAndReturn
   */
  export type MedicamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Medicamentos.
     */
    data: MedicamentoCreateManyInput | MedicamentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medicamento update
   */
  export type MedicamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Medicamento.
     */
    data: XOR<MedicamentoUpdateInput, MedicamentoUncheckedUpdateInput>
    /**
     * Choose, which Medicamento to update.
     */
    where: MedicamentoWhereUniqueInput
  }

  /**
   * Medicamento updateMany
   */
  export type MedicamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medicamentos.
     */
    data: XOR<MedicamentoUpdateManyMutationInput, MedicamentoUncheckedUpdateManyInput>
    /**
     * Filter which Medicamentos to update
     */
    where?: MedicamentoWhereInput
  }

  /**
   * Medicamento upsert
   */
  export type MedicamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Medicamento to update in case it exists.
     */
    where: MedicamentoWhereUniqueInput
    /**
     * In case the Medicamento found by the `where` argument doesn't exist, create a new Medicamento with this data.
     */
    create: XOR<MedicamentoCreateInput, MedicamentoUncheckedCreateInput>
    /**
     * In case the Medicamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicamentoUpdateInput, MedicamentoUncheckedUpdateInput>
  }

  /**
   * Medicamento delete
   */
  export type MedicamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoInclude<ExtArgs> | null
    /**
     * Filter which Medicamento to delete.
     */
    where: MedicamentoWhereUniqueInput
  }

  /**
   * Medicamento deleteMany
   */
  export type MedicamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicamentos to delete
     */
    where?: MedicamentoWhereInput
  }

  /**
   * Medicamento without action
   */
  export type MedicamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoInclude<ExtArgs> | null
  }


  /**
   * Model Cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteMinAggregateOutputType = {
    id: string | null
    nome: string | null
    telefone: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClienteMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    telefone: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClienteCountAggregateOutputType = {
    id: number
    nome: number
    telefone: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClienteMinAggregateInputType = {
    id?: true
    nome?: true
    telefone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClienteMaxAggregateInputType = {
    id?: true
    nome?: true
    telefone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClienteCountAggregateInputType = {
    id?: true
    nome?: true
    telefone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cliente to aggregate.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithAggregationInput | ClienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    id: string
    nome: string
    telefone: string
    email: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClienteCountAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    telefone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicamentos?: boolean | Cliente$medicamentosArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    telefone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectScalar = {
    id?: boolean
    nome?: boolean
    telefone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicamentos?: boolean | Cliente$medicamentosArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cliente"
    objects: {
      medicamentos: Prisma.$MedicamentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      telefone: string
      email: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }

  type ClienteGetPayload<S extends boolean | null | undefined | ClienteDefaultArgs> = $Result.GetResult<Prisma.$ClientePayload, S>

  type ClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface ClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cliente'], meta: { name: 'Cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteFindUniqueArgs>(args: SelectSubset<T, ClienteFindUniqueArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteFindFirstArgs>(args?: SelectSubset<T, ClienteFindFirstArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteWithIdOnly = await prisma.cliente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteFindManyArgs>(args?: SelectSubset<T, ClienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
     */
    create<T extends ClienteCreateArgs>(args: SelectSubset<T, ClienteCreateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clientes.
     * @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteCreateManyArgs>(args?: SelectSubset<T, ClienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {ClienteCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clientes and only return the `id`
     * const clienteWithIdOnly = await prisma.cliente.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
     */
    delete<T extends ClienteDeleteArgs>(args: SelectSubset<T, ClienteDeleteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteUpdateArgs>(args: SelectSubset<T, ClienteUpdateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteDeleteManyArgs>(args?: SelectSubset<T, ClienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteUpdateManyArgs>(args: SelectSubset<T, ClienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends ClienteUpsertArgs>(args: SelectSubset<T, ClienteUpsertArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cliente model
   */
  readonly fields: ClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicamentos<T extends Cliente$medicamentosArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$medicamentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicamentoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cliente model
   */ 
  interface ClienteFieldRefs {
    readonly id: FieldRef<"Cliente", 'String'>
    readonly nome: FieldRef<"Cliente", 'String'>
    readonly telefone: FieldRef<"Cliente", 'String'>
    readonly email: FieldRef<"Cliente", 'String'>
    readonly createdAt: FieldRef<"Cliente", 'DateTime'>
    readonly updatedAt: FieldRef<"Cliente", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cliente findUnique
   */
  export type ClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findFirst
   */
  export type ClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente create
   */
  export type ClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Cliente.
     */
    data: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }

  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente createManyAndReturn
   */
  export type ClienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente update
   */
  export type ClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Cliente.
     */
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     */
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     */
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }

  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter which Cliente to delete.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente.medicamentos
   */
  export type Cliente$medicamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicamento
     */
    select?: MedicamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentoInclude<ExtArgs> | null
    where?: MedicamentoWhereInput
    orderBy?: MedicamentoOrderByWithRelationInput | MedicamentoOrderByWithRelationInput[]
    cursor?: MedicamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicamentoScalarFieldEnum | MedicamentoScalarFieldEnum[]
  }

  /**
   * Cliente without action
   */
  export type ClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    perfil: 'perfil',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const FarmaciaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    cnpj: 'cnpj',
    endereco: 'endereco',
    telefone: 'telefone',
    email: 'email',
    corPrincipal: 'corPrincipal',
    corSecundaria: 'corSecundaria',
    logo: 'logo',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FarmaciaScalarFieldEnum = (typeof FarmaciaScalarFieldEnum)[keyof typeof FarmaciaScalarFieldEnum]


  export const FarmaciaUsuarioScalarFieldEnum: {
    id: 'id',
    farmaciaId: 'farmaciaId',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FarmaciaUsuarioScalarFieldEnum = (typeof FarmaciaUsuarioScalarFieldEnum)[keyof typeof FarmaciaUsuarioScalarFieldEnum]


  export const IndicadorScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    nome: 'nome',
    categoria: 'categoria',
    unidade: 'unidade',
    metaPadrao: 'metaPadrao',
    temImpacto: 'temImpacto',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IndicadorScalarFieldEnum = (typeof IndicadorScalarFieldEnum)[keyof typeof IndicadorScalarFieldEnum]


  export const IndicadorRelacionadoScalarFieldEnum: {
    id: 'id',
    indicadorOrigemId: 'indicadorOrigemId',
    indicadorDestinoId: 'indicadorDestinoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IndicadorRelacionadoScalarFieldEnum = (typeof IndicadorRelacionadoScalarFieldEnum)[keyof typeof IndicadorRelacionadoScalarFieldEnum]


  export const PlanoAcaoScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descricao: 'descricao',
    farmaciaId: 'farmaciaId',
    indicadorId: 'indicadorId',
    responsavelId: 'responsavelId',
    dataCriacao: 'dataCriacao',
    prazo: 'prazo',
    status: 'status',
    percentualConcluido: 'percentualConcluido',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanoAcaoScalarFieldEnum = (typeof PlanoAcaoScalarFieldEnum)[keyof typeof PlanoAcaoScalarFieldEnum]


  export const AcaoScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    prazo: 'prazo',
    concluida: 'concluida',
    atrasada: 'atrasada',
    planoAcaoId: 'planoAcaoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcaoScalarFieldEnum = (typeof AcaoScalarFieldEnum)[keyof typeof AcaoScalarFieldEnum]


  export const ComentarioScalarFieldEnum: {
    id: 'id',
    texto: 'texto',
    data: 'data',
    planoAcaoId: 'planoAcaoId',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComentarioScalarFieldEnum = (typeof ComentarioScalarFieldEnum)[keyof typeof ComentarioScalarFieldEnum]


  export const EvidenciaScalarFieldEnum: {
    id: 'id',
    url: 'url',
    descricao: 'descricao',
    dataCriacao: 'dataCriacao',
    status: 'status',
    dataValidacao: 'dataValidacao',
    validadoPorId: 'validadoPorId',
    motivoReprovacao: 'motivoReprovacao',
    planoId: 'planoId',
    farmaciaId: 'farmaciaId',
    indicadorId: 'indicadorId',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvidenciaScalarFieldEnum = (typeof EvidenciaScalarFieldEnum)[keyof typeof EvidenciaScalarFieldEnum]


  export const ComentarioEvidenciaScalarFieldEnum: {
    id: 'id',
    texto: 'texto',
    data: 'data',
    evidenciaId: 'evidenciaId',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComentarioEvidenciaScalarFieldEnum = (typeof ComentarioEvidenciaScalarFieldEnum)[keyof typeof ComentarioEvidenciaScalarFieldEnum]


  export const MedicamentoScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    nome: 'nome',
    tipo: 'tipo',
    ultimaCompra: 'ultimaCompra',
    proximaCompra: 'proximaCompra',
    duracaoDias: 'duracaoDias',
    lembreteEnviado: 'lembreteEnviado',
    farmaciaId: 'farmaciaId',
    clienteId: 'clienteId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicamentoScalarFieldEnum = (typeof MedicamentoScalarFieldEnum)[keyof typeof MedicamentoScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    telefone: 'telefone',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: StringFilter<"Usuario"> | string
    nome?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    perfil?: StringFilter<"Usuario"> | string
    ativo?: BoolFilter<"Usuario"> | boolean
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    farmaciasUsuario?: FarmaciaUsuarioListRelationFilter
    planos?: PlanoAcaoListRelationFilter
    comentarios?: ComentarioListRelationFilter
    evidencias?: EvidenciaListRelationFilter
    comentariosEvidencia?: ComentarioEvidenciaListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    farmaciasUsuario?: FarmaciaUsuarioOrderByRelationAggregateInput
    planos?: PlanoAcaoOrderByRelationAggregateInput
    comentarios?: ComentarioOrderByRelationAggregateInput
    evidencias?: EvidenciaOrderByRelationAggregateInput
    comentariosEvidencia?: ComentarioEvidenciaOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nome?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    perfil?: StringFilter<"Usuario"> | string
    ativo?: BoolFilter<"Usuario"> | boolean
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    farmaciasUsuario?: FarmaciaUsuarioListRelationFilter
    planos?: PlanoAcaoListRelationFilter
    comentarios?: ComentarioListRelationFilter
    evidencias?: EvidenciaListRelationFilter
    comentariosEvidencia?: ComentarioEvidenciaListRelationFilter
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Usuario"> | string
    nome?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    senha?: StringWithAggregatesFilter<"Usuario"> | string
    perfil?: StringWithAggregatesFilter<"Usuario"> | string
    ativo?: BoolWithAggregatesFilter<"Usuario"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type FarmaciaWhereInput = {
    AND?: FarmaciaWhereInput | FarmaciaWhereInput[]
    OR?: FarmaciaWhereInput[]
    NOT?: FarmaciaWhereInput | FarmaciaWhereInput[]
    id?: StringFilter<"Farmacia"> | string
    nome?: StringFilter<"Farmacia"> | string
    cnpj?: StringFilter<"Farmacia"> | string
    endereco?: StringNullableFilter<"Farmacia"> | string | null
    telefone?: StringNullableFilter<"Farmacia"> | string | null
    email?: StringNullableFilter<"Farmacia"> | string | null
    corPrincipal?: StringFilter<"Farmacia"> | string
    corSecundaria?: StringFilter<"Farmacia"> | string
    logo?: StringNullableFilter<"Farmacia"> | string | null
    ativo?: BoolFilter<"Farmacia"> | boolean
    createdAt?: DateTimeFilter<"Farmacia"> | Date | string
    updatedAt?: DateTimeFilter<"Farmacia"> | Date | string
    usuariosAssociados?: FarmaciaUsuarioListRelationFilter
    planosAcao?: PlanoAcaoListRelationFilter
    evidencias?: EvidenciaListRelationFilter
    medicamentos?: MedicamentoListRelationFilter
  }

  export type FarmaciaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    corPrincipal?: SortOrder
    corSecundaria?: SortOrder
    logo?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuariosAssociados?: FarmaciaUsuarioOrderByRelationAggregateInput
    planosAcao?: PlanoAcaoOrderByRelationAggregateInput
    evidencias?: EvidenciaOrderByRelationAggregateInput
    medicamentos?: MedicamentoOrderByRelationAggregateInput
  }

  export type FarmaciaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cnpj?: string
    AND?: FarmaciaWhereInput | FarmaciaWhereInput[]
    OR?: FarmaciaWhereInput[]
    NOT?: FarmaciaWhereInput | FarmaciaWhereInput[]
    nome?: StringFilter<"Farmacia"> | string
    endereco?: StringNullableFilter<"Farmacia"> | string | null
    telefone?: StringNullableFilter<"Farmacia"> | string | null
    email?: StringNullableFilter<"Farmacia"> | string | null
    corPrincipal?: StringFilter<"Farmacia"> | string
    corSecundaria?: StringFilter<"Farmacia"> | string
    logo?: StringNullableFilter<"Farmacia"> | string | null
    ativo?: BoolFilter<"Farmacia"> | boolean
    createdAt?: DateTimeFilter<"Farmacia"> | Date | string
    updatedAt?: DateTimeFilter<"Farmacia"> | Date | string
    usuariosAssociados?: FarmaciaUsuarioListRelationFilter
    planosAcao?: PlanoAcaoListRelationFilter
    evidencias?: EvidenciaListRelationFilter
    medicamentos?: MedicamentoListRelationFilter
  }, "id" | "cnpj">

  export type FarmaciaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    corPrincipal?: SortOrder
    corSecundaria?: SortOrder
    logo?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FarmaciaCountOrderByAggregateInput
    _max?: FarmaciaMaxOrderByAggregateInput
    _min?: FarmaciaMinOrderByAggregateInput
  }

  export type FarmaciaScalarWhereWithAggregatesInput = {
    AND?: FarmaciaScalarWhereWithAggregatesInput | FarmaciaScalarWhereWithAggregatesInput[]
    OR?: FarmaciaScalarWhereWithAggregatesInput[]
    NOT?: FarmaciaScalarWhereWithAggregatesInput | FarmaciaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Farmacia"> | string
    nome?: StringWithAggregatesFilter<"Farmacia"> | string
    cnpj?: StringWithAggregatesFilter<"Farmacia"> | string
    endereco?: StringNullableWithAggregatesFilter<"Farmacia"> | string | null
    telefone?: StringNullableWithAggregatesFilter<"Farmacia"> | string | null
    email?: StringNullableWithAggregatesFilter<"Farmacia"> | string | null
    corPrincipal?: StringWithAggregatesFilter<"Farmacia"> | string
    corSecundaria?: StringWithAggregatesFilter<"Farmacia"> | string
    logo?: StringNullableWithAggregatesFilter<"Farmacia"> | string | null
    ativo?: BoolWithAggregatesFilter<"Farmacia"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Farmacia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Farmacia"> | Date | string
  }

  export type FarmaciaUsuarioWhereInput = {
    AND?: FarmaciaUsuarioWhereInput | FarmaciaUsuarioWhereInput[]
    OR?: FarmaciaUsuarioWhereInput[]
    NOT?: FarmaciaUsuarioWhereInput | FarmaciaUsuarioWhereInput[]
    id?: StringFilter<"FarmaciaUsuario"> | string
    farmaciaId?: StringFilter<"FarmaciaUsuario"> | string
    usuarioId?: StringFilter<"FarmaciaUsuario"> | string
    createdAt?: DateTimeFilter<"FarmaciaUsuario"> | Date | string
    updatedAt?: DateTimeFilter<"FarmaciaUsuario"> | Date | string
    farmacia?: XOR<FarmaciaRelationFilter, FarmaciaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type FarmaciaUsuarioOrderByWithRelationInput = {
    id?: SortOrder
    farmaciaId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    farmacia?: FarmaciaOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type FarmaciaUsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    farmaciaId_usuarioId?: FarmaciaUsuarioFarmaciaIdUsuarioIdCompoundUniqueInput
    AND?: FarmaciaUsuarioWhereInput | FarmaciaUsuarioWhereInput[]
    OR?: FarmaciaUsuarioWhereInput[]
    NOT?: FarmaciaUsuarioWhereInput | FarmaciaUsuarioWhereInput[]
    farmaciaId?: StringFilter<"FarmaciaUsuario"> | string
    usuarioId?: StringFilter<"FarmaciaUsuario"> | string
    createdAt?: DateTimeFilter<"FarmaciaUsuario"> | Date | string
    updatedAt?: DateTimeFilter<"FarmaciaUsuario"> | Date | string
    farmacia?: XOR<FarmaciaRelationFilter, FarmaciaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "farmaciaId_usuarioId">

  export type FarmaciaUsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    farmaciaId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FarmaciaUsuarioCountOrderByAggregateInput
    _max?: FarmaciaUsuarioMaxOrderByAggregateInput
    _min?: FarmaciaUsuarioMinOrderByAggregateInput
  }

  export type FarmaciaUsuarioScalarWhereWithAggregatesInput = {
    AND?: FarmaciaUsuarioScalarWhereWithAggregatesInput | FarmaciaUsuarioScalarWhereWithAggregatesInput[]
    OR?: FarmaciaUsuarioScalarWhereWithAggregatesInput[]
    NOT?: FarmaciaUsuarioScalarWhereWithAggregatesInput | FarmaciaUsuarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FarmaciaUsuario"> | string
    farmaciaId?: StringWithAggregatesFilter<"FarmaciaUsuario"> | string
    usuarioId?: StringWithAggregatesFilter<"FarmaciaUsuario"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FarmaciaUsuario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FarmaciaUsuario"> | Date | string
  }

  export type IndicadorWhereInput = {
    AND?: IndicadorWhereInput | IndicadorWhereInput[]
    OR?: IndicadorWhereInput[]
    NOT?: IndicadorWhereInput | IndicadorWhereInput[]
    id?: StringFilter<"Indicador"> | string
    codigo?: StringFilter<"Indicador"> | string
    nome?: StringFilter<"Indicador"> | string
    categoria?: StringFilter<"Indicador"> | string
    unidade?: StringFilter<"Indicador"> | string
    metaPadrao?: StringFilter<"Indicador"> | string
    temImpacto?: BoolFilter<"Indicador"> | boolean
    createdAt?: DateTimeFilter<"Indicador"> | Date | string
    updatedAt?: DateTimeFilter<"Indicador"> | Date | string
    planosAcao?: PlanoAcaoListRelationFilter
    evidencias?: EvidenciaListRelationFilter
    relacionados?: IndicadorRelacionadoListRelationFilter
    relacionadoA?: IndicadorRelacionadoListRelationFilter
  }

  export type IndicadorOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
    unidade?: SortOrder
    metaPadrao?: SortOrder
    temImpacto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planosAcao?: PlanoAcaoOrderByRelationAggregateInput
    evidencias?: EvidenciaOrderByRelationAggregateInput
    relacionados?: IndicadorRelacionadoOrderByRelationAggregateInput
    relacionadoA?: IndicadorRelacionadoOrderByRelationAggregateInput
  }

  export type IndicadorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    codigo?: string
    AND?: IndicadorWhereInput | IndicadorWhereInput[]
    OR?: IndicadorWhereInput[]
    NOT?: IndicadorWhereInput | IndicadorWhereInput[]
    nome?: StringFilter<"Indicador"> | string
    categoria?: StringFilter<"Indicador"> | string
    unidade?: StringFilter<"Indicador"> | string
    metaPadrao?: StringFilter<"Indicador"> | string
    temImpacto?: BoolFilter<"Indicador"> | boolean
    createdAt?: DateTimeFilter<"Indicador"> | Date | string
    updatedAt?: DateTimeFilter<"Indicador"> | Date | string
    planosAcao?: PlanoAcaoListRelationFilter
    evidencias?: EvidenciaListRelationFilter
    relacionados?: IndicadorRelacionadoListRelationFilter
    relacionadoA?: IndicadorRelacionadoListRelationFilter
  }, "id" | "codigo">

  export type IndicadorOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
    unidade?: SortOrder
    metaPadrao?: SortOrder
    temImpacto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IndicadorCountOrderByAggregateInput
    _max?: IndicadorMaxOrderByAggregateInput
    _min?: IndicadorMinOrderByAggregateInput
  }

  export type IndicadorScalarWhereWithAggregatesInput = {
    AND?: IndicadorScalarWhereWithAggregatesInput | IndicadorScalarWhereWithAggregatesInput[]
    OR?: IndicadorScalarWhereWithAggregatesInput[]
    NOT?: IndicadorScalarWhereWithAggregatesInput | IndicadorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Indicador"> | string
    codigo?: StringWithAggregatesFilter<"Indicador"> | string
    nome?: StringWithAggregatesFilter<"Indicador"> | string
    categoria?: StringWithAggregatesFilter<"Indicador"> | string
    unidade?: StringWithAggregatesFilter<"Indicador"> | string
    metaPadrao?: StringWithAggregatesFilter<"Indicador"> | string
    temImpacto?: BoolWithAggregatesFilter<"Indicador"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Indicador"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Indicador"> | Date | string
  }

  export type IndicadorRelacionadoWhereInput = {
    AND?: IndicadorRelacionadoWhereInput | IndicadorRelacionadoWhereInput[]
    OR?: IndicadorRelacionadoWhereInput[]
    NOT?: IndicadorRelacionadoWhereInput | IndicadorRelacionadoWhereInput[]
    id?: StringFilter<"IndicadorRelacionado"> | string
    indicadorOrigemId?: StringFilter<"IndicadorRelacionado"> | string
    indicadorDestinoId?: StringFilter<"IndicadorRelacionado"> | string
    createdAt?: DateTimeFilter<"IndicadorRelacionado"> | Date | string
    updatedAt?: DateTimeFilter<"IndicadorRelacionado"> | Date | string
    indicadorOrigem?: XOR<IndicadorRelationFilter, IndicadorWhereInput>
    indicadorDestino?: XOR<IndicadorRelationFilter, IndicadorWhereInput>
  }

  export type IndicadorRelacionadoOrderByWithRelationInput = {
    id?: SortOrder
    indicadorOrigemId?: SortOrder
    indicadorDestinoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    indicadorOrigem?: IndicadorOrderByWithRelationInput
    indicadorDestino?: IndicadorOrderByWithRelationInput
  }

  export type IndicadorRelacionadoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    indicadorOrigemId_indicadorDestinoId?: IndicadorRelacionadoIndicadorOrigemIdIndicadorDestinoIdCompoundUniqueInput
    AND?: IndicadorRelacionadoWhereInput | IndicadorRelacionadoWhereInput[]
    OR?: IndicadorRelacionadoWhereInput[]
    NOT?: IndicadorRelacionadoWhereInput | IndicadorRelacionadoWhereInput[]
    indicadorOrigemId?: StringFilter<"IndicadorRelacionado"> | string
    indicadorDestinoId?: StringFilter<"IndicadorRelacionado"> | string
    createdAt?: DateTimeFilter<"IndicadorRelacionado"> | Date | string
    updatedAt?: DateTimeFilter<"IndicadorRelacionado"> | Date | string
    indicadorOrigem?: XOR<IndicadorRelationFilter, IndicadorWhereInput>
    indicadorDestino?: XOR<IndicadorRelationFilter, IndicadorWhereInput>
  }, "id" | "indicadorOrigemId_indicadorDestinoId">

  export type IndicadorRelacionadoOrderByWithAggregationInput = {
    id?: SortOrder
    indicadorOrigemId?: SortOrder
    indicadorDestinoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IndicadorRelacionadoCountOrderByAggregateInput
    _max?: IndicadorRelacionadoMaxOrderByAggregateInput
    _min?: IndicadorRelacionadoMinOrderByAggregateInput
  }

  export type IndicadorRelacionadoScalarWhereWithAggregatesInput = {
    AND?: IndicadorRelacionadoScalarWhereWithAggregatesInput | IndicadorRelacionadoScalarWhereWithAggregatesInput[]
    OR?: IndicadorRelacionadoScalarWhereWithAggregatesInput[]
    NOT?: IndicadorRelacionadoScalarWhereWithAggregatesInput | IndicadorRelacionadoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IndicadorRelacionado"> | string
    indicadorOrigemId?: StringWithAggregatesFilter<"IndicadorRelacionado"> | string
    indicadorDestinoId?: StringWithAggregatesFilter<"IndicadorRelacionado"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IndicadorRelacionado"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IndicadorRelacionado"> | Date | string
  }

  export type PlanoAcaoWhereInput = {
    AND?: PlanoAcaoWhereInput | PlanoAcaoWhereInput[]
    OR?: PlanoAcaoWhereInput[]
    NOT?: PlanoAcaoWhereInput | PlanoAcaoWhereInput[]
    id?: StringFilter<"PlanoAcao"> | string
    titulo?: StringFilter<"PlanoAcao"> | string
    descricao?: StringFilter<"PlanoAcao"> | string
    farmaciaId?: StringFilter<"PlanoAcao"> | string
    indicadorId?: StringFilter<"PlanoAcao"> | string
    responsavelId?: StringFilter<"PlanoAcao"> | string
    dataCriacao?: DateTimeFilter<"PlanoAcao"> | Date | string
    prazo?: DateTimeFilter<"PlanoAcao"> | Date | string
    status?: StringFilter<"PlanoAcao"> | string
    percentualConcluido?: IntFilter<"PlanoAcao"> | number
    createdAt?: DateTimeFilter<"PlanoAcao"> | Date | string
    updatedAt?: DateTimeFilter<"PlanoAcao"> | Date | string
    farmacia?: XOR<FarmaciaRelationFilter, FarmaciaWhereInput>
    indicador?: XOR<IndicadorRelationFilter, IndicadorWhereInput>
    responsavel?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    acoes?: AcaoListRelationFilter
    comentarios?: ComentarioListRelationFilter
    evidencias?: EvidenciaListRelationFilter
  }

  export type PlanoAcaoOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    farmaciaId?: SortOrder
    indicadorId?: SortOrder
    responsavelId?: SortOrder
    dataCriacao?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    percentualConcluido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    farmacia?: FarmaciaOrderByWithRelationInput
    indicador?: IndicadorOrderByWithRelationInput
    responsavel?: UsuarioOrderByWithRelationInput
    acoes?: AcaoOrderByRelationAggregateInput
    comentarios?: ComentarioOrderByRelationAggregateInput
    evidencias?: EvidenciaOrderByRelationAggregateInput
  }

  export type PlanoAcaoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanoAcaoWhereInput | PlanoAcaoWhereInput[]
    OR?: PlanoAcaoWhereInput[]
    NOT?: PlanoAcaoWhereInput | PlanoAcaoWhereInput[]
    titulo?: StringFilter<"PlanoAcao"> | string
    descricao?: StringFilter<"PlanoAcao"> | string
    farmaciaId?: StringFilter<"PlanoAcao"> | string
    indicadorId?: StringFilter<"PlanoAcao"> | string
    responsavelId?: StringFilter<"PlanoAcao"> | string
    dataCriacao?: DateTimeFilter<"PlanoAcao"> | Date | string
    prazo?: DateTimeFilter<"PlanoAcao"> | Date | string
    status?: StringFilter<"PlanoAcao"> | string
    percentualConcluido?: IntFilter<"PlanoAcao"> | number
    createdAt?: DateTimeFilter<"PlanoAcao"> | Date | string
    updatedAt?: DateTimeFilter<"PlanoAcao"> | Date | string
    farmacia?: XOR<FarmaciaRelationFilter, FarmaciaWhereInput>
    indicador?: XOR<IndicadorRelationFilter, IndicadorWhereInput>
    responsavel?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    acoes?: AcaoListRelationFilter
    comentarios?: ComentarioListRelationFilter
    evidencias?: EvidenciaListRelationFilter
  }, "id">

  export type PlanoAcaoOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    farmaciaId?: SortOrder
    indicadorId?: SortOrder
    responsavelId?: SortOrder
    dataCriacao?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    percentualConcluido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanoAcaoCountOrderByAggregateInput
    _avg?: PlanoAcaoAvgOrderByAggregateInput
    _max?: PlanoAcaoMaxOrderByAggregateInput
    _min?: PlanoAcaoMinOrderByAggregateInput
    _sum?: PlanoAcaoSumOrderByAggregateInput
  }

  export type PlanoAcaoScalarWhereWithAggregatesInput = {
    AND?: PlanoAcaoScalarWhereWithAggregatesInput | PlanoAcaoScalarWhereWithAggregatesInput[]
    OR?: PlanoAcaoScalarWhereWithAggregatesInput[]
    NOT?: PlanoAcaoScalarWhereWithAggregatesInput | PlanoAcaoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanoAcao"> | string
    titulo?: StringWithAggregatesFilter<"PlanoAcao"> | string
    descricao?: StringWithAggregatesFilter<"PlanoAcao"> | string
    farmaciaId?: StringWithAggregatesFilter<"PlanoAcao"> | string
    indicadorId?: StringWithAggregatesFilter<"PlanoAcao"> | string
    responsavelId?: StringWithAggregatesFilter<"PlanoAcao"> | string
    dataCriacao?: DateTimeWithAggregatesFilter<"PlanoAcao"> | Date | string
    prazo?: DateTimeWithAggregatesFilter<"PlanoAcao"> | Date | string
    status?: StringWithAggregatesFilter<"PlanoAcao"> | string
    percentualConcluido?: IntWithAggregatesFilter<"PlanoAcao"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PlanoAcao"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanoAcao"> | Date | string
  }

  export type AcaoWhereInput = {
    AND?: AcaoWhereInput | AcaoWhereInput[]
    OR?: AcaoWhereInput[]
    NOT?: AcaoWhereInput | AcaoWhereInput[]
    id?: StringFilter<"Acao"> | string
    descricao?: StringFilter<"Acao"> | string
    prazo?: DateTimeFilter<"Acao"> | Date | string
    concluida?: BoolFilter<"Acao"> | boolean
    atrasada?: BoolFilter<"Acao"> | boolean
    planoAcaoId?: StringFilter<"Acao"> | string
    createdAt?: DateTimeFilter<"Acao"> | Date | string
    updatedAt?: DateTimeFilter<"Acao"> | Date | string
    planoAcao?: XOR<PlanoAcaoRelationFilter, PlanoAcaoWhereInput>
  }

  export type AcaoOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    prazo?: SortOrder
    concluida?: SortOrder
    atrasada?: SortOrder
    planoAcaoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planoAcao?: PlanoAcaoOrderByWithRelationInput
  }

  export type AcaoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcaoWhereInput | AcaoWhereInput[]
    OR?: AcaoWhereInput[]
    NOT?: AcaoWhereInput | AcaoWhereInput[]
    descricao?: StringFilter<"Acao"> | string
    prazo?: DateTimeFilter<"Acao"> | Date | string
    concluida?: BoolFilter<"Acao"> | boolean
    atrasada?: BoolFilter<"Acao"> | boolean
    planoAcaoId?: StringFilter<"Acao"> | string
    createdAt?: DateTimeFilter<"Acao"> | Date | string
    updatedAt?: DateTimeFilter<"Acao"> | Date | string
    planoAcao?: XOR<PlanoAcaoRelationFilter, PlanoAcaoWhereInput>
  }, "id">

  export type AcaoOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    prazo?: SortOrder
    concluida?: SortOrder
    atrasada?: SortOrder
    planoAcaoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcaoCountOrderByAggregateInput
    _max?: AcaoMaxOrderByAggregateInput
    _min?: AcaoMinOrderByAggregateInput
  }

  export type AcaoScalarWhereWithAggregatesInput = {
    AND?: AcaoScalarWhereWithAggregatesInput | AcaoScalarWhereWithAggregatesInput[]
    OR?: AcaoScalarWhereWithAggregatesInput[]
    NOT?: AcaoScalarWhereWithAggregatesInput | AcaoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Acao"> | string
    descricao?: StringWithAggregatesFilter<"Acao"> | string
    prazo?: DateTimeWithAggregatesFilter<"Acao"> | Date | string
    concluida?: BoolWithAggregatesFilter<"Acao"> | boolean
    atrasada?: BoolWithAggregatesFilter<"Acao"> | boolean
    planoAcaoId?: StringWithAggregatesFilter<"Acao"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Acao"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Acao"> | Date | string
  }

  export type ComentarioWhereInput = {
    AND?: ComentarioWhereInput | ComentarioWhereInput[]
    OR?: ComentarioWhereInput[]
    NOT?: ComentarioWhereInput | ComentarioWhereInput[]
    id?: StringFilter<"Comentario"> | string
    texto?: StringFilter<"Comentario"> | string
    data?: DateTimeFilter<"Comentario"> | Date | string
    planoAcaoId?: StringFilter<"Comentario"> | string
    usuarioId?: StringFilter<"Comentario"> | string
    createdAt?: DateTimeFilter<"Comentario"> | Date | string
    updatedAt?: DateTimeFilter<"Comentario"> | Date | string
    planoAcao?: XOR<PlanoAcaoRelationFilter, PlanoAcaoWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type ComentarioOrderByWithRelationInput = {
    id?: SortOrder
    texto?: SortOrder
    data?: SortOrder
    planoAcaoId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planoAcao?: PlanoAcaoOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type ComentarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComentarioWhereInput | ComentarioWhereInput[]
    OR?: ComentarioWhereInput[]
    NOT?: ComentarioWhereInput | ComentarioWhereInput[]
    texto?: StringFilter<"Comentario"> | string
    data?: DateTimeFilter<"Comentario"> | Date | string
    planoAcaoId?: StringFilter<"Comentario"> | string
    usuarioId?: StringFilter<"Comentario"> | string
    createdAt?: DateTimeFilter<"Comentario"> | Date | string
    updatedAt?: DateTimeFilter<"Comentario"> | Date | string
    planoAcao?: XOR<PlanoAcaoRelationFilter, PlanoAcaoWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type ComentarioOrderByWithAggregationInput = {
    id?: SortOrder
    texto?: SortOrder
    data?: SortOrder
    planoAcaoId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComentarioCountOrderByAggregateInput
    _max?: ComentarioMaxOrderByAggregateInput
    _min?: ComentarioMinOrderByAggregateInput
  }

  export type ComentarioScalarWhereWithAggregatesInput = {
    AND?: ComentarioScalarWhereWithAggregatesInput | ComentarioScalarWhereWithAggregatesInput[]
    OR?: ComentarioScalarWhereWithAggregatesInput[]
    NOT?: ComentarioScalarWhereWithAggregatesInput | ComentarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comentario"> | string
    texto?: StringWithAggregatesFilter<"Comentario"> | string
    data?: DateTimeWithAggregatesFilter<"Comentario"> | Date | string
    planoAcaoId?: StringWithAggregatesFilter<"Comentario"> | string
    usuarioId?: StringWithAggregatesFilter<"Comentario"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comentario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comentario"> | Date | string
  }

  export type EvidenciaWhereInput = {
    AND?: EvidenciaWhereInput | EvidenciaWhereInput[]
    OR?: EvidenciaWhereInput[]
    NOT?: EvidenciaWhereInput | EvidenciaWhereInput[]
    id?: StringFilter<"Evidencia"> | string
    url?: StringFilter<"Evidencia"> | string
    descricao?: StringNullableFilter<"Evidencia"> | string | null
    dataCriacao?: DateTimeFilter<"Evidencia"> | Date | string
    status?: StringFilter<"Evidencia"> | string
    dataValidacao?: DateTimeNullableFilter<"Evidencia"> | Date | string | null
    validadoPorId?: StringNullableFilter<"Evidencia"> | string | null
    motivoReprovacao?: StringNullableFilter<"Evidencia"> | string | null
    planoId?: StringFilter<"Evidencia"> | string
    farmaciaId?: StringFilter<"Evidencia"> | string
    indicadorId?: StringFilter<"Evidencia"> | string
    usuarioId?: StringFilter<"Evidencia"> | string
    createdAt?: DateTimeFilter<"Evidencia"> | Date | string
    updatedAt?: DateTimeFilter<"Evidencia"> | Date | string
    plano?: XOR<PlanoAcaoRelationFilter, PlanoAcaoWhereInput>
    farmacia?: XOR<FarmaciaRelationFilter, FarmaciaWhereInput>
    indicador?: XOR<IndicadorRelationFilter, IndicadorWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    comentarios?: ComentarioEvidenciaListRelationFilter
  }

  export type EvidenciaOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    descricao?: SortOrderInput | SortOrder
    dataCriacao?: SortOrder
    status?: SortOrder
    dataValidacao?: SortOrderInput | SortOrder
    validadoPorId?: SortOrderInput | SortOrder
    motivoReprovacao?: SortOrderInput | SortOrder
    planoId?: SortOrder
    farmaciaId?: SortOrder
    indicadorId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plano?: PlanoAcaoOrderByWithRelationInput
    farmacia?: FarmaciaOrderByWithRelationInput
    indicador?: IndicadorOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
    comentarios?: ComentarioEvidenciaOrderByRelationAggregateInput
  }

  export type EvidenciaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvidenciaWhereInput | EvidenciaWhereInput[]
    OR?: EvidenciaWhereInput[]
    NOT?: EvidenciaWhereInput | EvidenciaWhereInput[]
    url?: StringFilter<"Evidencia"> | string
    descricao?: StringNullableFilter<"Evidencia"> | string | null
    dataCriacao?: DateTimeFilter<"Evidencia"> | Date | string
    status?: StringFilter<"Evidencia"> | string
    dataValidacao?: DateTimeNullableFilter<"Evidencia"> | Date | string | null
    validadoPorId?: StringNullableFilter<"Evidencia"> | string | null
    motivoReprovacao?: StringNullableFilter<"Evidencia"> | string | null
    planoId?: StringFilter<"Evidencia"> | string
    farmaciaId?: StringFilter<"Evidencia"> | string
    indicadorId?: StringFilter<"Evidencia"> | string
    usuarioId?: StringFilter<"Evidencia"> | string
    createdAt?: DateTimeFilter<"Evidencia"> | Date | string
    updatedAt?: DateTimeFilter<"Evidencia"> | Date | string
    plano?: XOR<PlanoAcaoRelationFilter, PlanoAcaoWhereInput>
    farmacia?: XOR<FarmaciaRelationFilter, FarmaciaWhereInput>
    indicador?: XOR<IndicadorRelationFilter, IndicadorWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    comentarios?: ComentarioEvidenciaListRelationFilter
  }, "id">

  export type EvidenciaOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    descricao?: SortOrderInput | SortOrder
    dataCriacao?: SortOrder
    status?: SortOrder
    dataValidacao?: SortOrderInput | SortOrder
    validadoPorId?: SortOrderInput | SortOrder
    motivoReprovacao?: SortOrderInput | SortOrder
    planoId?: SortOrder
    farmaciaId?: SortOrder
    indicadorId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvidenciaCountOrderByAggregateInput
    _max?: EvidenciaMaxOrderByAggregateInput
    _min?: EvidenciaMinOrderByAggregateInput
  }

  export type EvidenciaScalarWhereWithAggregatesInput = {
    AND?: EvidenciaScalarWhereWithAggregatesInput | EvidenciaScalarWhereWithAggregatesInput[]
    OR?: EvidenciaScalarWhereWithAggregatesInput[]
    NOT?: EvidenciaScalarWhereWithAggregatesInput | EvidenciaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evidencia"> | string
    url?: StringWithAggregatesFilter<"Evidencia"> | string
    descricao?: StringNullableWithAggregatesFilter<"Evidencia"> | string | null
    dataCriacao?: DateTimeWithAggregatesFilter<"Evidencia"> | Date | string
    status?: StringWithAggregatesFilter<"Evidencia"> | string
    dataValidacao?: DateTimeNullableWithAggregatesFilter<"Evidencia"> | Date | string | null
    validadoPorId?: StringNullableWithAggregatesFilter<"Evidencia"> | string | null
    motivoReprovacao?: StringNullableWithAggregatesFilter<"Evidencia"> | string | null
    planoId?: StringWithAggregatesFilter<"Evidencia"> | string
    farmaciaId?: StringWithAggregatesFilter<"Evidencia"> | string
    indicadorId?: StringWithAggregatesFilter<"Evidencia"> | string
    usuarioId?: StringWithAggregatesFilter<"Evidencia"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Evidencia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Evidencia"> | Date | string
  }

  export type ComentarioEvidenciaWhereInput = {
    AND?: ComentarioEvidenciaWhereInput | ComentarioEvidenciaWhereInput[]
    OR?: ComentarioEvidenciaWhereInput[]
    NOT?: ComentarioEvidenciaWhereInput | ComentarioEvidenciaWhereInput[]
    id?: StringFilter<"ComentarioEvidencia"> | string
    texto?: StringFilter<"ComentarioEvidencia"> | string
    data?: DateTimeFilter<"ComentarioEvidencia"> | Date | string
    evidenciaId?: StringFilter<"ComentarioEvidencia"> | string
    usuarioId?: StringFilter<"ComentarioEvidencia"> | string
    createdAt?: DateTimeFilter<"ComentarioEvidencia"> | Date | string
    updatedAt?: DateTimeFilter<"ComentarioEvidencia"> | Date | string
    evidencia?: XOR<EvidenciaRelationFilter, EvidenciaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type ComentarioEvidenciaOrderByWithRelationInput = {
    id?: SortOrder
    texto?: SortOrder
    data?: SortOrder
    evidenciaId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evidencia?: EvidenciaOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type ComentarioEvidenciaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComentarioEvidenciaWhereInput | ComentarioEvidenciaWhereInput[]
    OR?: ComentarioEvidenciaWhereInput[]
    NOT?: ComentarioEvidenciaWhereInput | ComentarioEvidenciaWhereInput[]
    texto?: StringFilter<"ComentarioEvidencia"> | string
    data?: DateTimeFilter<"ComentarioEvidencia"> | Date | string
    evidenciaId?: StringFilter<"ComentarioEvidencia"> | string
    usuarioId?: StringFilter<"ComentarioEvidencia"> | string
    createdAt?: DateTimeFilter<"ComentarioEvidencia"> | Date | string
    updatedAt?: DateTimeFilter<"ComentarioEvidencia"> | Date | string
    evidencia?: XOR<EvidenciaRelationFilter, EvidenciaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type ComentarioEvidenciaOrderByWithAggregationInput = {
    id?: SortOrder
    texto?: SortOrder
    data?: SortOrder
    evidenciaId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComentarioEvidenciaCountOrderByAggregateInput
    _max?: ComentarioEvidenciaMaxOrderByAggregateInput
    _min?: ComentarioEvidenciaMinOrderByAggregateInput
  }

  export type ComentarioEvidenciaScalarWhereWithAggregatesInput = {
    AND?: ComentarioEvidenciaScalarWhereWithAggregatesInput | ComentarioEvidenciaScalarWhereWithAggregatesInput[]
    OR?: ComentarioEvidenciaScalarWhereWithAggregatesInput[]
    NOT?: ComentarioEvidenciaScalarWhereWithAggregatesInput | ComentarioEvidenciaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComentarioEvidencia"> | string
    texto?: StringWithAggregatesFilter<"ComentarioEvidencia"> | string
    data?: DateTimeWithAggregatesFilter<"ComentarioEvidencia"> | Date | string
    evidenciaId?: StringWithAggregatesFilter<"ComentarioEvidencia"> | string
    usuarioId?: StringWithAggregatesFilter<"ComentarioEvidencia"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ComentarioEvidencia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComentarioEvidencia"> | Date | string
  }

  export type MedicamentoWhereInput = {
    AND?: MedicamentoWhereInput | MedicamentoWhereInput[]
    OR?: MedicamentoWhereInput[]
    NOT?: MedicamentoWhereInput | MedicamentoWhereInput[]
    id?: StringFilter<"Medicamento"> | string
    codigo?: StringFilter<"Medicamento"> | string
    nome?: StringFilter<"Medicamento"> | string
    tipo?: StringFilter<"Medicamento"> | string
    ultimaCompra?: DateTimeFilter<"Medicamento"> | Date | string
    proximaCompra?: DateTimeFilter<"Medicamento"> | Date | string
    duracaoDias?: IntFilter<"Medicamento"> | number
    lembreteEnviado?: BoolFilter<"Medicamento"> | boolean
    farmaciaId?: StringFilter<"Medicamento"> | string
    clienteId?: StringFilter<"Medicamento"> | string
    createdAt?: DateTimeFilter<"Medicamento"> | Date | string
    updatedAt?: DateTimeFilter<"Medicamento"> | Date | string
    farmacia?: XOR<FarmaciaRelationFilter, FarmaciaWhereInput>
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
  }

  export type MedicamentoOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    ultimaCompra?: SortOrder
    proximaCompra?: SortOrder
    duracaoDias?: SortOrder
    lembreteEnviado?: SortOrder
    farmaciaId?: SortOrder
    clienteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    farmacia?: FarmaciaOrderByWithRelationInput
    cliente?: ClienteOrderByWithRelationInput
  }

  export type MedicamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicamentoWhereInput | MedicamentoWhereInput[]
    OR?: MedicamentoWhereInput[]
    NOT?: MedicamentoWhereInput | MedicamentoWhereInput[]
    codigo?: StringFilter<"Medicamento"> | string
    nome?: StringFilter<"Medicamento"> | string
    tipo?: StringFilter<"Medicamento"> | string
    ultimaCompra?: DateTimeFilter<"Medicamento"> | Date | string
    proximaCompra?: DateTimeFilter<"Medicamento"> | Date | string
    duracaoDias?: IntFilter<"Medicamento"> | number
    lembreteEnviado?: BoolFilter<"Medicamento"> | boolean
    farmaciaId?: StringFilter<"Medicamento"> | string
    clienteId?: StringFilter<"Medicamento"> | string
    createdAt?: DateTimeFilter<"Medicamento"> | Date | string
    updatedAt?: DateTimeFilter<"Medicamento"> | Date | string
    farmacia?: XOR<FarmaciaRelationFilter, FarmaciaWhereInput>
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
  }, "id">

  export type MedicamentoOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    ultimaCompra?: SortOrder
    proximaCompra?: SortOrder
    duracaoDias?: SortOrder
    lembreteEnviado?: SortOrder
    farmaciaId?: SortOrder
    clienteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicamentoCountOrderByAggregateInput
    _avg?: MedicamentoAvgOrderByAggregateInput
    _max?: MedicamentoMaxOrderByAggregateInput
    _min?: MedicamentoMinOrderByAggregateInput
    _sum?: MedicamentoSumOrderByAggregateInput
  }

  export type MedicamentoScalarWhereWithAggregatesInput = {
    AND?: MedicamentoScalarWhereWithAggregatesInput | MedicamentoScalarWhereWithAggregatesInput[]
    OR?: MedicamentoScalarWhereWithAggregatesInput[]
    NOT?: MedicamentoScalarWhereWithAggregatesInput | MedicamentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Medicamento"> | string
    codigo?: StringWithAggregatesFilter<"Medicamento"> | string
    nome?: StringWithAggregatesFilter<"Medicamento"> | string
    tipo?: StringWithAggregatesFilter<"Medicamento"> | string
    ultimaCompra?: DateTimeWithAggregatesFilter<"Medicamento"> | Date | string
    proximaCompra?: DateTimeWithAggregatesFilter<"Medicamento"> | Date | string
    duracaoDias?: IntWithAggregatesFilter<"Medicamento"> | number
    lembreteEnviado?: BoolWithAggregatesFilter<"Medicamento"> | boolean
    farmaciaId?: StringWithAggregatesFilter<"Medicamento"> | string
    clienteId?: StringWithAggregatesFilter<"Medicamento"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Medicamento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Medicamento"> | Date | string
  }

  export type ClienteWhereInput = {
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    id?: StringFilter<"Cliente"> | string
    nome?: StringFilter<"Cliente"> | string
    telefone?: StringFilter<"Cliente"> | string
    email?: StringNullableFilter<"Cliente"> | string | null
    createdAt?: DateTimeFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeFilter<"Cliente"> | Date | string
    medicamentos?: MedicamentoListRelationFilter
  }

  export type ClienteOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicamentos?: MedicamentoOrderByRelationAggregateInput
  }

  export type ClienteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    nome?: StringFilter<"Cliente"> | string
    telefone?: StringFilter<"Cliente"> | string
    email?: StringNullableFilter<"Cliente"> | string | null
    createdAt?: DateTimeFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeFilter<"Cliente"> | Date | string
    medicamentos?: MedicamentoListRelationFilter
  }, "id">

  export type ClienteOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    OR?: ClienteScalarWhereWithAggregatesInput[]
    NOT?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cliente"> | string
    nome?: StringWithAggregatesFilter<"Cliente"> | string
    telefone?: StringWithAggregatesFilter<"Cliente"> | string
    email?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
  }

  export type UsuarioCreateInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    farmaciasUsuario?: FarmaciaUsuarioCreateNestedManyWithoutUsuarioInput
    planos?: PlanoAcaoCreateNestedManyWithoutResponsavelInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    evidencias?: EvidenciaCreateNestedManyWithoutUsuarioInput
    comentariosEvidencia?: ComentarioEvidenciaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    farmaciasUsuario?: FarmaciaUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    planos?: PlanoAcaoUncheckedCreateNestedManyWithoutResponsavelInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutUsuarioInput
    comentariosEvidencia?: ComentarioEvidenciaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmaciasUsuario?: FarmaciaUsuarioUpdateManyWithoutUsuarioNestedInput
    planos?: PlanoAcaoUpdateManyWithoutResponsavelNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    evidencias?: EvidenciaUpdateManyWithoutUsuarioNestedInput
    comentariosEvidencia?: ComentarioEvidenciaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmaciasUsuario?: FarmaciaUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    planos?: PlanoAcaoUncheckedUpdateManyWithoutResponsavelNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutUsuarioNestedInput
    comentariosEvidencia?: ComentarioEvidenciaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FarmaciaCreateInput = {
    id?: string
    nome: string
    cnpj: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    corPrincipal?: string
    corSecundaria?: string
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usuariosAssociados?: FarmaciaUsuarioCreateNestedManyWithoutFarmaciaInput
    planosAcao?: PlanoAcaoCreateNestedManyWithoutFarmaciaInput
    evidencias?: EvidenciaCreateNestedManyWithoutFarmaciaInput
    medicamentos?: MedicamentoCreateNestedManyWithoutFarmaciaInput
  }

  export type FarmaciaUncheckedCreateInput = {
    id?: string
    nome: string
    cnpj: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    corPrincipal?: string
    corSecundaria?: string
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usuariosAssociados?: FarmaciaUsuarioUncheckedCreateNestedManyWithoutFarmaciaInput
    planosAcao?: PlanoAcaoUncheckedCreateNestedManyWithoutFarmaciaInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutFarmaciaInput
    medicamentos?: MedicamentoUncheckedCreateNestedManyWithoutFarmaciaInput
  }

  export type FarmaciaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    corPrincipal?: StringFieldUpdateOperationsInput | string
    corSecundaria?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosAssociados?: FarmaciaUsuarioUpdateManyWithoutFarmaciaNestedInput
    planosAcao?: PlanoAcaoUpdateManyWithoutFarmaciaNestedInput
    evidencias?: EvidenciaUpdateManyWithoutFarmaciaNestedInput
    medicamentos?: MedicamentoUpdateManyWithoutFarmaciaNestedInput
  }

  export type FarmaciaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    corPrincipal?: StringFieldUpdateOperationsInput | string
    corSecundaria?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosAssociados?: FarmaciaUsuarioUncheckedUpdateManyWithoutFarmaciaNestedInput
    planosAcao?: PlanoAcaoUncheckedUpdateManyWithoutFarmaciaNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutFarmaciaNestedInput
    medicamentos?: MedicamentoUncheckedUpdateManyWithoutFarmaciaNestedInput
  }

  export type FarmaciaCreateManyInput = {
    id?: string
    nome: string
    cnpj: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    corPrincipal?: string
    corSecundaria?: string
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FarmaciaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    corPrincipal?: StringFieldUpdateOperationsInput | string
    corSecundaria?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FarmaciaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    corPrincipal?: StringFieldUpdateOperationsInput | string
    corSecundaria?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FarmaciaUsuarioCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    farmacia: FarmaciaCreateNestedOneWithoutUsuariosAssociadosInput
    usuario: UsuarioCreateNestedOneWithoutFarmaciasUsuarioInput
  }

  export type FarmaciaUsuarioUncheckedCreateInput = {
    id?: string
    farmaciaId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FarmaciaUsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmacia?: FarmaciaUpdateOneRequiredWithoutUsuariosAssociadosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutFarmaciasUsuarioNestedInput
  }

  export type FarmaciaUsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FarmaciaUsuarioCreateManyInput = {
    id?: string
    farmaciaId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FarmaciaUsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FarmaciaUsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicadorCreateInput = {
    id?: string
    codigo: string
    nome: string
    categoria: string
    unidade: string
    metaPadrao: string
    temImpacto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planosAcao?: PlanoAcaoCreateNestedManyWithoutIndicadorInput
    evidencias?: EvidenciaCreateNestedManyWithoutIndicadorInput
    relacionados?: IndicadorRelacionadoCreateNestedManyWithoutIndicadorOrigemInput
    relacionadoA?: IndicadorRelacionadoCreateNestedManyWithoutIndicadorDestinoInput
  }

  export type IndicadorUncheckedCreateInput = {
    id?: string
    codigo: string
    nome: string
    categoria: string
    unidade: string
    metaPadrao: string
    temImpacto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planosAcao?: PlanoAcaoUncheckedCreateNestedManyWithoutIndicadorInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutIndicadorInput
    relacionados?: IndicadorRelacionadoUncheckedCreateNestedManyWithoutIndicadorOrigemInput
    relacionadoA?: IndicadorRelacionadoUncheckedCreateNestedManyWithoutIndicadorDestinoInput
  }

  export type IndicadorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    metaPadrao?: StringFieldUpdateOperationsInput | string
    temImpacto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planosAcao?: PlanoAcaoUpdateManyWithoutIndicadorNestedInput
    evidencias?: EvidenciaUpdateManyWithoutIndicadorNestedInput
    relacionados?: IndicadorRelacionadoUpdateManyWithoutIndicadorOrigemNestedInput
    relacionadoA?: IndicadorRelacionadoUpdateManyWithoutIndicadorDestinoNestedInput
  }

  export type IndicadorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    metaPadrao?: StringFieldUpdateOperationsInput | string
    temImpacto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planosAcao?: PlanoAcaoUncheckedUpdateManyWithoutIndicadorNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutIndicadorNestedInput
    relacionados?: IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorOrigemNestedInput
    relacionadoA?: IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorDestinoNestedInput
  }

  export type IndicadorCreateManyInput = {
    id?: string
    codigo: string
    nome: string
    categoria: string
    unidade: string
    metaPadrao: string
    temImpacto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicadorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    metaPadrao?: StringFieldUpdateOperationsInput | string
    temImpacto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicadorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    metaPadrao?: StringFieldUpdateOperationsInput | string
    temImpacto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicadorRelacionadoCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    indicadorOrigem: IndicadorCreateNestedOneWithoutRelacionadosInput
    indicadorDestino: IndicadorCreateNestedOneWithoutRelacionadoAInput
  }

  export type IndicadorRelacionadoUncheckedCreateInput = {
    id?: string
    indicadorOrigemId: string
    indicadorDestinoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicadorRelacionadoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadorOrigem?: IndicadorUpdateOneRequiredWithoutRelacionadosNestedInput
    indicadorDestino?: IndicadorUpdateOneRequiredWithoutRelacionadoANestedInput
  }

  export type IndicadorRelacionadoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicadorOrigemId?: StringFieldUpdateOperationsInput | string
    indicadorDestinoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicadorRelacionadoCreateManyInput = {
    id?: string
    indicadorOrigemId: string
    indicadorDestinoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicadorRelacionadoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicadorRelacionadoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicadorOrigemId?: StringFieldUpdateOperationsInput | string
    indicadorDestinoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanoAcaoCreateInput = {
    id?: string
    titulo: string
    descricao: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    farmacia: FarmaciaCreateNestedOneWithoutPlanosAcaoInput
    indicador: IndicadorCreateNestedOneWithoutPlanosAcaoInput
    responsavel: UsuarioCreateNestedOneWithoutPlanosInput
    acoes?: AcaoCreateNestedManyWithoutPlanoAcaoInput
    comentarios?: ComentarioCreateNestedManyWithoutPlanoAcaoInput
    evidencias?: EvidenciaCreateNestedManyWithoutPlanoInput
  }

  export type PlanoAcaoUncheckedCreateInput = {
    id?: string
    titulo: string
    descricao: string
    farmaciaId: string
    indicadorId: string
    responsavelId: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    acoes?: AcaoUncheckedCreateNestedManyWithoutPlanoAcaoInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutPlanoAcaoInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutPlanoInput
  }

  export type PlanoAcaoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmacia?: FarmaciaUpdateOneRequiredWithoutPlanosAcaoNestedInput
    indicador?: IndicadorUpdateOneRequiredWithoutPlanosAcaoNestedInput
    responsavel?: UsuarioUpdateOneRequiredWithoutPlanosNestedInput
    acoes?: AcaoUpdateManyWithoutPlanoAcaoNestedInput
    comentarios?: ComentarioUpdateManyWithoutPlanoAcaoNestedInput
    evidencias?: EvidenciaUpdateManyWithoutPlanoNestedInput
  }

  export type PlanoAcaoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    responsavelId?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acoes?: AcaoUncheckedUpdateManyWithoutPlanoAcaoNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutPlanoAcaoNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutPlanoNestedInput
  }

  export type PlanoAcaoCreateManyInput = {
    id?: string
    titulo: string
    descricao: string
    farmaciaId: string
    indicadorId: string
    responsavelId: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanoAcaoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanoAcaoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    responsavelId?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcaoCreateInput = {
    id?: string
    descricao: string
    prazo: Date | string
    concluida?: boolean
    atrasada?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planoAcao: PlanoAcaoCreateNestedOneWithoutAcoesInput
  }

  export type AcaoUncheckedCreateInput = {
    id?: string
    descricao: string
    prazo: Date | string
    concluida?: boolean
    atrasada?: boolean
    planoAcaoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcaoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    concluida?: BoolFieldUpdateOperationsInput | boolean
    atrasada?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planoAcao?: PlanoAcaoUpdateOneRequiredWithoutAcoesNestedInput
  }

  export type AcaoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    concluida?: BoolFieldUpdateOperationsInput | boolean
    atrasada?: BoolFieldUpdateOperationsInput | boolean
    planoAcaoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcaoCreateManyInput = {
    id?: string
    descricao: string
    prazo: Date | string
    concluida?: boolean
    atrasada?: boolean
    planoAcaoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcaoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    concluida?: BoolFieldUpdateOperationsInput | boolean
    atrasada?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcaoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    concluida?: BoolFieldUpdateOperationsInput | boolean
    atrasada?: BoolFieldUpdateOperationsInput | boolean
    planoAcaoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioCreateInput = {
    id?: string
    texto: string
    data?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    planoAcao: PlanoAcaoCreateNestedOneWithoutComentariosInput
    usuario: UsuarioCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioUncheckedCreateInput = {
    id?: string
    texto: string
    data?: Date | string
    planoAcaoId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planoAcao?: PlanoAcaoUpdateOneRequiredWithoutComentariosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    planoAcaoId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioCreateManyInput = {
    id?: string
    texto: string
    data?: Date | string
    planoAcaoId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    planoAcaoId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenciaCreateInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plano: PlanoAcaoCreateNestedOneWithoutEvidenciasInput
    farmacia: FarmaciaCreateNestedOneWithoutEvidenciasInput
    indicador: IndicadorCreateNestedOneWithoutEvidenciasInput
    usuario: UsuarioCreateNestedOneWithoutEvidenciasInput
    comentarios?: ComentarioEvidenciaCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaUncheckedCreateInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    planoId: string
    farmaciaId: string
    indicadorId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comentarios?: ComentarioEvidenciaUncheckedCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plano?: PlanoAcaoUpdateOneRequiredWithoutEvidenciasNestedInput
    farmacia?: FarmaciaUpdateOneRequiredWithoutEvidenciasNestedInput
    indicador?: IndicadorUpdateOneRequiredWithoutEvidenciasNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutEvidenciasNestedInput
    comentarios?: ComentarioEvidenciaUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    planoId?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comentarios?: ComentarioEvidenciaUncheckedUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaCreateManyInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    planoId: string
    farmaciaId: string
    indicadorId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenciaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenciaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    planoId?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioEvidenciaCreateInput = {
    id?: string
    texto: string
    data?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    evidencia: EvidenciaCreateNestedOneWithoutComentariosInput
    usuario: UsuarioCreateNestedOneWithoutComentariosEvidenciaInput
  }

  export type ComentarioEvidenciaUncheckedCreateInput = {
    id?: string
    texto: string
    data?: Date | string
    evidenciaId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentarioEvidenciaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidencia?: EvidenciaUpdateOneRequiredWithoutComentariosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutComentariosEvidenciaNestedInput
  }

  export type ComentarioEvidenciaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    evidenciaId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioEvidenciaCreateManyInput = {
    id?: string
    texto: string
    data?: Date | string
    evidenciaId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentarioEvidenciaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioEvidenciaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    evidenciaId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentoCreateInput = {
    id?: string
    codigo: string
    nome: string
    tipo: string
    ultimaCompra: Date | string
    proximaCompra: Date | string
    duracaoDias: number
    lembreteEnviado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    farmacia: FarmaciaCreateNestedOneWithoutMedicamentosInput
    cliente: ClienteCreateNestedOneWithoutMedicamentosInput
  }

  export type MedicamentoUncheckedCreateInput = {
    id?: string
    codigo: string
    nome: string
    tipo: string
    ultimaCompra: Date | string
    proximaCompra: Date | string
    duracaoDias: number
    lembreteEnviado?: boolean
    farmaciaId: string
    clienteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicamentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ultimaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    proximaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    duracaoDias?: IntFieldUpdateOperationsInput | number
    lembreteEnviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmacia?: FarmaciaUpdateOneRequiredWithoutMedicamentosNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutMedicamentosNestedInput
  }

  export type MedicamentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ultimaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    proximaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    duracaoDias?: IntFieldUpdateOperationsInput | number
    lembreteEnviado?: BoolFieldUpdateOperationsInput | boolean
    farmaciaId?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentoCreateManyInput = {
    id?: string
    codigo: string
    nome: string
    tipo: string
    ultimaCompra: Date | string
    proximaCompra: Date | string
    duracaoDias: number
    lembreteEnviado?: boolean
    farmaciaId: string
    clienteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicamentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ultimaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    proximaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    duracaoDias?: IntFieldUpdateOperationsInput | number
    lembreteEnviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ultimaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    proximaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    duracaoDias?: IntFieldUpdateOperationsInput | number
    lembreteEnviado?: BoolFieldUpdateOperationsInput | boolean
    farmaciaId?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteCreateInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicamentos?: MedicamentoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicamentos?: MedicamentoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicamentos?: MedicamentoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicamentos?: MedicamentoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateManyInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClienteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FarmaciaUsuarioListRelationFilter = {
    every?: FarmaciaUsuarioWhereInput
    some?: FarmaciaUsuarioWhereInput
    none?: FarmaciaUsuarioWhereInput
  }

  export type PlanoAcaoListRelationFilter = {
    every?: PlanoAcaoWhereInput
    some?: PlanoAcaoWhereInput
    none?: PlanoAcaoWhereInput
  }

  export type ComentarioListRelationFilter = {
    every?: ComentarioWhereInput
    some?: ComentarioWhereInput
    none?: ComentarioWhereInput
  }

  export type EvidenciaListRelationFilter = {
    every?: EvidenciaWhereInput
    some?: EvidenciaWhereInput
    none?: EvidenciaWhereInput
  }

  export type ComentarioEvidenciaListRelationFilter = {
    every?: ComentarioEvidenciaWhereInput
    some?: ComentarioEvidenciaWhereInput
    none?: ComentarioEvidenciaWhereInput
  }

  export type FarmaciaUsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanoAcaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComentarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvidenciaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComentarioEvidenciaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type MedicamentoListRelationFilter = {
    every?: MedicamentoWhereInput
    some?: MedicamentoWhereInput
    none?: MedicamentoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MedicamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FarmaciaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    corPrincipal?: SortOrder
    corSecundaria?: SortOrder
    logo?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FarmaciaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    corPrincipal?: SortOrder
    corSecundaria?: SortOrder
    logo?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FarmaciaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    corPrincipal?: SortOrder
    corSecundaria?: SortOrder
    logo?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FarmaciaRelationFilter = {
    is?: FarmaciaWhereInput
    isNot?: FarmaciaWhereInput
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type FarmaciaUsuarioFarmaciaIdUsuarioIdCompoundUniqueInput = {
    farmaciaId: string
    usuarioId: string
  }

  export type FarmaciaUsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    farmaciaId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FarmaciaUsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    farmaciaId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FarmaciaUsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    farmaciaId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicadorRelacionadoListRelationFilter = {
    every?: IndicadorRelacionadoWhereInput
    some?: IndicadorRelacionadoWhereInput
    none?: IndicadorRelacionadoWhereInput
  }

  export type IndicadorRelacionadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IndicadorCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
    unidade?: SortOrder
    metaPadrao?: SortOrder
    temImpacto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicadorMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
    unidade?: SortOrder
    metaPadrao?: SortOrder
    temImpacto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicadorMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
    unidade?: SortOrder
    metaPadrao?: SortOrder
    temImpacto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicadorRelationFilter = {
    is?: IndicadorWhereInput
    isNot?: IndicadorWhereInput
  }

  export type IndicadorRelacionadoIndicadorOrigemIdIndicadorDestinoIdCompoundUniqueInput = {
    indicadorOrigemId: string
    indicadorDestinoId: string
  }

  export type IndicadorRelacionadoCountOrderByAggregateInput = {
    id?: SortOrder
    indicadorOrigemId?: SortOrder
    indicadorDestinoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicadorRelacionadoMaxOrderByAggregateInput = {
    id?: SortOrder
    indicadorOrigemId?: SortOrder
    indicadorDestinoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicadorRelacionadoMinOrderByAggregateInput = {
    id?: SortOrder
    indicadorOrigemId?: SortOrder
    indicadorDestinoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AcaoListRelationFilter = {
    every?: AcaoWhereInput
    some?: AcaoWhereInput
    none?: AcaoWhereInput
  }

  export type AcaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanoAcaoCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    farmaciaId?: SortOrder
    indicadorId?: SortOrder
    responsavelId?: SortOrder
    dataCriacao?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    percentualConcluido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanoAcaoAvgOrderByAggregateInput = {
    percentualConcluido?: SortOrder
  }

  export type PlanoAcaoMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    farmaciaId?: SortOrder
    indicadorId?: SortOrder
    responsavelId?: SortOrder
    dataCriacao?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    percentualConcluido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanoAcaoMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    farmaciaId?: SortOrder
    indicadorId?: SortOrder
    responsavelId?: SortOrder
    dataCriacao?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    percentualConcluido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanoAcaoSumOrderByAggregateInput = {
    percentualConcluido?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PlanoAcaoRelationFilter = {
    is?: PlanoAcaoWhereInput
    isNot?: PlanoAcaoWhereInput
  }

  export type AcaoCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    prazo?: SortOrder
    concluida?: SortOrder
    atrasada?: SortOrder
    planoAcaoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcaoMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    prazo?: SortOrder
    concluida?: SortOrder
    atrasada?: SortOrder
    planoAcaoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcaoMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    prazo?: SortOrder
    concluida?: SortOrder
    atrasada?: SortOrder
    planoAcaoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComentarioCountOrderByAggregateInput = {
    id?: SortOrder
    texto?: SortOrder
    data?: SortOrder
    planoAcaoId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComentarioMaxOrderByAggregateInput = {
    id?: SortOrder
    texto?: SortOrder
    data?: SortOrder
    planoAcaoId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComentarioMinOrderByAggregateInput = {
    id?: SortOrder
    texto?: SortOrder
    data?: SortOrder
    planoAcaoId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EvidenciaCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    descricao?: SortOrder
    dataCriacao?: SortOrder
    status?: SortOrder
    dataValidacao?: SortOrder
    validadoPorId?: SortOrder
    motivoReprovacao?: SortOrder
    planoId?: SortOrder
    farmaciaId?: SortOrder
    indicadorId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvidenciaMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    descricao?: SortOrder
    dataCriacao?: SortOrder
    status?: SortOrder
    dataValidacao?: SortOrder
    validadoPorId?: SortOrder
    motivoReprovacao?: SortOrder
    planoId?: SortOrder
    farmaciaId?: SortOrder
    indicadorId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvidenciaMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    descricao?: SortOrder
    dataCriacao?: SortOrder
    status?: SortOrder
    dataValidacao?: SortOrder
    validadoPorId?: SortOrder
    motivoReprovacao?: SortOrder
    planoId?: SortOrder
    farmaciaId?: SortOrder
    indicadorId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EvidenciaRelationFilter = {
    is?: EvidenciaWhereInput
    isNot?: EvidenciaWhereInput
  }

  export type ComentarioEvidenciaCountOrderByAggregateInput = {
    id?: SortOrder
    texto?: SortOrder
    data?: SortOrder
    evidenciaId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComentarioEvidenciaMaxOrderByAggregateInput = {
    id?: SortOrder
    texto?: SortOrder
    data?: SortOrder
    evidenciaId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComentarioEvidenciaMinOrderByAggregateInput = {
    id?: SortOrder
    texto?: SortOrder
    data?: SortOrder
    evidenciaId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClienteRelationFilter = {
    is?: ClienteWhereInput
    isNot?: ClienteWhereInput
  }

  export type MedicamentoCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    ultimaCompra?: SortOrder
    proximaCompra?: SortOrder
    duracaoDias?: SortOrder
    lembreteEnviado?: SortOrder
    farmaciaId?: SortOrder
    clienteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicamentoAvgOrderByAggregateInput = {
    duracaoDias?: SortOrder
  }

  export type MedicamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    ultimaCompra?: SortOrder
    proximaCompra?: SortOrder
    duracaoDias?: SortOrder
    lembreteEnviado?: SortOrder
    farmaciaId?: SortOrder
    clienteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicamentoMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    ultimaCompra?: SortOrder
    proximaCompra?: SortOrder
    duracaoDias?: SortOrder
    lembreteEnviado?: SortOrder
    farmaciaId?: SortOrder
    clienteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicamentoSumOrderByAggregateInput = {
    duracaoDias?: SortOrder
  }

  export type ClienteCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FarmaciaUsuarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<FarmaciaUsuarioCreateWithoutUsuarioInput, FarmaciaUsuarioUncheckedCreateWithoutUsuarioInput> | FarmaciaUsuarioCreateWithoutUsuarioInput[] | FarmaciaUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: FarmaciaUsuarioCreateOrConnectWithoutUsuarioInput | FarmaciaUsuarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: FarmaciaUsuarioCreateManyUsuarioInputEnvelope
    connect?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
  }

  export type PlanoAcaoCreateNestedManyWithoutResponsavelInput = {
    create?: XOR<PlanoAcaoCreateWithoutResponsavelInput, PlanoAcaoUncheckedCreateWithoutResponsavelInput> | PlanoAcaoCreateWithoutResponsavelInput[] | PlanoAcaoUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutResponsavelInput | PlanoAcaoCreateOrConnectWithoutResponsavelInput[]
    createMany?: PlanoAcaoCreateManyResponsavelInputEnvelope
    connect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
  }

  export type ComentarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type EvidenciaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EvidenciaCreateWithoutUsuarioInput, EvidenciaUncheckedCreateWithoutUsuarioInput> | EvidenciaCreateWithoutUsuarioInput[] | EvidenciaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutUsuarioInput | EvidenciaCreateOrConnectWithoutUsuarioInput[]
    createMany?: EvidenciaCreateManyUsuarioInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type ComentarioEvidenciaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComentarioEvidenciaCreateWithoutUsuarioInput, ComentarioEvidenciaUncheckedCreateWithoutUsuarioInput> | ComentarioEvidenciaCreateWithoutUsuarioInput[] | ComentarioEvidenciaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioEvidenciaCreateOrConnectWithoutUsuarioInput | ComentarioEvidenciaCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComentarioEvidenciaCreateManyUsuarioInputEnvelope
    connect?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
  }

  export type FarmaciaUsuarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<FarmaciaUsuarioCreateWithoutUsuarioInput, FarmaciaUsuarioUncheckedCreateWithoutUsuarioInput> | FarmaciaUsuarioCreateWithoutUsuarioInput[] | FarmaciaUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: FarmaciaUsuarioCreateOrConnectWithoutUsuarioInput | FarmaciaUsuarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: FarmaciaUsuarioCreateManyUsuarioInputEnvelope
    connect?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
  }

  export type PlanoAcaoUncheckedCreateNestedManyWithoutResponsavelInput = {
    create?: XOR<PlanoAcaoCreateWithoutResponsavelInput, PlanoAcaoUncheckedCreateWithoutResponsavelInput> | PlanoAcaoCreateWithoutResponsavelInput[] | PlanoAcaoUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutResponsavelInput | PlanoAcaoCreateOrConnectWithoutResponsavelInput[]
    createMany?: PlanoAcaoCreateManyResponsavelInputEnvelope
    connect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
  }

  export type ComentarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type EvidenciaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EvidenciaCreateWithoutUsuarioInput, EvidenciaUncheckedCreateWithoutUsuarioInput> | EvidenciaCreateWithoutUsuarioInput[] | EvidenciaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutUsuarioInput | EvidenciaCreateOrConnectWithoutUsuarioInput[]
    createMany?: EvidenciaCreateManyUsuarioInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type ComentarioEvidenciaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComentarioEvidenciaCreateWithoutUsuarioInput, ComentarioEvidenciaUncheckedCreateWithoutUsuarioInput> | ComentarioEvidenciaCreateWithoutUsuarioInput[] | ComentarioEvidenciaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioEvidenciaCreateOrConnectWithoutUsuarioInput | ComentarioEvidenciaCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComentarioEvidenciaCreateManyUsuarioInputEnvelope
    connect?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FarmaciaUsuarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<FarmaciaUsuarioCreateWithoutUsuarioInput, FarmaciaUsuarioUncheckedCreateWithoutUsuarioInput> | FarmaciaUsuarioCreateWithoutUsuarioInput[] | FarmaciaUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: FarmaciaUsuarioCreateOrConnectWithoutUsuarioInput | FarmaciaUsuarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: FarmaciaUsuarioUpsertWithWhereUniqueWithoutUsuarioInput | FarmaciaUsuarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: FarmaciaUsuarioCreateManyUsuarioInputEnvelope
    set?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    disconnect?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    delete?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    connect?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    update?: FarmaciaUsuarioUpdateWithWhereUniqueWithoutUsuarioInput | FarmaciaUsuarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: FarmaciaUsuarioUpdateManyWithWhereWithoutUsuarioInput | FarmaciaUsuarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: FarmaciaUsuarioScalarWhereInput | FarmaciaUsuarioScalarWhereInput[]
  }

  export type PlanoAcaoUpdateManyWithoutResponsavelNestedInput = {
    create?: XOR<PlanoAcaoCreateWithoutResponsavelInput, PlanoAcaoUncheckedCreateWithoutResponsavelInput> | PlanoAcaoCreateWithoutResponsavelInput[] | PlanoAcaoUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutResponsavelInput | PlanoAcaoCreateOrConnectWithoutResponsavelInput[]
    upsert?: PlanoAcaoUpsertWithWhereUniqueWithoutResponsavelInput | PlanoAcaoUpsertWithWhereUniqueWithoutResponsavelInput[]
    createMany?: PlanoAcaoCreateManyResponsavelInputEnvelope
    set?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    disconnect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    delete?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    connect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    update?: PlanoAcaoUpdateWithWhereUniqueWithoutResponsavelInput | PlanoAcaoUpdateWithWhereUniqueWithoutResponsavelInput[]
    updateMany?: PlanoAcaoUpdateManyWithWhereWithoutResponsavelInput | PlanoAcaoUpdateManyWithWhereWithoutResponsavelInput[]
    deleteMany?: PlanoAcaoScalarWhereInput | PlanoAcaoScalarWhereInput[]
  }

  export type ComentarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutUsuarioInput | ComentarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutUsuarioInput | ComentarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutUsuarioInput | ComentarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type EvidenciaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EvidenciaCreateWithoutUsuarioInput, EvidenciaUncheckedCreateWithoutUsuarioInput> | EvidenciaCreateWithoutUsuarioInput[] | EvidenciaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutUsuarioInput | EvidenciaCreateOrConnectWithoutUsuarioInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutUsuarioInput | EvidenciaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EvidenciaCreateManyUsuarioInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutUsuarioInput | EvidenciaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutUsuarioInput | EvidenciaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type ComentarioEvidenciaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComentarioEvidenciaCreateWithoutUsuarioInput, ComentarioEvidenciaUncheckedCreateWithoutUsuarioInput> | ComentarioEvidenciaCreateWithoutUsuarioInput[] | ComentarioEvidenciaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioEvidenciaCreateOrConnectWithoutUsuarioInput | ComentarioEvidenciaCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComentarioEvidenciaUpsertWithWhereUniqueWithoutUsuarioInput | ComentarioEvidenciaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComentarioEvidenciaCreateManyUsuarioInputEnvelope
    set?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    disconnect?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    delete?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    connect?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    update?: ComentarioEvidenciaUpdateWithWhereUniqueWithoutUsuarioInput | ComentarioEvidenciaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComentarioEvidenciaUpdateManyWithWhereWithoutUsuarioInput | ComentarioEvidenciaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComentarioEvidenciaScalarWhereInput | ComentarioEvidenciaScalarWhereInput[]
  }

  export type FarmaciaUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<FarmaciaUsuarioCreateWithoutUsuarioInput, FarmaciaUsuarioUncheckedCreateWithoutUsuarioInput> | FarmaciaUsuarioCreateWithoutUsuarioInput[] | FarmaciaUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: FarmaciaUsuarioCreateOrConnectWithoutUsuarioInput | FarmaciaUsuarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: FarmaciaUsuarioUpsertWithWhereUniqueWithoutUsuarioInput | FarmaciaUsuarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: FarmaciaUsuarioCreateManyUsuarioInputEnvelope
    set?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    disconnect?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    delete?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    connect?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    update?: FarmaciaUsuarioUpdateWithWhereUniqueWithoutUsuarioInput | FarmaciaUsuarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: FarmaciaUsuarioUpdateManyWithWhereWithoutUsuarioInput | FarmaciaUsuarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: FarmaciaUsuarioScalarWhereInput | FarmaciaUsuarioScalarWhereInput[]
  }

  export type PlanoAcaoUncheckedUpdateManyWithoutResponsavelNestedInput = {
    create?: XOR<PlanoAcaoCreateWithoutResponsavelInput, PlanoAcaoUncheckedCreateWithoutResponsavelInput> | PlanoAcaoCreateWithoutResponsavelInput[] | PlanoAcaoUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutResponsavelInput | PlanoAcaoCreateOrConnectWithoutResponsavelInput[]
    upsert?: PlanoAcaoUpsertWithWhereUniqueWithoutResponsavelInput | PlanoAcaoUpsertWithWhereUniqueWithoutResponsavelInput[]
    createMany?: PlanoAcaoCreateManyResponsavelInputEnvelope
    set?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    disconnect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    delete?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    connect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    update?: PlanoAcaoUpdateWithWhereUniqueWithoutResponsavelInput | PlanoAcaoUpdateWithWhereUniqueWithoutResponsavelInput[]
    updateMany?: PlanoAcaoUpdateManyWithWhereWithoutResponsavelInput | PlanoAcaoUpdateManyWithWhereWithoutResponsavelInput[]
    deleteMany?: PlanoAcaoScalarWhereInput | PlanoAcaoScalarWhereInput[]
  }

  export type ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutUsuarioInput | ComentarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutUsuarioInput | ComentarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutUsuarioInput | ComentarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type EvidenciaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EvidenciaCreateWithoutUsuarioInput, EvidenciaUncheckedCreateWithoutUsuarioInput> | EvidenciaCreateWithoutUsuarioInput[] | EvidenciaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutUsuarioInput | EvidenciaCreateOrConnectWithoutUsuarioInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutUsuarioInput | EvidenciaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EvidenciaCreateManyUsuarioInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutUsuarioInput | EvidenciaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutUsuarioInput | EvidenciaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type ComentarioEvidenciaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComentarioEvidenciaCreateWithoutUsuarioInput, ComentarioEvidenciaUncheckedCreateWithoutUsuarioInput> | ComentarioEvidenciaCreateWithoutUsuarioInput[] | ComentarioEvidenciaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioEvidenciaCreateOrConnectWithoutUsuarioInput | ComentarioEvidenciaCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComentarioEvidenciaUpsertWithWhereUniqueWithoutUsuarioInput | ComentarioEvidenciaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComentarioEvidenciaCreateManyUsuarioInputEnvelope
    set?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    disconnect?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    delete?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    connect?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    update?: ComentarioEvidenciaUpdateWithWhereUniqueWithoutUsuarioInput | ComentarioEvidenciaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComentarioEvidenciaUpdateManyWithWhereWithoutUsuarioInput | ComentarioEvidenciaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComentarioEvidenciaScalarWhereInput | ComentarioEvidenciaScalarWhereInput[]
  }

  export type FarmaciaUsuarioCreateNestedManyWithoutFarmaciaInput = {
    create?: XOR<FarmaciaUsuarioCreateWithoutFarmaciaInput, FarmaciaUsuarioUncheckedCreateWithoutFarmaciaInput> | FarmaciaUsuarioCreateWithoutFarmaciaInput[] | FarmaciaUsuarioUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: FarmaciaUsuarioCreateOrConnectWithoutFarmaciaInput | FarmaciaUsuarioCreateOrConnectWithoutFarmaciaInput[]
    createMany?: FarmaciaUsuarioCreateManyFarmaciaInputEnvelope
    connect?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
  }

  export type PlanoAcaoCreateNestedManyWithoutFarmaciaInput = {
    create?: XOR<PlanoAcaoCreateWithoutFarmaciaInput, PlanoAcaoUncheckedCreateWithoutFarmaciaInput> | PlanoAcaoCreateWithoutFarmaciaInput[] | PlanoAcaoUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutFarmaciaInput | PlanoAcaoCreateOrConnectWithoutFarmaciaInput[]
    createMany?: PlanoAcaoCreateManyFarmaciaInputEnvelope
    connect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
  }

  export type EvidenciaCreateNestedManyWithoutFarmaciaInput = {
    create?: XOR<EvidenciaCreateWithoutFarmaciaInput, EvidenciaUncheckedCreateWithoutFarmaciaInput> | EvidenciaCreateWithoutFarmaciaInput[] | EvidenciaUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutFarmaciaInput | EvidenciaCreateOrConnectWithoutFarmaciaInput[]
    createMany?: EvidenciaCreateManyFarmaciaInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type MedicamentoCreateNestedManyWithoutFarmaciaInput = {
    create?: XOR<MedicamentoCreateWithoutFarmaciaInput, MedicamentoUncheckedCreateWithoutFarmaciaInput> | MedicamentoCreateWithoutFarmaciaInput[] | MedicamentoUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: MedicamentoCreateOrConnectWithoutFarmaciaInput | MedicamentoCreateOrConnectWithoutFarmaciaInput[]
    createMany?: MedicamentoCreateManyFarmaciaInputEnvelope
    connect?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
  }

  export type FarmaciaUsuarioUncheckedCreateNestedManyWithoutFarmaciaInput = {
    create?: XOR<FarmaciaUsuarioCreateWithoutFarmaciaInput, FarmaciaUsuarioUncheckedCreateWithoutFarmaciaInput> | FarmaciaUsuarioCreateWithoutFarmaciaInput[] | FarmaciaUsuarioUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: FarmaciaUsuarioCreateOrConnectWithoutFarmaciaInput | FarmaciaUsuarioCreateOrConnectWithoutFarmaciaInput[]
    createMany?: FarmaciaUsuarioCreateManyFarmaciaInputEnvelope
    connect?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
  }

  export type PlanoAcaoUncheckedCreateNestedManyWithoutFarmaciaInput = {
    create?: XOR<PlanoAcaoCreateWithoutFarmaciaInput, PlanoAcaoUncheckedCreateWithoutFarmaciaInput> | PlanoAcaoCreateWithoutFarmaciaInput[] | PlanoAcaoUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutFarmaciaInput | PlanoAcaoCreateOrConnectWithoutFarmaciaInput[]
    createMany?: PlanoAcaoCreateManyFarmaciaInputEnvelope
    connect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
  }

  export type EvidenciaUncheckedCreateNestedManyWithoutFarmaciaInput = {
    create?: XOR<EvidenciaCreateWithoutFarmaciaInput, EvidenciaUncheckedCreateWithoutFarmaciaInput> | EvidenciaCreateWithoutFarmaciaInput[] | EvidenciaUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutFarmaciaInput | EvidenciaCreateOrConnectWithoutFarmaciaInput[]
    createMany?: EvidenciaCreateManyFarmaciaInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type MedicamentoUncheckedCreateNestedManyWithoutFarmaciaInput = {
    create?: XOR<MedicamentoCreateWithoutFarmaciaInput, MedicamentoUncheckedCreateWithoutFarmaciaInput> | MedicamentoCreateWithoutFarmaciaInput[] | MedicamentoUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: MedicamentoCreateOrConnectWithoutFarmaciaInput | MedicamentoCreateOrConnectWithoutFarmaciaInput[]
    createMany?: MedicamentoCreateManyFarmaciaInputEnvelope
    connect?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FarmaciaUsuarioUpdateManyWithoutFarmaciaNestedInput = {
    create?: XOR<FarmaciaUsuarioCreateWithoutFarmaciaInput, FarmaciaUsuarioUncheckedCreateWithoutFarmaciaInput> | FarmaciaUsuarioCreateWithoutFarmaciaInput[] | FarmaciaUsuarioUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: FarmaciaUsuarioCreateOrConnectWithoutFarmaciaInput | FarmaciaUsuarioCreateOrConnectWithoutFarmaciaInput[]
    upsert?: FarmaciaUsuarioUpsertWithWhereUniqueWithoutFarmaciaInput | FarmaciaUsuarioUpsertWithWhereUniqueWithoutFarmaciaInput[]
    createMany?: FarmaciaUsuarioCreateManyFarmaciaInputEnvelope
    set?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    disconnect?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    delete?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    connect?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    update?: FarmaciaUsuarioUpdateWithWhereUniqueWithoutFarmaciaInput | FarmaciaUsuarioUpdateWithWhereUniqueWithoutFarmaciaInput[]
    updateMany?: FarmaciaUsuarioUpdateManyWithWhereWithoutFarmaciaInput | FarmaciaUsuarioUpdateManyWithWhereWithoutFarmaciaInput[]
    deleteMany?: FarmaciaUsuarioScalarWhereInput | FarmaciaUsuarioScalarWhereInput[]
  }

  export type PlanoAcaoUpdateManyWithoutFarmaciaNestedInput = {
    create?: XOR<PlanoAcaoCreateWithoutFarmaciaInput, PlanoAcaoUncheckedCreateWithoutFarmaciaInput> | PlanoAcaoCreateWithoutFarmaciaInput[] | PlanoAcaoUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutFarmaciaInput | PlanoAcaoCreateOrConnectWithoutFarmaciaInput[]
    upsert?: PlanoAcaoUpsertWithWhereUniqueWithoutFarmaciaInput | PlanoAcaoUpsertWithWhereUniqueWithoutFarmaciaInput[]
    createMany?: PlanoAcaoCreateManyFarmaciaInputEnvelope
    set?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    disconnect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    delete?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    connect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    update?: PlanoAcaoUpdateWithWhereUniqueWithoutFarmaciaInput | PlanoAcaoUpdateWithWhereUniqueWithoutFarmaciaInput[]
    updateMany?: PlanoAcaoUpdateManyWithWhereWithoutFarmaciaInput | PlanoAcaoUpdateManyWithWhereWithoutFarmaciaInput[]
    deleteMany?: PlanoAcaoScalarWhereInput | PlanoAcaoScalarWhereInput[]
  }

  export type EvidenciaUpdateManyWithoutFarmaciaNestedInput = {
    create?: XOR<EvidenciaCreateWithoutFarmaciaInput, EvidenciaUncheckedCreateWithoutFarmaciaInput> | EvidenciaCreateWithoutFarmaciaInput[] | EvidenciaUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutFarmaciaInput | EvidenciaCreateOrConnectWithoutFarmaciaInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutFarmaciaInput | EvidenciaUpsertWithWhereUniqueWithoutFarmaciaInput[]
    createMany?: EvidenciaCreateManyFarmaciaInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutFarmaciaInput | EvidenciaUpdateWithWhereUniqueWithoutFarmaciaInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutFarmaciaInput | EvidenciaUpdateManyWithWhereWithoutFarmaciaInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type MedicamentoUpdateManyWithoutFarmaciaNestedInput = {
    create?: XOR<MedicamentoCreateWithoutFarmaciaInput, MedicamentoUncheckedCreateWithoutFarmaciaInput> | MedicamentoCreateWithoutFarmaciaInput[] | MedicamentoUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: MedicamentoCreateOrConnectWithoutFarmaciaInput | MedicamentoCreateOrConnectWithoutFarmaciaInput[]
    upsert?: MedicamentoUpsertWithWhereUniqueWithoutFarmaciaInput | MedicamentoUpsertWithWhereUniqueWithoutFarmaciaInput[]
    createMany?: MedicamentoCreateManyFarmaciaInputEnvelope
    set?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    disconnect?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    delete?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    connect?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    update?: MedicamentoUpdateWithWhereUniqueWithoutFarmaciaInput | MedicamentoUpdateWithWhereUniqueWithoutFarmaciaInput[]
    updateMany?: MedicamentoUpdateManyWithWhereWithoutFarmaciaInput | MedicamentoUpdateManyWithWhereWithoutFarmaciaInput[]
    deleteMany?: MedicamentoScalarWhereInput | MedicamentoScalarWhereInput[]
  }

  export type FarmaciaUsuarioUncheckedUpdateManyWithoutFarmaciaNestedInput = {
    create?: XOR<FarmaciaUsuarioCreateWithoutFarmaciaInput, FarmaciaUsuarioUncheckedCreateWithoutFarmaciaInput> | FarmaciaUsuarioCreateWithoutFarmaciaInput[] | FarmaciaUsuarioUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: FarmaciaUsuarioCreateOrConnectWithoutFarmaciaInput | FarmaciaUsuarioCreateOrConnectWithoutFarmaciaInput[]
    upsert?: FarmaciaUsuarioUpsertWithWhereUniqueWithoutFarmaciaInput | FarmaciaUsuarioUpsertWithWhereUniqueWithoutFarmaciaInput[]
    createMany?: FarmaciaUsuarioCreateManyFarmaciaInputEnvelope
    set?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    disconnect?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    delete?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    connect?: FarmaciaUsuarioWhereUniqueInput | FarmaciaUsuarioWhereUniqueInput[]
    update?: FarmaciaUsuarioUpdateWithWhereUniqueWithoutFarmaciaInput | FarmaciaUsuarioUpdateWithWhereUniqueWithoutFarmaciaInput[]
    updateMany?: FarmaciaUsuarioUpdateManyWithWhereWithoutFarmaciaInput | FarmaciaUsuarioUpdateManyWithWhereWithoutFarmaciaInput[]
    deleteMany?: FarmaciaUsuarioScalarWhereInput | FarmaciaUsuarioScalarWhereInput[]
  }

  export type PlanoAcaoUncheckedUpdateManyWithoutFarmaciaNestedInput = {
    create?: XOR<PlanoAcaoCreateWithoutFarmaciaInput, PlanoAcaoUncheckedCreateWithoutFarmaciaInput> | PlanoAcaoCreateWithoutFarmaciaInput[] | PlanoAcaoUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutFarmaciaInput | PlanoAcaoCreateOrConnectWithoutFarmaciaInput[]
    upsert?: PlanoAcaoUpsertWithWhereUniqueWithoutFarmaciaInput | PlanoAcaoUpsertWithWhereUniqueWithoutFarmaciaInput[]
    createMany?: PlanoAcaoCreateManyFarmaciaInputEnvelope
    set?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    disconnect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    delete?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    connect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    update?: PlanoAcaoUpdateWithWhereUniqueWithoutFarmaciaInput | PlanoAcaoUpdateWithWhereUniqueWithoutFarmaciaInput[]
    updateMany?: PlanoAcaoUpdateManyWithWhereWithoutFarmaciaInput | PlanoAcaoUpdateManyWithWhereWithoutFarmaciaInput[]
    deleteMany?: PlanoAcaoScalarWhereInput | PlanoAcaoScalarWhereInput[]
  }

  export type EvidenciaUncheckedUpdateManyWithoutFarmaciaNestedInput = {
    create?: XOR<EvidenciaCreateWithoutFarmaciaInput, EvidenciaUncheckedCreateWithoutFarmaciaInput> | EvidenciaCreateWithoutFarmaciaInput[] | EvidenciaUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutFarmaciaInput | EvidenciaCreateOrConnectWithoutFarmaciaInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutFarmaciaInput | EvidenciaUpsertWithWhereUniqueWithoutFarmaciaInput[]
    createMany?: EvidenciaCreateManyFarmaciaInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutFarmaciaInput | EvidenciaUpdateWithWhereUniqueWithoutFarmaciaInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutFarmaciaInput | EvidenciaUpdateManyWithWhereWithoutFarmaciaInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type MedicamentoUncheckedUpdateManyWithoutFarmaciaNestedInput = {
    create?: XOR<MedicamentoCreateWithoutFarmaciaInput, MedicamentoUncheckedCreateWithoutFarmaciaInput> | MedicamentoCreateWithoutFarmaciaInput[] | MedicamentoUncheckedCreateWithoutFarmaciaInput[]
    connectOrCreate?: MedicamentoCreateOrConnectWithoutFarmaciaInput | MedicamentoCreateOrConnectWithoutFarmaciaInput[]
    upsert?: MedicamentoUpsertWithWhereUniqueWithoutFarmaciaInput | MedicamentoUpsertWithWhereUniqueWithoutFarmaciaInput[]
    createMany?: MedicamentoCreateManyFarmaciaInputEnvelope
    set?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    disconnect?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    delete?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    connect?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    update?: MedicamentoUpdateWithWhereUniqueWithoutFarmaciaInput | MedicamentoUpdateWithWhereUniqueWithoutFarmaciaInput[]
    updateMany?: MedicamentoUpdateManyWithWhereWithoutFarmaciaInput | MedicamentoUpdateManyWithWhereWithoutFarmaciaInput[]
    deleteMany?: MedicamentoScalarWhereInput | MedicamentoScalarWhereInput[]
  }

  export type FarmaciaCreateNestedOneWithoutUsuariosAssociadosInput = {
    create?: XOR<FarmaciaCreateWithoutUsuariosAssociadosInput, FarmaciaUncheckedCreateWithoutUsuariosAssociadosInput>
    connectOrCreate?: FarmaciaCreateOrConnectWithoutUsuariosAssociadosInput
    connect?: FarmaciaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutFarmaciasUsuarioInput = {
    create?: XOR<UsuarioCreateWithoutFarmaciasUsuarioInput, UsuarioUncheckedCreateWithoutFarmaciasUsuarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFarmaciasUsuarioInput
    connect?: UsuarioWhereUniqueInput
  }

  export type FarmaciaUpdateOneRequiredWithoutUsuariosAssociadosNestedInput = {
    create?: XOR<FarmaciaCreateWithoutUsuariosAssociadosInput, FarmaciaUncheckedCreateWithoutUsuariosAssociadosInput>
    connectOrCreate?: FarmaciaCreateOrConnectWithoutUsuariosAssociadosInput
    upsert?: FarmaciaUpsertWithoutUsuariosAssociadosInput
    connect?: FarmaciaWhereUniqueInput
    update?: XOR<XOR<FarmaciaUpdateToOneWithWhereWithoutUsuariosAssociadosInput, FarmaciaUpdateWithoutUsuariosAssociadosInput>, FarmaciaUncheckedUpdateWithoutUsuariosAssociadosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutFarmaciasUsuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutFarmaciasUsuarioInput, UsuarioUncheckedCreateWithoutFarmaciasUsuarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFarmaciasUsuarioInput
    upsert?: UsuarioUpsertWithoutFarmaciasUsuarioInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutFarmaciasUsuarioInput, UsuarioUpdateWithoutFarmaciasUsuarioInput>, UsuarioUncheckedUpdateWithoutFarmaciasUsuarioInput>
  }

  export type PlanoAcaoCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<PlanoAcaoCreateWithoutIndicadorInput, PlanoAcaoUncheckedCreateWithoutIndicadorInput> | PlanoAcaoCreateWithoutIndicadorInput[] | PlanoAcaoUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutIndicadorInput | PlanoAcaoCreateOrConnectWithoutIndicadorInput[]
    createMany?: PlanoAcaoCreateManyIndicadorInputEnvelope
    connect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
  }

  export type EvidenciaCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<EvidenciaCreateWithoutIndicadorInput, EvidenciaUncheckedCreateWithoutIndicadorInput> | EvidenciaCreateWithoutIndicadorInput[] | EvidenciaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutIndicadorInput | EvidenciaCreateOrConnectWithoutIndicadorInput[]
    createMany?: EvidenciaCreateManyIndicadorInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type IndicadorRelacionadoCreateNestedManyWithoutIndicadorOrigemInput = {
    create?: XOR<IndicadorRelacionadoCreateWithoutIndicadorOrigemInput, IndicadorRelacionadoUncheckedCreateWithoutIndicadorOrigemInput> | IndicadorRelacionadoCreateWithoutIndicadorOrigemInput[] | IndicadorRelacionadoUncheckedCreateWithoutIndicadorOrigemInput[]
    connectOrCreate?: IndicadorRelacionadoCreateOrConnectWithoutIndicadorOrigemInput | IndicadorRelacionadoCreateOrConnectWithoutIndicadorOrigemInput[]
    createMany?: IndicadorRelacionadoCreateManyIndicadorOrigemInputEnvelope
    connect?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
  }

  export type IndicadorRelacionadoCreateNestedManyWithoutIndicadorDestinoInput = {
    create?: XOR<IndicadorRelacionadoCreateWithoutIndicadorDestinoInput, IndicadorRelacionadoUncheckedCreateWithoutIndicadorDestinoInput> | IndicadorRelacionadoCreateWithoutIndicadorDestinoInput[] | IndicadorRelacionadoUncheckedCreateWithoutIndicadorDestinoInput[]
    connectOrCreate?: IndicadorRelacionadoCreateOrConnectWithoutIndicadorDestinoInput | IndicadorRelacionadoCreateOrConnectWithoutIndicadorDestinoInput[]
    createMany?: IndicadorRelacionadoCreateManyIndicadorDestinoInputEnvelope
    connect?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
  }

  export type PlanoAcaoUncheckedCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<PlanoAcaoCreateWithoutIndicadorInput, PlanoAcaoUncheckedCreateWithoutIndicadorInput> | PlanoAcaoCreateWithoutIndicadorInput[] | PlanoAcaoUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutIndicadorInput | PlanoAcaoCreateOrConnectWithoutIndicadorInput[]
    createMany?: PlanoAcaoCreateManyIndicadorInputEnvelope
    connect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
  }

  export type EvidenciaUncheckedCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<EvidenciaCreateWithoutIndicadorInput, EvidenciaUncheckedCreateWithoutIndicadorInput> | EvidenciaCreateWithoutIndicadorInput[] | EvidenciaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutIndicadorInput | EvidenciaCreateOrConnectWithoutIndicadorInput[]
    createMany?: EvidenciaCreateManyIndicadorInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type IndicadorRelacionadoUncheckedCreateNestedManyWithoutIndicadorOrigemInput = {
    create?: XOR<IndicadorRelacionadoCreateWithoutIndicadorOrigemInput, IndicadorRelacionadoUncheckedCreateWithoutIndicadorOrigemInput> | IndicadorRelacionadoCreateWithoutIndicadorOrigemInput[] | IndicadorRelacionadoUncheckedCreateWithoutIndicadorOrigemInput[]
    connectOrCreate?: IndicadorRelacionadoCreateOrConnectWithoutIndicadorOrigemInput | IndicadorRelacionadoCreateOrConnectWithoutIndicadorOrigemInput[]
    createMany?: IndicadorRelacionadoCreateManyIndicadorOrigemInputEnvelope
    connect?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
  }

  export type IndicadorRelacionadoUncheckedCreateNestedManyWithoutIndicadorDestinoInput = {
    create?: XOR<IndicadorRelacionadoCreateWithoutIndicadorDestinoInput, IndicadorRelacionadoUncheckedCreateWithoutIndicadorDestinoInput> | IndicadorRelacionadoCreateWithoutIndicadorDestinoInput[] | IndicadorRelacionadoUncheckedCreateWithoutIndicadorDestinoInput[]
    connectOrCreate?: IndicadorRelacionadoCreateOrConnectWithoutIndicadorDestinoInput | IndicadorRelacionadoCreateOrConnectWithoutIndicadorDestinoInput[]
    createMany?: IndicadorRelacionadoCreateManyIndicadorDestinoInputEnvelope
    connect?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
  }

  export type PlanoAcaoUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<PlanoAcaoCreateWithoutIndicadorInput, PlanoAcaoUncheckedCreateWithoutIndicadorInput> | PlanoAcaoCreateWithoutIndicadorInput[] | PlanoAcaoUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutIndicadorInput | PlanoAcaoCreateOrConnectWithoutIndicadorInput[]
    upsert?: PlanoAcaoUpsertWithWhereUniqueWithoutIndicadorInput | PlanoAcaoUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: PlanoAcaoCreateManyIndicadorInputEnvelope
    set?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    disconnect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    delete?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    connect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    update?: PlanoAcaoUpdateWithWhereUniqueWithoutIndicadorInput | PlanoAcaoUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: PlanoAcaoUpdateManyWithWhereWithoutIndicadorInput | PlanoAcaoUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: PlanoAcaoScalarWhereInput | PlanoAcaoScalarWhereInput[]
  }

  export type EvidenciaUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<EvidenciaCreateWithoutIndicadorInput, EvidenciaUncheckedCreateWithoutIndicadorInput> | EvidenciaCreateWithoutIndicadorInput[] | EvidenciaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutIndicadorInput | EvidenciaCreateOrConnectWithoutIndicadorInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutIndicadorInput | EvidenciaUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: EvidenciaCreateManyIndicadorInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutIndicadorInput | EvidenciaUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutIndicadorInput | EvidenciaUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type IndicadorRelacionadoUpdateManyWithoutIndicadorOrigemNestedInput = {
    create?: XOR<IndicadorRelacionadoCreateWithoutIndicadorOrigemInput, IndicadorRelacionadoUncheckedCreateWithoutIndicadorOrigemInput> | IndicadorRelacionadoCreateWithoutIndicadorOrigemInput[] | IndicadorRelacionadoUncheckedCreateWithoutIndicadorOrigemInput[]
    connectOrCreate?: IndicadorRelacionadoCreateOrConnectWithoutIndicadorOrigemInput | IndicadorRelacionadoCreateOrConnectWithoutIndicadorOrigemInput[]
    upsert?: IndicadorRelacionadoUpsertWithWhereUniqueWithoutIndicadorOrigemInput | IndicadorRelacionadoUpsertWithWhereUniqueWithoutIndicadorOrigemInput[]
    createMany?: IndicadorRelacionadoCreateManyIndicadorOrigemInputEnvelope
    set?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    disconnect?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    delete?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    connect?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    update?: IndicadorRelacionadoUpdateWithWhereUniqueWithoutIndicadorOrigemInput | IndicadorRelacionadoUpdateWithWhereUniqueWithoutIndicadorOrigemInput[]
    updateMany?: IndicadorRelacionadoUpdateManyWithWhereWithoutIndicadorOrigemInput | IndicadorRelacionadoUpdateManyWithWhereWithoutIndicadorOrigemInput[]
    deleteMany?: IndicadorRelacionadoScalarWhereInput | IndicadorRelacionadoScalarWhereInput[]
  }

  export type IndicadorRelacionadoUpdateManyWithoutIndicadorDestinoNestedInput = {
    create?: XOR<IndicadorRelacionadoCreateWithoutIndicadorDestinoInput, IndicadorRelacionadoUncheckedCreateWithoutIndicadorDestinoInput> | IndicadorRelacionadoCreateWithoutIndicadorDestinoInput[] | IndicadorRelacionadoUncheckedCreateWithoutIndicadorDestinoInput[]
    connectOrCreate?: IndicadorRelacionadoCreateOrConnectWithoutIndicadorDestinoInput | IndicadorRelacionadoCreateOrConnectWithoutIndicadorDestinoInput[]
    upsert?: IndicadorRelacionadoUpsertWithWhereUniqueWithoutIndicadorDestinoInput | IndicadorRelacionadoUpsertWithWhereUniqueWithoutIndicadorDestinoInput[]
    createMany?: IndicadorRelacionadoCreateManyIndicadorDestinoInputEnvelope
    set?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    disconnect?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    delete?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    connect?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    update?: IndicadorRelacionadoUpdateWithWhereUniqueWithoutIndicadorDestinoInput | IndicadorRelacionadoUpdateWithWhereUniqueWithoutIndicadorDestinoInput[]
    updateMany?: IndicadorRelacionadoUpdateManyWithWhereWithoutIndicadorDestinoInput | IndicadorRelacionadoUpdateManyWithWhereWithoutIndicadorDestinoInput[]
    deleteMany?: IndicadorRelacionadoScalarWhereInput | IndicadorRelacionadoScalarWhereInput[]
  }

  export type PlanoAcaoUncheckedUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<PlanoAcaoCreateWithoutIndicadorInput, PlanoAcaoUncheckedCreateWithoutIndicadorInput> | PlanoAcaoCreateWithoutIndicadorInput[] | PlanoAcaoUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutIndicadorInput | PlanoAcaoCreateOrConnectWithoutIndicadorInput[]
    upsert?: PlanoAcaoUpsertWithWhereUniqueWithoutIndicadorInput | PlanoAcaoUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: PlanoAcaoCreateManyIndicadorInputEnvelope
    set?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    disconnect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    delete?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    connect?: PlanoAcaoWhereUniqueInput | PlanoAcaoWhereUniqueInput[]
    update?: PlanoAcaoUpdateWithWhereUniqueWithoutIndicadorInput | PlanoAcaoUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: PlanoAcaoUpdateManyWithWhereWithoutIndicadorInput | PlanoAcaoUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: PlanoAcaoScalarWhereInput | PlanoAcaoScalarWhereInput[]
  }

  export type EvidenciaUncheckedUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<EvidenciaCreateWithoutIndicadorInput, EvidenciaUncheckedCreateWithoutIndicadorInput> | EvidenciaCreateWithoutIndicadorInput[] | EvidenciaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutIndicadorInput | EvidenciaCreateOrConnectWithoutIndicadorInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutIndicadorInput | EvidenciaUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: EvidenciaCreateManyIndicadorInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutIndicadorInput | EvidenciaUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutIndicadorInput | EvidenciaUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorOrigemNestedInput = {
    create?: XOR<IndicadorRelacionadoCreateWithoutIndicadorOrigemInput, IndicadorRelacionadoUncheckedCreateWithoutIndicadorOrigemInput> | IndicadorRelacionadoCreateWithoutIndicadorOrigemInput[] | IndicadorRelacionadoUncheckedCreateWithoutIndicadorOrigemInput[]
    connectOrCreate?: IndicadorRelacionadoCreateOrConnectWithoutIndicadorOrigemInput | IndicadorRelacionadoCreateOrConnectWithoutIndicadorOrigemInput[]
    upsert?: IndicadorRelacionadoUpsertWithWhereUniqueWithoutIndicadorOrigemInput | IndicadorRelacionadoUpsertWithWhereUniqueWithoutIndicadorOrigemInput[]
    createMany?: IndicadorRelacionadoCreateManyIndicadorOrigemInputEnvelope
    set?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    disconnect?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    delete?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    connect?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    update?: IndicadorRelacionadoUpdateWithWhereUniqueWithoutIndicadorOrigemInput | IndicadorRelacionadoUpdateWithWhereUniqueWithoutIndicadorOrigemInput[]
    updateMany?: IndicadorRelacionadoUpdateManyWithWhereWithoutIndicadorOrigemInput | IndicadorRelacionadoUpdateManyWithWhereWithoutIndicadorOrigemInput[]
    deleteMany?: IndicadorRelacionadoScalarWhereInput | IndicadorRelacionadoScalarWhereInput[]
  }

  export type IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorDestinoNestedInput = {
    create?: XOR<IndicadorRelacionadoCreateWithoutIndicadorDestinoInput, IndicadorRelacionadoUncheckedCreateWithoutIndicadorDestinoInput> | IndicadorRelacionadoCreateWithoutIndicadorDestinoInput[] | IndicadorRelacionadoUncheckedCreateWithoutIndicadorDestinoInput[]
    connectOrCreate?: IndicadorRelacionadoCreateOrConnectWithoutIndicadorDestinoInput | IndicadorRelacionadoCreateOrConnectWithoutIndicadorDestinoInput[]
    upsert?: IndicadorRelacionadoUpsertWithWhereUniqueWithoutIndicadorDestinoInput | IndicadorRelacionadoUpsertWithWhereUniqueWithoutIndicadorDestinoInput[]
    createMany?: IndicadorRelacionadoCreateManyIndicadorDestinoInputEnvelope
    set?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    disconnect?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    delete?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    connect?: IndicadorRelacionadoWhereUniqueInput | IndicadorRelacionadoWhereUniqueInput[]
    update?: IndicadorRelacionadoUpdateWithWhereUniqueWithoutIndicadorDestinoInput | IndicadorRelacionadoUpdateWithWhereUniqueWithoutIndicadorDestinoInput[]
    updateMany?: IndicadorRelacionadoUpdateManyWithWhereWithoutIndicadorDestinoInput | IndicadorRelacionadoUpdateManyWithWhereWithoutIndicadorDestinoInput[]
    deleteMany?: IndicadorRelacionadoScalarWhereInput | IndicadorRelacionadoScalarWhereInput[]
  }

  export type IndicadorCreateNestedOneWithoutRelacionadosInput = {
    create?: XOR<IndicadorCreateWithoutRelacionadosInput, IndicadorUncheckedCreateWithoutRelacionadosInput>
    connectOrCreate?: IndicadorCreateOrConnectWithoutRelacionadosInput
    connect?: IndicadorWhereUniqueInput
  }

  export type IndicadorCreateNestedOneWithoutRelacionadoAInput = {
    create?: XOR<IndicadorCreateWithoutRelacionadoAInput, IndicadorUncheckedCreateWithoutRelacionadoAInput>
    connectOrCreate?: IndicadorCreateOrConnectWithoutRelacionadoAInput
    connect?: IndicadorWhereUniqueInput
  }

  export type IndicadorUpdateOneRequiredWithoutRelacionadosNestedInput = {
    create?: XOR<IndicadorCreateWithoutRelacionadosInput, IndicadorUncheckedCreateWithoutRelacionadosInput>
    connectOrCreate?: IndicadorCreateOrConnectWithoutRelacionadosInput
    upsert?: IndicadorUpsertWithoutRelacionadosInput
    connect?: IndicadorWhereUniqueInput
    update?: XOR<XOR<IndicadorUpdateToOneWithWhereWithoutRelacionadosInput, IndicadorUpdateWithoutRelacionadosInput>, IndicadorUncheckedUpdateWithoutRelacionadosInput>
  }

  export type IndicadorUpdateOneRequiredWithoutRelacionadoANestedInput = {
    create?: XOR<IndicadorCreateWithoutRelacionadoAInput, IndicadorUncheckedCreateWithoutRelacionadoAInput>
    connectOrCreate?: IndicadorCreateOrConnectWithoutRelacionadoAInput
    upsert?: IndicadorUpsertWithoutRelacionadoAInput
    connect?: IndicadorWhereUniqueInput
    update?: XOR<XOR<IndicadorUpdateToOneWithWhereWithoutRelacionadoAInput, IndicadorUpdateWithoutRelacionadoAInput>, IndicadorUncheckedUpdateWithoutRelacionadoAInput>
  }

  export type FarmaciaCreateNestedOneWithoutPlanosAcaoInput = {
    create?: XOR<FarmaciaCreateWithoutPlanosAcaoInput, FarmaciaUncheckedCreateWithoutPlanosAcaoInput>
    connectOrCreate?: FarmaciaCreateOrConnectWithoutPlanosAcaoInput
    connect?: FarmaciaWhereUniqueInput
  }

  export type IndicadorCreateNestedOneWithoutPlanosAcaoInput = {
    create?: XOR<IndicadorCreateWithoutPlanosAcaoInput, IndicadorUncheckedCreateWithoutPlanosAcaoInput>
    connectOrCreate?: IndicadorCreateOrConnectWithoutPlanosAcaoInput
    connect?: IndicadorWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutPlanosInput = {
    create?: XOR<UsuarioCreateWithoutPlanosInput, UsuarioUncheckedCreateWithoutPlanosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPlanosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type AcaoCreateNestedManyWithoutPlanoAcaoInput = {
    create?: XOR<AcaoCreateWithoutPlanoAcaoInput, AcaoUncheckedCreateWithoutPlanoAcaoInput> | AcaoCreateWithoutPlanoAcaoInput[] | AcaoUncheckedCreateWithoutPlanoAcaoInput[]
    connectOrCreate?: AcaoCreateOrConnectWithoutPlanoAcaoInput | AcaoCreateOrConnectWithoutPlanoAcaoInput[]
    createMany?: AcaoCreateManyPlanoAcaoInputEnvelope
    connect?: AcaoWhereUniqueInput | AcaoWhereUniqueInput[]
  }

  export type ComentarioCreateNestedManyWithoutPlanoAcaoInput = {
    create?: XOR<ComentarioCreateWithoutPlanoAcaoInput, ComentarioUncheckedCreateWithoutPlanoAcaoInput> | ComentarioCreateWithoutPlanoAcaoInput[] | ComentarioUncheckedCreateWithoutPlanoAcaoInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutPlanoAcaoInput | ComentarioCreateOrConnectWithoutPlanoAcaoInput[]
    createMany?: ComentarioCreateManyPlanoAcaoInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type EvidenciaCreateNestedManyWithoutPlanoInput = {
    create?: XOR<EvidenciaCreateWithoutPlanoInput, EvidenciaUncheckedCreateWithoutPlanoInput> | EvidenciaCreateWithoutPlanoInput[] | EvidenciaUncheckedCreateWithoutPlanoInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutPlanoInput | EvidenciaCreateOrConnectWithoutPlanoInput[]
    createMany?: EvidenciaCreateManyPlanoInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type AcaoUncheckedCreateNestedManyWithoutPlanoAcaoInput = {
    create?: XOR<AcaoCreateWithoutPlanoAcaoInput, AcaoUncheckedCreateWithoutPlanoAcaoInput> | AcaoCreateWithoutPlanoAcaoInput[] | AcaoUncheckedCreateWithoutPlanoAcaoInput[]
    connectOrCreate?: AcaoCreateOrConnectWithoutPlanoAcaoInput | AcaoCreateOrConnectWithoutPlanoAcaoInput[]
    createMany?: AcaoCreateManyPlanoAcaoInputEnvelope
    connect?: AcaoWhereUniqueInput | AcaoWhereUniqueInput[]
  }

  export type ComentarioUncheckedCreateNestedManyWithoutPlanoAcaoInput = {
    create?: XOR<ComentarioCreateWithoutPlanoAcaoInput, ComentarioUncheckedCreateWithoutPlanoAcaoInput> | ComentarioCreateWithoutPlanoAcaoInput[] | ComentarioUncheckedCreateWithoutPlanoAcaoInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutPlanoAcaoInput | ComentarioCreateOrConnectWithoutPlanoAcaoInput[]
    createMany?: ComentarioCreateManyPlanoAcaoInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type EvidenciaUncheckedCreateNestedManyWithoutPlanoInput = {
    create?: XOR<EvidenciaCreateWithoutPlanoInput, EvidenciaUncheckedCreateWithoutPlanoInput> | EvidenciaCreateWithoutPlanoInput[] | EvidenciaUncheckedCreateWithoutPlanoInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutPlanoInput | EvidenciaCreateOrConnectWithoutPlanoInput[]
    createMany?: EvidenciaCreateManyPlanoInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FarmaciaUpdateOneRequiredWithoutPlanosAcaoNestedInput = {
    create?: XOR<FarmaciaCreateWithoutPlanosAcaoInput, FarmaciaUncheckedCreateWithoutPlanosAcaoInput>
    connectOrCreate?: FarmaciaCreateOrConnectWithoutPlanosAcaoInput
    upsert?: FarmaciaUpsertWithoutPlanosAcaoInput
    connect?: FarmaciaWhereUniqueInput
    update?: XOR<XOR<FarmaciaUpdateToOneWithWhereWithoutPlanosAcaoInput, FarmaciaUpdateWithoutPlanosAcaoInput>, FarmaciaUncheckedUpdateWithoutPlanosAcaoInput>
  }

  export type IndicadorUpdateOneRequiredWithoutPlanosAcaoNestedInput = {
    create?: XOR<IndicadorCreateWithoutPlanosAcaoInput, IndicadorUncheckedCreateWithoutPlanosAcaoInput>
    connectOrCreate?: IndicadorCreateOrConnectWithoutPlanosAcaoInput
    upsert?: IndicadorUpsertWithoutPlanosAcaoInput
    connect?: IndicadorWhereUniqueInput
    update?: XOR<XOR<IndicadorUpdateToOneWithWhereWithoutPlanosAcaoInput, IndicadorUpdateWithoutPlanosAcaoInput>, IndicadorUncheckedUpdateWithoutPlanosAcaoInput>
  }

  export type UsuarioUpdateOneRequiredWithoutPlanosNestedInput = {
    create?: XOR<UsuarioCreateWithoutPlanosInput, UsuarioUncheckedCreateWithoutPlanosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPlanosInput
    upsert?: UsuarioUpsertWithoutPlanosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPlanosInput, UsuarioUpdateWithoutPlanosInput>, UsuarioUncheckedUpdateWithoutPlanosInput>
  }

  export type AcaoUpdateManyWithoutPlanoAcaoNestedInput = {
    create?: XOR<AcaoCreateWithoutPlanoAcaoInput, AcaoUncheckedCreateWithoutPlanoAcaoInput> | AcaoCreateWithoutPlanoAcaoInput[] | AcaoUncheckedCreateWithoutPlanoAcaoInput[]
    connectOrCreate?: AcaoCreateOrConnectWithoutPlanoAcaoInput | AcaoCreateOrConnectWithoutPlanoAcaoInput[]
    upsert?: AcaoUpsertWithWhereUniqueWithoutPlanoAcaoInput | AcaoUpsertWithWhereUniqueWithoutPlanoAcaoInput[]
    createMany?: AcaoCreateManyPlanoAcaoInputEnvelope
    set?: AcaoWhereUniqueInput | AcaoWhereUniqueInput[]
    disconnect?: AcaoWhereUniqueInput | AcaoWhereUniqueInput[]
    delete?: AcaoWhereUniqueInput | AcaoWhereUniqueInput[]
    connect?: AcaoWhereUniqueInput | AcaoWhereUniqueInput[]
    update?: AcaoUpdateWithWhereUniqueWithoutPlanoAcaoInput | AcaoUpdateWithWhereUniqueWithoutPlanoAcaoInput[]
    updateMany?: AcaoUpdateManyWithWhereWithoutPlanoAcaoInput | AcaoUpdateManyWithWhereWithoutPlanoAcaoInput[]
    deleteMany?: AcaoScalarWhereInput | AcaoScalarWhereInput[]
  }

  export type ComentarioUpdateManyWithoutPlanoAcaoNestedInput = {
    create?: XOR<ComentarioCreateWithoutPlanoAcaoInput, ComentarioUncheckedCreateWithoutPlanoAcaoInput> | ComentarioCreateWithoutPlanoAcaoInput[] | ComentarioUncheckedCreateWithoutPlanoAcaoInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutPlanoAcaoInput | ComentarioCreateOrConnectWithoutPlanoAcaoInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutPlanoAcaoInput | ComentarioUpsertWithWhereUniqueWithoutPlanoAcaoInput[]
    createMany?: ComentarioCreateManyPlanoAcaoInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutPlanoAcaoInput | ComentarioUpdateWithWhereUniqueWithoutPlanoAcaoInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutPlanoAcaoInput | ComentarioUpdateManyWithWhereWithoutPlanoAcaoInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type EvidenciaUpdateManyWithoutPlanoNestedInput = {
    create?: XOR<EvidenciaCreateWithoutPlanoInput, EvidenciaUncheckedCreateWithoutPlanoInput> | EvidenciaCreateWithoutPlanoInput[] | EvidenciaUncheckedCreateWithoutPlanoInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutPlanoInput | EvidenciaCreateOrConnectWithoutPlanoInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutPlanoInput | EvidenciaUpsertWithWhereUniqueWithoutPlanoInput[]
    createMany?: EvidenciaCreateManyPlanoInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutPlanoInput | EvidenciaUpdateWithWhereUniqueWithoutPlanoInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutPlanoInput | EvidenciaUpdateManyWithWhereWithoutPlanoInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type AcaoUncheckedUpdateManyWithoutPlanoAcaoNestedInput = {
    create?: XOR<AcaoCreateWithoutPlanoAcaoInput, AcaoUncheckedCreateWithoutPlanoAcaoInput> | AcaoCreateWithoutPlanoAcaoInput[] | AcaoUncheckedCreateWithoutPlanoAcaoInput[]
    connectOrCreate?: AcaoCreateOrConnectWithoutPlanoAcaoInput | AcaoCreateOrConnectWithoutPlanoAcaoInput[]
    upsert?: AcaoUpsertWithWhereUniqueWithoutPlanoAcaoInput | AcaoUpsertWithWhereUniqueWithoutPlanoAcaoInput[]
    createMany?: AcaoCreateManyPlanoAcaoInputEnvelope
    set?: AcaoWhereUniqueInput | AcaoWhereUniqueInput[]
    disconnect?: AcaoWhereUniqueInput | AcaoWhereUniqueInput[]
    delete?: AcaoWhereUniqueInput | AcaoWhereUniqueInput[]
    connect?: AcaoWhereUniqueInput | AcaoWhereUniqueInput[]
    update?: AcaoUpdateWithWhereUniqueWithoutPlanoAcaoInput | AcaoUpdateWithWhereUniqueWithoutPlanoAcaoInput[]
    updateMany?: AcaoUpdateManyWithWhereWithoutPlanoAcaoInput | AcaoUpdateManyWithWhereWithoutPlanoAcaoInput[]
    deleteMany?: AcaoScalarWhereInput | AcaoScalarWhereInput[]
  }

  export type ComentarioUncheckedUpdateManyWithoutPlanoAcaoNestedInput = {
    create?: XOR<ComentarioCreateWithoutPlanoAcaoInput, ComentarioUncheckedCreateWithoutPlanoAcaoInput> | ComentarioCreateWithoutPlanoAcaoInput[] | ComentarioUncheckedCreateWithoutPlanoAcaoInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutPlanoAcaoInput | ComentarioCreateOrConnectWithoutPlanoAcaoInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutPlanoAcaoInput | ComentarioUpsertWithWhereUniqueWithoutPlanoAcaoInput[]
    createMany?: ComentarioCreateManyPlanoAcaoInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutPlanoAcaoInput | ComentarioUpdateWithWhereUniqueWithoutPlanoAcaoInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutPlanoAcaoInput | ComentarioUpdateManyWithWhereWithoutPlanoAcaoInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type EvidenciaUncheckedUpdateManyWithoutPlanoNestedInput = {
    create?: XOR<EvidenciaCreateWithoutPlanoInput, EvidenciaUncheckedCreateWithoutPlanoInput> | EvidenciaCreateWithoutPlanoInput[] | EvidenciaUncheckedCreateWithoutPlanoInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutPlanoInput | EvidenciaCreateOrConnectWithoutPlanoInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutPlanoInput | EvidenciaUpsertWithWhereUniqueWithoutPlanoInput[]
    createMany?: EvidenciaCreateManyPlanoInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutPlanoInput | EvidenciaUpdateWithWhereUniqueWithoutPlanoInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutPlanoInput | EvidenciaUpdateManyWithWhereWithoutPlanoInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type PlanoAcaoCreateNestedOneWithoutAcoesInput = {
    create?: XOR<PlanoAcaoCreateWithoutAcoesInput, PlanoAcaoUncheckedCreateWithoutAcoesInput>
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutAcoesInput
    connect?: PlanoAcaoWhereUniqueInput
  }

  export type PlanoAcaoUpdateOneRequiredWithoutAcoesNestedInput = {
    create?: XOR<PlanoAcaoCreateWithoutAcoesInput, PlanoAcaoUncheckedCreateWithoutAcoesInput>
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutAcoesInput
    upsert?: PlanoAcaoUpsertWithoutAcoesInput
    connect?: PlanoAcaoWhereUniqueInput
    update?: XOR<XOR<PlanoAcaoUpdateToOneWithWhereWithoutAcoesInput, PlanoAcaoUpdateWithoutAcoesInput>, PlanoAcaoUncheckedUpdateWithoutAcoesInput>
  }

  export type PlanoAcaoCreateNestedOneWithoutComentariosInput = {
    create?: XOR<PlanoAcaoCreateWithoutComentariosInput, PlanoAcaoUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutComentariosInput
    connect?: PlanoAcaoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutComentariosInput = {
    create?: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComentariosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PlanoAcaoUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<PlanoAcaoCreateWithoutComentariosInput, PlanoAcaoUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutComentariosInput
    upsert?: PlanoAcaoUpsertWithoutComentariosInput
    connect?: PlanoAcaoWhereUniqueInput
    update?: XOR<XOR<PlanoAcaoUpdateToOneWithWhereWithoutComentariosInput, PlanoAcaoUpdateWithoutComentariosInput>, PlanoAcaoUncheckedUpdateWithoutComentariosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComentariosInput
    upsert?: UsuarioUpsertWithoutComentariosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutComentariosInput, UsuarioUpdateWithoutComentariosInput>, UsuarioUncheckedUpdateWithoutComentariosInput>
  }

  export type PlanoAcaoCreateNestedOneWithoutEvidenciasInput = {
    create?: XOR<PlanoAcaoCreateWithoutEvidenciasInput, PlanoAcaoUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutEvidenciasInput
    connect?: PlanoAcaoWhereUniqueInput
  }

  export type FarmaciaCreateNestedOneWithoutEvidenciasInput = {
    create?: XOR<FarmaciaCreateWithoutEvidenciasInput, FarmaciaUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: FarmaciaCreateOrConnectWithoutEvidenciasInput
    connect?: FarmaciaWhereUniqueInput
  }

  export type IndicadorCreateNestedOneWithoutEvidenciasInput = {
    create?: XOR<IndicadorCreateWithoutEvidenciasInput, IndicadorUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: IndicadorCreateOrConnectWithoutEvidenciasInput
    connect?: IndicadorWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutEvidenciasInput = {
    create?: XOR<UsuarioCreateWithoutEvidenciasInput, UsuarioUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEvidenciasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ComentarioEvidenciaCreateNestedManyWithoutEvidenciaInput = {
    create?: XOR<ComentarioEvidenciaCreateWithoutEvidenciaInput, ComentarioEvidenciaUncheckedCreateWithoutEvidenciaInput> | ComentarioEvidenciaCreateWithoutEvidenciaInput[] | ComentarioEvidenciaUncheckedCreateWithoutEvidenciaInput[]
    connectOrCreate?: ComentarioEvidenciaCreateOrConnectWithoutEvidenciaInput | ComentarioEvidenciaCreateOrConnectWithoutEvidenciaInput[]
    createMany?: ComentarioEvidenciaCreateManyEvidenciaInputEnvelope
    connect?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
  }

  export type ComentarioEvidenciaUncheckedCreateNestedManyWithoutEvidenciaInput = {
    create?: XOR<ComentarioEvidenciaCreateWithoutEvidenciaInput, ComentarioEvidenciaUncheckedCreateWithoutEvidenciaInput> | ComentarioEvidenciaCreateWithoutEvidenciaInput[] | ComentarioEvidenciaUncheckedCreateWithoutEvidenciaInput[]
    connectOrCreate?: ComentarioEvidenciaCreateOrConnectWithoutEvidenciaInput | ComentarioEvidenciaCreateOrConnectWithoutEvidenciaInput[]
    createMany?: ComentarioEvidenciaCreateManyEvidenciaInputEnvelope
    connect?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PlanoAcaoUpdateOneRequiredWithoutEvidenciasNestedInput = {
    create?: XOR<PlanoAcaoCreateWithoutEvidenciasInput, PlanoAcaoUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: PlanoAcaoCreateOrConnectWithoutEvidenciasInput
    upsert?: PlanoAcaoUpsertWithoutEvidenciasInput
    connect?: PlanoAcaoWhereUniqueInput
    update?: XOR<XOR<PlanoAcaoUpdateToOneWithWhereWithoutEvidenciasInput, PlanoAcaoUpdateWithoutEvidenciasInput>, PlanoAcaoUncheckedUpdateWithoutEvidenciasInput>
  }

  export type FarmaciaUpdateOneRequiredWithoutEvidenciasNestedInput = {
    create?: XOR<FarmaciaCreateWithoutEvidenciasInput, FarmaciaUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: FarmaciaCreateOrConnectWithoutEvidenciasInput
    upsert?: FarmaciaUpsertWithoutEvidenciasInput
    connect?: FarmaciaWhereUniqueInput
    update?: XOR<XOR<FarmaciaUpdateToOneWithWhereWithoutEvidenciasInput, FarmaciaUpdateWithoutEvidenciasInput>, FarmaciaUncheckedUpdateWithoutEvidenciasInput>
  }

  export type IndicadorUpdateOneRequiredWithoutEvidenciasNestedInput = {
    create?: XOR<IndicadorCreateWithoutEvidenciasInput, IndicadorUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: IndicadorCreateOrConnectWithoutEvidenciasInput
    upsert?: IndicadorUpsertWithoutEvidenciasInput
    connect?: IndicadorWhereUniqueInput
    update?: XOR<XOR<IndicadorUpdateToOneWithWhereWithoutEvidenciasInput, IndicadorUpdateWithoutEvidenciasInput>, IndicadorUncheckedUpdateWithoutEvidenciasInput>
  }

  export type UsuarioUpdateOneRequiredWithoutEvidenciasNestedInput = {
    create?: XOR<UsuarioCreateWithoutEvidenciasInput, UsuarioUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEvidenciasInput
    upsert?: UsuarioUpsertWithoutEvidenciasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEvidenciasInput, UsuarioUpdateWithoutEvidenciasInput>, UsuarioUncheckedUpdateWithoutEvidenciasInput>
  }

  export type ComentarioEvidenciaUpdateManyWithoutEvidenciaNestedInput = {
    create?: XOR<ComentarioEvidenciaCreateWithoutEvidenciaInput, ComentarioEvidenciaUncheckedCreateWithoutEvidenciaInput> | ComentarioEvidenciaCreateWithoutEvidenciaInput[] | ComentarioEvidenciaUncheckedCreateWithoutEvidenciaInput[]
    connectOrCreate?: ComentarioEvidenciaCreateOrConnectWithoutEvidenciaInput | ComentarioEvidenciaCreateOrConnectWithoutEvidenciaInput[]
    upsert?: ComentarioEvidenciaUpsertWithWhereUniqueWithoutEvidenciaInput | ComentarioEvidenciaUpsertWithWhereUniqueWithoutEvidenciaInput[]
    createMany?: ComentarioEvidenciaCreateManyEvidenciaInputEnvelope
    set?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    disconnect?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    delete?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    connect?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    update?: ComentarioEvidenciaUpdateWithWhereUniqueWithoutEvidenciaInput | ComentarioEvidenciaUpdateWithWhereUniqueWithoutEvidenciaInput[]
    updateMany?: ComentarioEvidenciaUpdateManyWithWhereWithoutEvidenciaInput | ComentarioEvidenciaUpdateManyWithWhereWithoutEvidenciaInput[]
    deleteMany?: ComentarioEvidenciaScalarWhereInput | ComentarioEvidenciaScalarWhereInput[]
  }

  export type ComentarioEvidenciaUncheckedUpdateManyWithoutEvidenciaNestedInput = {
    create?: XOR<ComentarioEvidenciaCreateWithoutEvidenciaInput, ComentarioEvidenciaUncheckedCreateWithoutEvidenciaInput> | ComentarioEvidenciaCreateWithoutEvidenciaInput[] | ComentarioEvidenciaUncheckedCreateWithoutEvidenciaInput[]
    connectOrCreate?: ComentarioEvidenciaCreateOrConnectWithoutEvidenciaInput | ComentarioEvidenciaCreateOrConnectWithoutEvidenciaInput[]
    upsert?: ComentarioEvidenciaUpsertWithWhereUniqueWithoutEvidenciaInput | ComentarioEvidenciaUpsertWithWhereUniqueWithoutEvidenciaInput[]
    createMany?: ComentarioEvidenciaCreateManyEvidenciaInputEnvelope
    set?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    disconnect?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    delete?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    connect?: ComentarioEvidenciaWhereUniqueInput | ComentarioEvidenciaWhereUniqueInput[]
    update?: ComentarioEvidenciaUpdateWithWhereUniqueWithoutEvidenciaInput | ComentarioEvidenciaUpdateWithWhereUniqueWithoutEvidenciaInput[]
    updateMany?: ComentarioEvidenciaUpdateManyWithWhereWithoutEvidenciaInput | ComentarioEvidenciaUpdateManyWithWhereWithoutEvidenciaInput[]
    deleteMany?: ComentarioEvidenciaScalarWhereInput | ComentarioEvidenciaScalarWhereInput[]
  }

  export type EvidenciaCreateNestedOneWithoutComentariosInput = {
    create?: XOR<EvidenciaCreateWithoutComentariosInput, EvidenciaUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: EvidenciaCreateOrConnectWithoutComentariosInput
    connect?: EvidenciaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutComentariosEvidenciaInput = {
    create?: XOR<UsuarioCreateWithoutComentariosEvidenciaInput, UsuarioUncheckedCreateWithoutComentariosEvidenciaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComentariosEvidenciaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EvidenciaUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<EvidenciaCreateWithoutComentariosInput, EvidenciaUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: EvidenciaCreateOrConnectWithoutComentariosInput
    upsert?: EvidenciaUpsertWithoutComentariosInput
    connect?: EvidenciaWhereUniqueInput
    update?: XOR<XOR<EvidenciaUpdateToOneWithWhereWithoutComentariosInput, EvidenciaUpdateWithoutComentariosInput>, EvidenciaUncheckedUpdateWithoutComentariosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutComentariosEvidenciaNestedInput = {
    create?: XOR<UsuarioCreateWithoutComentariosEvidenciaInput, UsuarioUncheckedCreateWithoutComentariosEvidenciaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComentariosEvidenciaInput
    upsert?: UsuarioUpsertWithoutComentariosEvidenciaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutComentariosEvidenciaInput, UsuarioUpdateWithoutComentariosEvidenciaInput>, UsuarioUncheckedUpdateWithoutComentariosEvidenciaInput>
  }

  export type FarmaciaCreateNestedOneWithoutMedicamentosInput = {
    create?: XOR<FarmaciaCreateWithoutMedicamentosInput, FarmaciaUncheckedCreateWithoutMedicamentosInput>
    connectOrCreate?: FarmaciaCreateOrConnectWithoutMedicamentosInput
    connect?: FarmaciaWhereUniqueInput
  }

  export type ClienteCreateNestedOneWithoutMedicamentosInput = {
    create?: XOR<ClienteCreateWithoutMedicamentosInput, ClienteUncheckedCreateWithoutMedicamentosInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutMedicamentosInput
    connect?: ClienteWhereUniqueInput
  }

  export type FarmaciaUpdateOneRequiredWithoutMedicamentosNestedInput = {
    create?: XOR<FarmaciaCreateWithoutMedicamentosInput, FarmaciaUncheckedCreateWithoutMedicamentosInput>
    connectOrCreate?: FarmaciaCreateOrConnectWithoutMedicamentosInput
    upsert?: FarmaciaUpsertWithoutMedicamentosInput
    connect?: FarmaciaWhereUniqueInput
    update?: XOR<XOR<FarmaciaUpdateToOneWithWhereWithoutMedicamentosInput, FarmaciaUpdateWithoutMedicamentosInput>, FarmaciaUncheckedUpdateWithoutMedicamentosInput>
  }

  export type ClienteUpdateOneRequiredWithoutMedicamentosNestedInput = {
    create?: XOR<ClienteCreateWithoutMedicamentosInput, ClienteUncheckedCreateWithoutMedicamentosInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutMedicamentosInput
    upsert?: ClienteUpsertWithoutMedicamentosInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutMedicamentosInput, ClienteUpdateWithoutMedicamentosInput>, ClienteUncheckedUpdateWithoutMedicamentosInput>
  }

  export type MedicamentoCreateNestedManyWithoutClienteInput = {
    create?: XOR<MedicamentoCreateWithoutClienteInput, MedicamentoUncheckedCreateWithoutClienteInput> | MedicamentoCreateWithoutClienteInput[] | MedicamentoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: MedicamentoCreateOrConnectWithoutClienteInput | MedicamentoCreateOrConnectWithoutClienteInput[]
    createMany?: MedicamentoCreateManyClienteInputEnvelope
    connect?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
  }

  export type MedicamentoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<MedicamentoCreateWithoutClienteInput, MedicamentoUncheckedCreateWithoutClienteInput> | MedicamentoCreateWithoutClienteInput[] | MedicamentoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: MedicamentoCreateOrConnectWithoutClienteInput | MedicamentoCreateOrConnectWithoutClienteInput[]
    createMany?: MedicamentoCreateManyClienteInputEnvelope
    connect?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
  }

  export type MedicamentoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<MedicamentoCreateWithoutClienteInput, MedicamentoUncheckedCreateWithoutClienteInput> | MedicamentoCreateWithoutClienteInput[] | MedicamentoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: MedicamentoCreateOrConnectWithoutClienteInput | MedicamentoCreateOrConnectWithoutClienteInput[]
    upsert?: MedicamentoUpsertWithWhereUniqueWithoutClienteInput | MedicamentoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: MedicamentoCreateManyClienteInputEnvelope
    set?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    disconnect?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    delete?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    connect?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    update?: MedicamentoUpdateWithWhereUniqueWithoutClienteInput | MedicamentoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: MedicamentoUpdateManyWithWhereWithoutClienteInput | MedicamentoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: MedicamentoScalarWhereInput | MedicamentoScalarWhereInput[]
  }

  export type MedicamentoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<MedicamentoCreateWithoutClienteInput, MedicamentoUncheckedCreateWithoutClienteInput> | MedicamentoCreateWithoutClienteInput[] | MedicamentoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: MedicamentoCreateOrConnectWithoutClienteInput | MedicamentoCreateOrConnectWithoutClienteInput[]
    upsert?: MedicamentoUpsertWithWhereUniqueWithoutClienteInput | MedicamentoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: MedicamentoCreateManyClienteInputEnvelope
    set?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    disconnect?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    delete?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    connect?: MedicamentoWhereUniqueInput | MedicamentoWhereUniqueInput[]
    update?: MedicamentoUpdateWithWhereUniqueWithoutClienteInput | MedicamentoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: MedicamentoUpdateManyWithWhereWithoutClienteInput | MedicamentoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: MedicamentoScalarWhereInput | MedicamentoScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FarmaciaUsuarioCreateWithoutUsuarioInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    farmacia: FarmaciaCreateNestedOneWithoutUsuariosAssociadosInput
  }

  export type FarmaciaUsuarioUncheckedCreateWithoutUsuarioInput = {
    id?: string
    farmaciaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FarmaciaUsuarioCreateOrConnectWithoutUsuarioInput = {
    where: FarmaciaUsuarioWhereUniqueInput
    create: XOR<FarmaciaUsuarioCreateWithoutUsuarioInput, FarmaciaUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type FarmaciaUsuarioCreateManyUsuarioInputEnvelope = {
    data: FarmaciaUsuarioCreateManyUsuarioInput | FarmaciaUsuarioCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type PlanoAcaoCreateWithoutResponsavelInput = {
    id?: string
    titulo: string
    descricao: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    farmacia: FarmaciaCreateNestedOneWithoutPlanosAcaoInput
    indicador: IndicadorCreateNestedOneWithoutPlanosAcaoInput
    acoes?: AcaoCreateNestedManyWithoutPlanoAcaoInput
    comentarios?: ComentarioCreateNestedManyWithoutPlanoAcaoInput
    evidencias?: EvidenciaCreateNestedManyWithoutPlanoInput
  }

  export type PlanoAcaoUncheckedCreateWithoutResponsavelInput = {
    id?: string
    titulo: string
    descricao: string
    farmaciaId: string
    indicadorId: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    acoes?: AcaoUncheckedCreateNestedManyWithoutPlanoAcaoInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutPlanoAcaoInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutPlanoInput
  }

  export type PlanoAcaoCreateOrConnectWithoutResponsavelInput = {
    where: PlanoAcaoWhereUniqueInput
    create: XOR<PlanoAcaoCreateWithoutResponsavelInput, PlanoAcaoUncheckedCreateWithoutResponsavelInput>
  }

  export type PlanoAcaoCreateManyResponsavelInputEnvelope = {
    data: PlanoAcaoCreateManyResponsavelInput | PlanoAcaoCreateManyResponsavelInput[]
    skipDuplicates?: boolean
  }

  export type ComentarioCreateWithoutUsuarioInput = {
    id?: string
    texto: string
    data?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    planoAcao: PlanoAcaoCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioUncheckedCreateWithoutUsuarioInput = {
    id?: string
    texto: string
    data?: Date | string
    planoAcaoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentarioCreateOrConnectWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    create: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ComentarioCreateManyUsuarioInputEnvelope = {
    data: ComentarioCreateManyUsuarioInput | ComentarioCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type EvidenciaCreateWithoutUsuarioInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plano: PlanoAcaoCreateNestedOneWithoutEvidenciasInput
    farmacia: FarmaciaCreateNestedOneWithoutEvidenciasInput
    indicador: IndicadorCreateNestedOneWithoutEvidenciasInput
    comentarios?: ComentarioEvidenciaCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaUncheckedCreateWithoutUsuarioInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    planoId: string
    farmaciaId: string
    indicadorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comentarios?: ComentarioEvidenciaUncheckedCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaCreateOrConnectWithoutUsuarioInput = {
    where: EvidenciaWhereUniqueInput
    create: XOR<EvidenciaCreateWithoutUsuarioInput, EvidenciaUncheckedCreateWithoutUsuarioInput>
  }

  export type EvidenciaCreateManyUsuarioInputEnvelope = {
    data: EvidenciaCreateManyUsuarioInput | EvidenciaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ComentarioEvidenciaCreateWithoutUsuarioInput = {
    id?: string
    texto: string
    data?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    evidencia: EvidenciaCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioEvidenciaUncheckedCreateWithoutUsuarioInput = {
    id?: string
    texto: string
    data?: Date | string
    evidenciaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentarioEvidenciaCreateOrConnectWithoutUsuarioInput = {
    where: ComentarioEvidenciaWhereUniqueInput
    create: XOR<ComentarioEvidenciaCreateWithoutUsuarioInput, ComentarioEvidenciaUncheckedCreateWithoutUsuarioInput>
  }

  export type ComentarioEvidenciaCreateManyUsuarioInputEnvelope = {
    data: ComentarioEvidenciaCreateManyUsuarioInput | ComentarioEvidenciaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type FarmaciaUsuarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: FarmaciaUsuarioWhereUniqueInput
    update: XOR<FarmaciaUsuarioUpdateWithoutUsuarioInput, FarmaciaUsuarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<FarmaciaUsuarioCreateWithoutUsuarioInput, FarmaciaUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type FarmaciaUsuarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: FarmaciaUsuarioWhereUniqueInput
    data: XOR<FarmaciaUsuarioUpdateWithoutUsuarioInput, FarmaciaUsuarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type FarmaciaUsuarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: FarmaciaUsuarioScalarWhereInput
    data: XOR<FarmaciaUsuarioUpdateManyMutationInput, FarmaciaUsuarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type FarmaciaUsuarioScalarWhereInput = {
    AND?: FarmaciaUsuarioScalarWhereInput | FarmaciaUsuarioScalarWhereInput[]
    OR?: FarmaciaUsuarioScalarWhereInput[]
    NOT?: FarmaciaUsuarioScalarWhereInput | FarmaciaUsuarioScalarWhereInput[]
    id?: StringFilter<"FarmaciaUsuario"> | string
    farmaciaId?: StringFilter<"FarmaciaUsuario"> | string
    usuarioId?: StringFilter<"FarmaciaUsuario"> | string
    createdAt?: DateTimeFilter<"FarmaciaUsuario"> | Date | string
    updatedAt?: DateTimeFilter<"FarmaciaUsuario"> | Date | string
  }

  export type PlanoAcaoUpsertWithWhereUniqueWithoutResponsavelInput = {
    where: PlanoAcaoWhereUniqueInput
    update: XOR<PlanoAcaoUpdateWithoutResponsavelInput, PlanoAcaoUncheckedUpdateWithoutResponsavelInput>
    create: XOR<PlanoAcaoCreateWithoutResponsavelInput, PlanoAcaoUncheckedCreateWithoutResponsavelInput>
  }

  export type PlanoAcaoUpdateWithWhereUniqueWithoutResponsavelInput = {
    where: PlanoAcaoWhereUniqueInput
    data: XOR<PlanoAcaoUpdateWithoutResponsavelInput, PlanoAcaoUncheckedUpdateWithoutResponsavelInput>
  }

  export type PlanoAcaoUpdateManyWithWhereWithoutResponsavelInput = {
    where: PlanoAcaoScalarWhereInput
    data: XOR<PlanoAcaoUpdateManyMutationInput, PlanoAcaoUncheckedUpdateManyWithoutResponsavelInput>
  }

  export type PlanoAcaoScalarWhereInput = {
    AND?: PlanoAcaoScalarWhereInput | PlanoAcaoScalarWhereInput[]
    OR?: PlanoAcaoScalarWhereInput[]
    NOT?: PlanoAcaoScalarWhereInput | PlanoAcaoScalarWhereInput[]
    id?: StringFilter<"PlanoAcao"> | string
    titulo?: StringFilter<"PlanoAcao"> | string
    descricao?: StringFilter<"PlanoAcao"> | string
    farmaciaId?: StringFilter<"PlanoAcao"> | string
    indicadorId?: StringFilter<"PlanoAcao"> | string
    responsavelId?: StringFilter<"PlanoAcao"> | string
    dataCriacao?: DateTimeFilter<"PlanoAcao"> | Date | string
    prazo?: DateTimeFilter<"PlanoAcao"> | Date | string
    status?: StringFilter<"PlanoAcao"> | string
    percentualConcluido?: IntFilter<"PlanoAcao"> | number
    createdAt?: DateTimeFilter<"PlanoAcao"> | Date | string
    updatedAt?: DateTimeFilter<"PlanoAcao"> | Date | string
  }

  export type ComentarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    update: XOR<ComentarioUpdateWithoutUsuarioInput, ComentarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ComentarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    data: XOR<ComentarioUpdateWithoutUsuarioInput, ComentarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type ComentarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: ComentarioScalarWhereInput
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ComentarioScalarWhereInput = {
    AND?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
    OR?: ComentarioScalarWhereInput[]
    NOT?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
    id?: StringFilter<"Comentario"> | string
    texto?: StringFilter<"Comentario"> | string
    data?: DateTimeFilter<"Comentario"> | Date | string
    planoAcaoId?: StringFilter<"Comentario"> | string
    usuarioId?: StringFilter<"Comentario"> | string
    createdAt?: DateTimeFilter<"Comentario"> | Date | string
    updatedAt?: DateTimeFilter<"Comentario"> | Date | string
  }

  export type EvidenciaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: EvidenciaWhereUniqueInput
    update: XOR<EvidenciaUpdateWithoutUsuarioInput, EvidenciaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EvidenciaCreateWithoutUsuarioInput, EvidenciaUncheckedCreateWithoutUsuarioInput>
  }

  export type EvidenciaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: EvidenciaWhereUniqueInput
    data: XOR<EvidenciaUpdateWithoutUsuarioInput, EvidenciaUncheckedUpdateWithoutUsuarioInput>
  }

  export type EvidenciaUpdateManyWithWhereWithoutUsuarioInput = {
    where: EvidenciaScalarWhereInput
    data: XOR<EvidenciaUpdateManyMutationInput, EvidenciaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type EvidenciaScalarWhereInput = {
    AND?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
    OR?: EvidenciaScalarWhereInput[]
    NOT?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
    id?: StringFilter<"Evidencia"> | string
    url?: StringFilter<"Evidencia"> | string
    descricao?: StringNullableFilter<"Evidencia"> | string | null
    dataCriacao?: DateTimeFilter<"Evidencia"> | Date | string
    status?: StringFilter<"Evidencia"> | string
    dataValidacao?: DateTimeNullableFilter<"Evidencia"> | Date | string | null
    validadoPorId?: StringNullableFilter<"Evidencia"> | string | null
    motivoReprovacao?: StringNullableFilter<"Evidencia"> | string | null
    planoId?: StringFilter<"Evidencia"> | string
    farmaciaId?: StringFilter<"Evidencia"> | string
    indicadorId?: StringFilter<"Evidencia"> | string
    usuarioId?: StringFilter<"Evidencia"> | string
    createdAt?: DateTimeFilter<"Evidencia"> | Date | string
    updatedAt?: DateTimeFilter<"Evidencia"> | Date | string
  }

  export type ComentarioEvidenciaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ComentarioEvidenciaWhereUniqueInput
    update: XOR<ComentarioEvidenciaUpdateWithoutUsuarioInput, ComentarioEvidenciaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ComentarioEvidenciaCreateWithoutUsuarioInput, ComentarioEvidenciaUncheckedCreateWithoutUsuarioInput>
  }

  export type ComentarioEvidenciaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ComentarioEvidenciaWhereUniqueInput
    data: XOR<ComentarioEvidenciaUpdateWithoutUsuarioInput, ComentarioEvidenciaUncheckedUpdateWithoutUsuarioInput>
  }

  export type ComentarioEvidenciaUpdateManyWithWhereWithoutUsuarioInput = {
    where: ComentarioEvidenciaScalarWhereInput
    data: XOR<ComentarioEvidenciaUpdateManyMutationInput, ComentarioEvidenciaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ComentarioEvidenciaScalarWhereInput = {
    AND?: ComentarioEvidenciaScalarWhereInput | ComentarioEvidenciaScalarWhereInput[]
    OR?: ComentarioEvidenciaScalarWhereInput[]
    NOT?: ComentarioEvidenciaScalarWhereInput | ComentarioEvidenciaScalarWhereInput[]
    id?: StringFilter<"ComentarioEvidencia"> | string
    texto?: StringFilter<"ComentarioEvidencia"> | string
    data?: DateTimeFilter<"ComentarioEvidencia"> | Date | string
    evidenciaId?: StringFilter<"ComentarioEvidencia"> | string
    usuarioId?: StringFilter<"ComentarioEvidencia"> | string
    createdAt?: DateTimeFilter<"ComentarioEvidencia"> | Date | string
    updatedAt?: DateTimeFilter<"ComentarioEvidencia"> | Date | string
  }

  export type FarmaciaUsuarioCreateWithoutFarmaciaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutFarmaciasUsuarioInput
  }

  export type FarmaciaUsuarioUncheckedCreateWithoutFarmaciaInput = {
    id?: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FarmaciaUsuarioCreateOrConnectWithoutFarmaciaInput = {
    where: FarmaciaUsuarioWhereUniqueInput
    create: XOR<FarmaciaUsuarioCreateWithoutFarmaciaInput, FarmaciaUsuarioUncheckedCreateWithoutFarmaciaInput>
  }

  export type FarmaciaUsuarioCreateManyFarmaciaInputEnvelope = {
    data: FarmaciaUsuarioCreateManyFarmaciaInput | FarmaciaUsuarioCreateManyFarmaciaInput[]
    skipDuplicates?: boolean
  }

  export type PlanoAcaoCreateWithoutFarmaciaInput = {
    id?: string
    titulo: string
    descricao: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    indicador: IndicadorCreateNestedOneWithoutPlanosAcaoInput
    responsavel: UsuarioCreateNestedOneWithoutPlanosInput
    acoes?: AcaoCreateNestedManyWithoutPlanoAcaoInput
    comentarios?: ComentarioCreateNestedManyWithoutPlanoAcaoInput
    evidencias?: EvidenciaCreateNestedManyWithoutPlanoInput
  }

  export type PlanoAcaoUncheckedCreateWithoutFarmaciaInput = {
    id?: string
    titulo: string
    descricao: string
    indicadorId: string
    responsavelId: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    acoes?: AcaoUncheckedCreateNestedManyWithoutPlanoAcaoInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutPlanoAcaoInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutPlanoInput
  }

  export type PlanoAcaoCreateOrConnectWithoutFarmaciaInput = {
    where: PlanoAcaoWhereUniqueInput
    create: XOR<PlanoAcaoCreateWithoutFarmaciaInput, PlanoAcaoUncheckedCreateWithoutFarmaciaInput>
  }

  export type PlanoAcaoCreateManyFarmaciaInputEnvelope = {
    data: PlanoAcaoCreateManyFarmaciaInput | PlanoAcaoCreateManyFarmaciaInput[]
    skipDuplicates?: boolean
  }

  export type EvidenciaCreateWithoutFarmaciaInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plano: PlanoAcaoCreateNestedOneWithoutEvidenciasInput
    indicador: IndicadorCreateNestedOneWithoutEvidenciasInput
    usuario: UsuarioCreateNestedOneWithoutEvidenciasInput
    comentarios?: ComentarioEvidenciaCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaUncheckedCreateWithoutFarmaciaInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    planoId: string
    indicadorId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comentarios?: ComentarioEvidenciaUncheckedCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaCreateOrConnectWithoutFarmaciaInput = {
    where: EvidenciaWhereUniqueInput
    create: XOR<EvidenciaCreateWithoutFarmaciaInput, EvidenciaUncheckedCreateWithoutFarmaciaInput>
  }

  export type EvidenciaCreateManyFarmaciaInputEnvelope = {
    data: EvidenciaCreateManyFarmaciaInput | EvidenciaCreateManyFarmaciaInput[]
    skipDuplicates?: boolean
  }

  export type MedicamentoCreateWithoutFarmaciaInput = {
    id?: string
    codigo: string
    nome: string
    tipo: string
    ultimaCompra: Date | string
    proximaCompra: Date | string
    duracaoDias: number
    lembreteEnviado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutMedicamentosInput
  }

  export type MedicamentoUncheckedCreateWithoutFarmaciaInput = {
    id?: string
    codigo: string
    nome: string
    tipo: string
    ultimaCompra: Date | string
    proximaCompra: Date | string
    duracaoDias: number
    lembreteEnviado?: boolean
    clienteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicamentoCreateOrConnectWithoutFarmaciaInput = {
    where: MedicamentoWhereUniqueInput
    create: XOR<MedicamentoCreateWithoutFarmaciaInput, MedicamentoUncheckedCreateWithoutFarmaciaInput>
  }

  export type MedicamentoCreateManyFarmaciaInputEnvelope = {
    data: MedicamentoCreateManyFarmaciaInput | MedicamentoCreateManyFarmaciaInput[]
    skipDuplicates?: boolean
  }

  export type FarmaciaUsuarioUpsertWithWhereUniqueWithoutFarmaciaInput = {
    where: FarmaciaUsuarioWhereUniqueInput
    update: XOR<FarmaciaUsuarioUpdateWithoutFarmaciaInput, FarmaciaUsuarioUncheckedUpdateWithoutFarmaciaInput>
    create: XOR<FarmaciaUsuarioCreateWithoutFarmaciaInput, FarmaciaUsuarioUncheckedCreateWithoutFarmaciaInput>
  }

  export type FarmaciaUsuarioUpdateWithWhereUniqueWithoutFarmaciaInput = {
    where: FarmaciaUsuarioWhereUniqueInput
    data: XOR<FarmaciaUsuarioUpdateWithoutFarmaciaInput, FarmaciaUsuarioUncheckedUpdateWithoutFarmaciaInput>
  }

  export type FarmaciaUsuarioUpdateManyWithWhereWithoutFarmaciaInput = {
    where: FarmaciaUsuarioScalarWhereInput
    data: XOR<FarmaciaUsuarioUpdateManyMutationInput, FarmaciaUsuarioUncheckedUpdateManyWithoutFarmaciaInput>
  }

  export type PlanoAcaoUpsertWithWhereUniqueWithoutFarmaciaInput = {
    where: PlanoAcaoWhereUniqueInput
    update: XOR<PlanoAcaoUpdateWithoutFarmaciaInput, PlanoAcaoUncheckedUpdateWithoutFarmaciaInput>
    create: XOR<PlanoAcaoCreateWithoutFarmaciaInput, PlanoAcaoUncheckedCreateWithoutFarmaciaInput>
  }

  export type PlanoAcaoUpdateWithWhereUniqueWithoutFarmaciaInput = {
    where: PlanoAcaoWhereUniqueInput
    data: XOR<PlanoAcaoUpdateWithoutFarmaciaInput, PlanoAcaoUncheckedUpdateWithoutFarmaciaInput>
  }

  export type PlanoAcaoUpdateManyWithWhereWithoutFarmaciaInput = {
    where: PlanoAcaoScalarWhereInput
    data: XOR<PlanoAcaoUpdateManyMutationInput, PlanoAcaoUncheckedUpdateManyWithoutFarmaciaInput>
  }

  export type EvidenciaUpsertWithWhereUniqueWithoutFarmaciaInput = {
    where: EvidenciaWhereUniqueInput
    update: XOR<EvidenciaUpdateWithoutFarmaciaInput, EvidenciaUncheckedUpdateWithoutFarmaciaInput>
    create: XOR<EvidenciaCreateWithoutFarmaciaInput, EvidenciaUncheckedCreateWithoutFarmaciaInput>
  }

  export type EvidenciaUpdateWithWhereUniqueWithoutFarmaciaInput = {
    where: EvidenciaWhereUniqueInput
    data: XOR<EvidenciaUpdateWithoutFarmaciaInput, EvidenciaUncheckedUpdateWithoutFarmaciaInput>
  }

  export type EvidenciaUpdateManyWithWhereWithoutFarmaciaInput = {
    where: EvidenciaScalarWhereInput
    data: XOR<EvidenciaUpdateManyMutationInput, EvidenciaUncheckedUpdateManyWithoutFarmaciaInput>
  }

  export type MedicamentoUpsertWithWhereUniqueWithoutFarmaciaInput = {
    where: MedicamentoWhereUniqueInput
    update: XOR<MedicamentoUpdateWithoutFarmaciaInput, MedicamentoUncheckedUpdateWithoutFarmaciaInput>
    create: XOR<MedicamentoCreateWithoutFarmaciaInput, MedicamentoUncheckedCreateWithoutFarmaciaInput>
  }

  export type MedicamentoUpdateWithWhereUniqueWithoutFarmaciaInput = {
    where: MedicamentoWhereUniqueInput
    data: XOR<MedicamentoUpdateWithoutFarmaciaInput, MedicamentoUncheckedUpdateWithoutFarmaciaInput>
  }

  export type MedicamentoUpdateManyWithWhereWithoutFarmaciaInput = {
    where: MedicamentoScalarWhereInput
    data: XOR<MedicamentoUpdateManyMutationInput, MedicamentoUncheckedUpdateManyWithoutFarmaciaInput>
  }

  export type MedicamentoScalarWhereInput = {
    AND?: MedicamentoScalarWhereInput | MedicamentoScalarWhereInput[]
    OR?: MedicamentoScalarWhereInput[]
    NOT?: MedicamentoScalarWhereInput | MedicamentoScalarWhereInput[]
    id?: StringFilter<"Medicamento"> | string
    codigo?: StringFilter<"Medicamento"> | string
    nome?: StringFilter<"Medicamento"> | string
    tipo?: StringFilter<"Medicamento"> | string
    ultimaCompra?: DateTimeFilter<"Medicamento"> | Date | string
    proximaCompra?: DateTimeFilter<"Medicamento"> | Date | string
    duracaoDias?: IntFilter<"Medicamento"> | number
    lembreteEnviado?: BoolFilter<"Medicamento"> | boolean
    farmaciaId?: StringFilter<"Medicamento"> | string
    clienteId?: StringFilter<"Medicamento"> | string
    createdAt?: DateTimeFilter<"Medicamento"> | Date | string
    updatedAt?: DateTimeFilter<"Medicamento"> | Date | string
  }

  export type FarmaciaCreateWithoutUsuariosAssociadosInput = {
    id?: string
    nome: string
    cnpj: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    corPrincipal?: string
    corSecundaria?: string
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planosAcao?: PlanoAcaoCreateNestedManyWithoutFarmaciaInput
    evidencias?: EvidenciaCreateNestedManyWithoutFarmaciaInput
    medicamentos?: MedicamentoCreateNestedManyWithoutFarmaciaInput
  }

  export type FarmaciaUncheckedCreateWithoutUsuariosAssociadosInput = {
    id?: string
    nome: string
    cnpj: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    corPrincipal?: string
    corSecundaria?: string
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planosAcao?: PlanoAcaoUncheckedCreateNestedManyWithoutFarmaciaInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutFarmaciaInput
    medicamentos?: MedicamentoUncheckedCreateNestedManyWithoutFarmaciaInput
  }

  export type FarmaciaCreateOrConnectWithoutUsuariosAssociadosInput = {
    where: FarmaciaWhereUniqueInput
    create: XOR<FarmaciaCreateWithoutUsuariosAssociadosInput, FarmaciaUncheckedCreateWithoutUsuariosAssociadosInput>
  }

  export type UsuarioCreateWithoutFarmaciasUsuarioInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planos?: PlanoAcaoCreateNestedManyWithoutResponsavelInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    evidencias?: EvidenciaCreateNestedManyWithoutUsuarioInput
    comentariosEvidencia?: ComentarioEvidenciaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutFarmaciasUsuarioInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planos?: PlanoAcaoUncheckedCreateNestedManyWithoutResponsavelInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutUsuarioInput
    comentariosEvidencia?: ComentarioEvidenciaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutFarmaciasUsuarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutFarmaciasUsuarioInput, UsuarioUncheckedCreateWithoutFarmaciasUsuarioInput>
  }

  export type FarmaciaUpsertWithoutUsuariosAssociadosInput = {
    update: XOR<FarmaciaUpdateWithoutUsuariosAssociadosInput, FarmaciaUncheckedUpdateWithoutUsuariosAssociadosInput>
    create: XOR<FarmaciaCreateWithoutUsuariosAssociadosInput, FarmaciaUncheckedCreateWithoutUsuariosAssociadosInput>
    where?: FarmaciaWhereInput
  }

  export type FarmaciaUpdateToOneWithWhereWithoutUsuariosAssociadosInput = {
    where?: FarmaciaWhereInput
    data: XOR<FarmaciaUpdateWithoutUsuariosAssociadosInput, FarmaciaUncheckedUpdateWithoutUsuariosAssociadosInput>
  }

  export type FarmaciaUpdateWithoutUsuariosAssociadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    corPrincipal?: StringFieldUpdateOperationsInput | string
    corSecundaria?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planosAcao?: PlanoAcaoUpdateManyWithoutFarmaciaNestedInput
    evidencias?: EvidenciaUpdateManyWithoutFarmaciaNestedInput
    medicamentos?: MedicamentoUpdateManyWithoutFarmaciaNestedInput
  }

  export type FarmaciaUncheckedUpdateWithoutUsuariosAssociadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    corPrincipal?: StringFieldUpdateOperationsInput | string
    corSecundaria?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planosAcao?: PlanoAcaoUncheckedUpdateManyWithoutFarmaciaNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutFarmaciaNestedInput
    medicamentos?: MedicamentoUncheckedUpdateManyWithoutFarmaciaNestedInput
  }

  export type UsuarioUpsertWithoutFarmaciasUsuarioInput = {
    update: XOR<UsuarioUpdateWithoutFarmaciasUsuarioInput, UsuarioUncheckedUpdateWithoutFarmaciasUsuarioInput>
    create: XOR<UsuarioCreateWithoutFarmaciasUsuarioInput, UsuarioUncheckedCreateWithoutFarmaciasUsuarioInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutFarmaciasUsuarioInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutFarmaciasUsuarioInput, UsuarioUncheckedUpdateWithoutFarmaciasUsuarioInput>
  }

  export type UsuarioUpdateWithoutFarmaciasUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planos?: PlanoAcaoUpdateManyWithoutResponsavelNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    evidencias?: EvidenciaUpdateManyWithoutUsuarioNestedInput
    comentariosEvidencia?: ComentarioEvidenciaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutFarmaciasUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planos?: PlanoAcaoUncheckedUpdateManyWithoutResponsavelNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutUsuarioNestedInput
    comentariosEvidencia?: ComentarioEvidenciaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type PlanoAcaoCreateWithoutIndicadorInput = {
    id?: string
    titulo: string
    descricao: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    farmacia: FarmaciaCreateNestedOneWithoutPlanosAcaoInput
    responsavel: UsuarioCreateNestedOneWithoutPlanosInput
    acoes?: AcaoCreateNestedManyWithoutPlanoAcaoInput
    comentarios?: ComentarioCreateNestedManyWithoutPlanoAcaoInput
    evidencias?: EvidenciaCreateNestedManyWithoutPlanoInput
  }

  export type PlanoAcaoUncheckedCreateWithoutIndicadorInput = {
    id?: string
    titulo: string
    descricao: string
    farmaciaId: string
    responsavelId: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    acoes?: AcaoUncheckedCreateNestedManyWithoutPlanoAcaoInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutPlanoAcaoInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutPlanoInput
  }

  export type PlanoAcaoCreateOrConnectWithoutIndicadorInput = {
    where: PlanoAcaoWhereUniqueInput
    create: XOR<PlanoAcaoCreateWithoutIndicadorInput, PlanoAcaoUncheckedCreateWithoutIndicadorInput>
  }

  export type PlanoAcaoCreateManyIndicadorInputEnvelope = {
    data: PlanoAcaoCreateManyIndicadorInput | PlanoAcaoCreateManyIndicadorInput[]
    skipDuplicates?: boolean
  }

  export type EvidenciaCreateWithoutIndicadorInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plano: PlanoAcaoCreateNestedOneWithoutEvidenciasInput
    farmacia: FarmaciaCreateNestedOneWithoutEvidenciasInput
    usuario: UsuarioCreateNestedOneWithoutEvidenciasInput
    comentarios?: ComentarioEvidenciaCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaUncheckedCreateWithoutIndicadorInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    planoId: string
    farmaciaId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comentarios?: ComentarioEvidenciaUncheckedCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaCreateOrConnectWithoutIndicadorInput = {
    where: EvidenciaWhereUniqueInput
    create: XOR<EvidenciaCreateWithoutIndicadorInput, EvidenciaUncheckedCreateWithoutIndicadorInput>
  }

  export type EvidenciaCreateManyIndicadorInputEnvelope = {
    data: EvidenciaCreateManyIndicadorInput | EvidenciaCreateManyIndicadorInput[]
    skipDuplicates?: boolean
  }

  export type IndicadorRelacionadoCreateWithoutIndicadorOrigemInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    indicadorDestino: IndicadorCreateNestedOneWithoutRelacionadoAInput
  }

  export type IndicadorRelacionadoUncheckedCreateWithoutIndicadorOrigemInput = {
    id?: string
    indicadorDestinoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicadorRelacionadoCreateOrConnectWithoutIndicadorOrigemInput = {
    where: IndicadorRelacionadoWhereUniqueInput
    create: XOR<IndicadorRelacionadoCreateWithoutIndicadorOrigemInput, IndicadorRelacionadoUncheckedCreateWithoutIndicadorOrigemInput>
  }

  export type IndicadorRelacionadoCreateManyIndicadorOrigemInputEnvelope = {
    data: IndicadorRelacionadoCreateManyIndicadorOrigemInput | IndicadorRelacionadoCreateManyIndicadorOrigemInput[]
    skipDuplicates?: boolean
  }

  export type IndicadorRelacionadoCreateWithoutIndicadorDestinoInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    indicadorOrigem: IndicadorCreateNestedOneWithoutRelacionadosInput
  }

  export type IndicadorRelacionadoUncheckedCreateWithoutIndicadorDestinoInput = {
    id?: string
    indicadorOrigemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicadorRelacionadoCreateOrConnectWithoutIndicadorDestinoInput = {
    where: IndicadorRelacionadoWhereUniqueInput
    create: XOR<IndicadorRelacionadoCreateWithoutIndicadorDestinoInput, IndicadorRelacionadoUncheckedCreateWithoutIndicadorDestinoInput>
  }

  export type IndicadorRelacionadoCreateManyIndicadorDestinoInputEnvelope = {
    data: IndicadorRelacionadoCreateManyIndicadorDestinoInput | IndicadorRelacionadoCreateManyIndicadorDestinoInput[]
    skipDuplicates?: boolean
  }

  export type PlanoAcaoUpsertWithWhereUniqueWithoutIndicadorInput = {
    where: PlanoAcaoWhereUniqueInput
    update: XOR<PlanoAcaoUpdateWithoutIndicadorInput, PlanoAcaoUncheckedUpdateWithoutIndicadorInput>
    create: XOR<PlanoAcaoCreateWithoutIndicadorInput, PlanoAcaoUncheckedCreateWithoutIndicadorInput>
  }

  export type PlanoAcaoUpdateWithWhereUniqueWithoutIndicadorInput = {
    where: PlanoAcaoWhereUniqueInput
    data: XOR<PlanoAcaoUpdateWithoutIndicadorInput, PlanoAcaoUncheckedUpdateWithoutIndicadorInput>
  }

  export type PlanoAcaoUpdateManyWithWhereWithoutIndicadorInput = {
    where: PlanoAcaoScalarWhereInput
    data: XOR<PlanoAcaoUpdateManyMutationInput, PlanoAcaoUncheckedUpdateManyWithoutIndicadorInput>
  }

  export type EvidenciaUpsertWithWhereUniqueWithoutIndicadorInput = {
    where: EvidenciaWhereUniqueInput
    update: XOR<EvidenciaUpdateWithoutIndicadorInput, EvidenciaUncheckedUpdateWithoutIndicadorInput>
    create: XOR<EvidenciaCreateWithoutIndicadorInput, EvidenciaUncheckedCreateWithoutIndicadorInput>
  }

  export type EvidenciaUpdateWithWhereUniqueWithoutIndicadorInput = {
    where: EvidenciaWhereUniqueInput
    data: XOR<EvidenciaUpdateWithoutIndicadorInput, EvidenciaUncheckedUpdateWithoutIndicadorInput>
  }

  export type EvidenciaUpdateManyWithWhereWithoutIndicadorInput = {
    where: EvidenciaScalarWhereInput
    data: XOR<EvidenciaUpdateManyMutationInput, EvidenciaUncheckedUpdateManyWithoutIndicadorInput>
  }

  export type IndicadorRelacionadoUpsertWithWhereUniqueWithoutIndicadorOrigemInput = {
    where: IndicadorRelacionadoWhereUniqueInput
    update: XOR<IndicadorRelacionadoUpdateWithoutIndicadorOrigemInput, IndicadorRelacionadoUncheckedUpdateWithoutIndicadorOrigemInput>
    create: XOR<IndicadorRelacionadoCreateWithoutIndicadorOrigemInput, IndicadorRelacionadoUncheckedCreateWithoutIndicadorOrigemInput>
  }

  export type IndicadorRelacionadoUpdateWithWhereUniqueWithoutIndicadorOrigemInput = {
    where: IndicadorRelacionadoWhereUniqueInput
    data: XOR<IndicadorRelacionadoUpdateWithoutIndicadorOrigemInput, IndicadorRelacionadoUncheckedUpdateWithoutIndicadorOrigemInput>
  }

  export type IndicadorRelacionadoUpdateManyWithWhereWithoutIndicadorOrigemInput = {
    where: IndicadorRelacionadoScalarWhereInput
    data: XOR<IndicadorRelacionadoUpdateManyMutationInput, IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorOrigemInput>
  }

  export type IndicadorRelacionadoScalarWhereInput = {
    AND?: IndicadorRelacionadoScalarWhereInput | IndicadorRelacionadoScalarWhereInput[]
    OR?: IndicadorRelacionadoScalarWhereInput[]
    NOT?: IndicadorRelacionadoScalarWhereInput | IndicadorRelacionadoScalarWhereInput[]
    id?: StringFilter<"IndicadorRelacionado"> | string
    indicadorOrigemId?: StringFilter<"IndicadorRelacionado"> | string
    indicadorDestinoId?: StringFilter<"IndicadorRelacionado"> | string
    createdAt?: DateTimeFilter<"IndicadorRelacionado"> | Date | string
    updatedAt?: DateTimeFilter<"IndicadorRelacionado"> | Date | string
  }

  export type IndicadorRelacionadoUpsertWithWhereUniqueWithoutIndicadorDestinoInput = {
    where: IndicadorRelacionadoWhereUniqueInput
    update: XOR<IndicadorRelacionadoUpdateWithoutIndicadorDestinoInput, IndicadorRelacionadoUncheckedUpdateWithoutIndicadorDestinoInput>
    create: XOR<IndicadorRelacionadoCreateWithoutIndicadorDestinoInput, IndicadorRelacionadoUncheckedCreateWithoutIndicadorDestinoInput>
  }

  export type IndicadorRelacionadoUpdateWithWhereUniqueWithoutIndicadorDestinoInput = {
    where: IndicadorRelacionadoWhereUniqueInput
    data: XOR<IndicadorRelacionadoUpdateWithoutIndicadorDestinoInput, IndicadorRelacionadoUncheckedUpdateWithoutIndicadorDestinoInput>
  }

  export type IndicadorRelacionadoUpdateManyWithWhereWithoutIndicadorDestinoInput = {
    where: IndicadorRelacionadoScalarWhereInput
    data: XOR<IndicadorRelacionadoUpdateManyMutationInput, IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorDestinoInput>
  }

  export type IndicadorCreateWithoutRelacionadosInput = {
    id?: string
    codigo: string
    nome: string
    categoria: string
    unidade: string
    metaPadrao: string
    temImpacto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planosAcao?: PlanoAcaoCreateNestedManyWithoutIndicadorInput
    evidencias?: EvidenciaCreateNestedManyWithoutIndicadorInput
    relacionadoA?: IndicadorRelacionadoCreateNestedManyWithoutIndicadorDestinoInput
  }

  export type IndicadorUncheckedCreateWithoutRelacionadosInput = {
    id?: string
    codigo: string
    nome: string
    categoria: string
    unidade: string
    metaPadrao: string
    temImpacto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planosAcao?: PlanoAcaoUncheckedCreateNestedManyWithoutIndicadorInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutIndicadorInput
    relacionadoA?: IndicadorRelacionadoUncheckedCreateNestedManyWithoutIndicadorDestinoInput
  }

  export type IndicadorCreateOrConnectWithoutRelacionadosInput = {
    where: IndicadorWhereUniqueInput
    create: XOR<IndicadorCreateWithoutRelacionadosInput, IndicadorUncheckedCreateWithoutRelacionadosInput>
  }

  export type IndicadorCreateWithoutRelacionadoAInput = {
    id?: string
    codigo: string
    nome: string
    categoria: string
    unidade: string
    metaPadrao: string
    temImpacto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planosAcao?: PlanoAcaoCreateNestedManyWithoutIndicadorInput
    evidencias?: EvidenciaCreateNestedManyWithoutIndicadorInput
    relacionados?: IndicadorRelacionadoCreateNestedManyWithoutIndicadorOrigemInput
  }

  export type IndicadorUncheckedCreateWithoutRelacionadoAInput = {
    id?: string
    codigo: string
    nome: string
    categoria: string
    unidade: string
    metaPadrao: string
    temImpacto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planosAcao?: PlanoAcaoUncheckedCreateNestedManyWithoutIndicadorInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutIndicadorInput
    relacionados?: IndicadorRelacionadoUncheckedCreateNestedManyWithoutIndicadorOrigemInput
  }

  export type IndicadorCreateOrConnectWithoutRelacionadoAInput = {
    where: IndicadorWhereUniqueInput
    create: XOR<IndicadorCreateWithoutRelacionadoAInput, IndicadorUncheckedCreateWithoutRelacionadoAInput>
  }

  export type IndicadorUpsertWithoutRelacionadosInput = {
    update: XOR<IndicadorUpdateWithoutRelacionadosInput, IndicadorUncheckedUpdateWithoutRelacionadosInput>
    create: XOR<IndicadorCreateWithoutRelacionadosInput, IndicadorUncheckedCreateWithoutRelacionadosInput>
    where?: IndicadorWhereInput
  }

  export type IndicadorUpdateToOneWithWhereWithoutRelacionadosInput = {
    where?: IndicadorWhereInput
    data: XOR<IndicadorUpdateWithoutRelacionadosInput, IndicadorUncheckedUpdateWithoutRelacionadosInput>
  }

  export type IndicadorUpdateWithoutRelacionadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    metaPadrao?: StringFieldUpdateOperationsInput | string
    temImpacto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planosAcao?: PlanoAcaoUpdateManyWithoutIndicadorNestedInput
    evidencias?: EvidenciaUpdateManyWithoutIndicadorNestedInput
    relacionadoA?: IndicadorRelacionadoUpdateManyWithoutIndicadorDestinoNestedInput
  }

  export type IndicadorUncheckedUpdateWithoutRelacionadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    metaPadrao?: StringFieldUpdateOperationsInput | string
    temImpacto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planosAcao?: PlanoAcaoUncheckedUpdateManyWithoutIndicadorNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutIndicadorNestedInput
    relacionadoA?: IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorDestinoNestedInput
  }

  export type IndicadorUpsertWithoutRelacionadoAInput = {
    update: XOR<IndicadorUpdateWithoutRelacionadoAInput, IndicadorUncheckedUpdateWithoutRelacionadoAInput>
    create: XOR<IndicadorCreateWithoutRelacionadoAInput, IndicadorUncheckedCreateWithoutRelacionadoAInput>
    where?: IndicadorWhereInput
  }

  export type IndicadorUpdateToOneWithWhereWithoutRelacionadoAInput = {
    where?: IndicadorWhereInput
    data: XOR<IndicadorUpdateWithoutRelacionadoAInput, IndicadorUncheckedUpdateWithoutRelacionadoAInput>
  }

  export type IndicadorUpdateWithoutRelacionadoAInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    metaPadrao?: StringFieldUpdateOperationsInput | string
    temImpacto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planosAcao?: PlanoAcaoUpdateManyWithoutIndicadorNestedInput
    evidencias?: EvidenciaUpdateManyWithoutIndicadorNestedInput
    relacionados?: IndicadorRelacionadoUpdateManyWithoutIndicadorOrigemNestedInput
  }

  export type IndicadorUncheckedUpdateWithoutRelacionadoAInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    metaPadrao?: StringFieldUpdateOperationsInput | string
    temImpacto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planosAcao?: PlanoAcaoUncheckedUpdateManyWithoutIndicadorNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutIndicadorNestedInput
    relacionados?: IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorOrigemNestedInput
  }

  export type FarmaciaCreateWithoutPlanosAcaoInput = {
    id?: string
    nome: string
    cnpj: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    corPrincipal?: string
    corSecundaria?: string
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usuariosAssociados?: FarmaciaUsuarioCreateNestedManyWithoutFarmaciaInput
    evidencias?: EvidenciaCreateNestedManyWithoutFarmaciaInput
    medicamentos?: MedicamentoCreateNestedManyWithoutFarmaciaInput
  }

  export type FarmaciaUncheckedCreateWithoutPlanosAcaoInput = {
    id?: string
    nome: string
    cnpj: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    corPrincipal?: string
    corSecundaria?: string
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usuariosAssociados?: FarmaciaUsuarioUncheckedCreateNestedManyWithoutFarmaciaInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutFarmaciaInput
    medicamentos?: MedicamentoUncheckedCreateNestedManyWithoutFarmaciaInput
  }

  export type FarmaciaCreateOrConnectWithoutPlanosAcaoInput = {
    where: FarmaciaWhereUniqueInput
    create: XOR<FarmaciaCreateWithoutPlanosAcaoInput, FarmaciaUncheckedCreateWithoutPlanosAcaoInput>
  }

  export type IndicadorCreateWithoutPlanosAcaoInput = {
    id?: string
    codigo: string
    nome: string
    categoria: string
    unidade: string
    metaPadrao: string
    temImpacto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evidencias?: EvidenciaCreateNestedManyWithoutIndicadorInput
    relacionados?: IndicadorRelacionadoCreateNestedManyWithoutIndicadorOrigemInput
    relacionadoA?: IndicadorRelacionadoCreateNestedManyWithoutIndicadorDestinoInput
  }

  export type IndicadorUncheckedCreateWithoutPlanosAcaoInput = {
    id?: string
    codigo: string
    nome: string
    categoria: string
    unidade: string
    metaPadrao: string
    temImpacto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutIndicadorInput
    relacionados?: IndicadorRelacionadoUncheckedCreateNestedManyWithoutIndicadorOrigemInput
    relacionadoA?: IndicadorRelacionadoUncheckedCreateNestedManyWithoutIndicadorDestinoInput
  }

  export type IndicadorCreateOrConnectWithoutPlanosAcaoInput = {
    where: IndicadorWhereUniqueInput
    create: XOR<IndicadorCreateWithoutPlanosAcaoInput, IndicadorUncheckedCreateWithoutPlanosAcaoInput>
  }

  export type UsuarioCreateWithoutPlanosInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    farmaciasUsuario?: FarmaciaUsuarioCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    evidencias?: EvidenciaCreateNestedManyWithoutUsuarioInput
    comentariosEvidencia?: ComentarioEvidenciaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPlanosInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    farmaciasUsuario?: FarmaciaUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutUsuarioInput
    comentariosEvidencia?: ComentarioEvidenciaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPlanosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPlanosInput, UsuarioUncheckedCreateWithoutPlanosInput>
  }

  export type AcaoCreateWithoutPlanoAcaoInput = {
    id?: string
    descricao: string
    prazo: Date | string
    concluida?: boolean
    atrasada?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcaoUncheckedCreateWithoutPlanoAcaoInput = {
    id?: string
    descricao: string
    prazo: Date | string
    concluida?: boolean
    atrasada?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcaoCreateOrConnectWithoutPlanoAcaoInput = {
    where: AcaoWhereUniqueInput
    create: XOR<AcaoCreateWithoutPlanoAcaoInput, AcaoUncheckedCreateWithoutPlanoAcaoInput>
  }

  export type AcaoCreateManyPlanoAcaoInputEnvelope = {
    data: AcaoCreateManyPlanoAcaoInput | AcaoCreateManyPlanoAcaoInput[]
    skipDuplicates?: boolean
  }

  export type ComentarioCreateWithoutPlanoAcaoInput = {
    id?: string
    texto: string
    data?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioUncheckedCreateWithoutPlanoAcaoInput = {
    id?: string
    texto: string
    data?: Date | string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentarioCreateOrConnectWithoutPlanoAcaoInput = {
    where: ComentarioWhereUniqueInput
    create: XOR<ComentarioCreateWithoutPlanoAcaoInput, ComentarioUncheckedCreateWithoutPlanoAcaoInput>
  }

  export type ComentarioCreateManyPlanoAcaoInputEnvelope = {
    data: ComentarioCreateManyPlanoAcaoInput | ComentarioCreateManyPlanoAcaoInput[]
    skipDuplicates?: boolean
  }

  export type EvidenciaCreateWithoutPlanoInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    farmacia: FarmaciaCreateNestedOneWithoutEvidenciasInput
    indicador: IndicadorCreateNestedOneWithoutEvidenciasInput
    usuario: UsuarioCreateNestedOneWithoutEvidenciasInput
    comentarios?: ComentarioEvidenciaCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaUncheckedCreateWithoutPlanoInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    farmaciaId: string
    indicadorId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comentarios?: ComentarioEvidenciaUncheckedCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaCreateOrConnectWithoutPlanoInput = {
    where: EvidenciaWhereUniqueInput
    create: XOR<EvidenciaCreateWithoutPlanoInput, EvidenciaUncheckedCreateWithoutPlanoInput>
  }

  export type EvidenciaCreateManyPlanoInputEnvelope = {
    data: EvidenciaCreateManyPlanoInput | EvidenciaCreateManyPlanoInput[]
    skipDuplicates?: boolean
  }

  export type FarmaciaUpsertWithoutPlanosAcaoInput = {
    update: XOR<FarmaciaUpdateWithoutPlanosAcaoInput, FarmaciaUncheckedUpdateWithoutPlanosAcaoInput>
    create: XOR<FarmaciaCreateWithoutPlanosAcaoInput, FarmaciaUncheckedCreateWithoutPlanosAcaoInput>
    where?: FarmaciaWhereInput
  }

  export type FarmaciaUpdateToOneWithWhereWithoutPlanosAcaoInput = {
    where?: FarmaciaWhereInput
    data: XOR<FarmaciaUpdateWithoutPlanosAcaoInput, FarmaciaUncheckedUpdateWithoutPlanosAcaoInput>
  }

  export type FarmaciaUpdateWithoutPlanosAcaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    corPrincipal?: StringFieldUpdateOperationsInput | string
    corSecundaria?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosAssociados?: FarmaciaUsuarioUpdateManyWithoutFarmaciaNestedInput
    evidencias?: EvidenciaUpdateManyWithoutFarmaciaNestedInput
    medicamentos?: MedicamentoUpdateManyWithoutFarmaciaNestedInput
  }

  export type FarmaciaUncheckedUpdateWithoutPlanosAcaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    corPrincipal?: StringFieldUpdateOperationsInput | string
    corSecundaria?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosAssociados?: FarmaciaUsuarioUncheckedUpdateManyWithoutFarmaciaNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutFarmaciaNestedInput
    medicamentos?: MedicamentoUncheckedUpdateManyWithoutFarmaciaNestedInput
  }

  export type IndicadorUpsertWithoutPlanosAcaoInput = {
    update: XOR<IndicadorUpdateWithoutPlanosAcaoInput, IndicadorUncheckedUpdateWithoutPlanosAcaoInput>
    create: XOR<IndicadorCreateWithoutPlanosAcaoInput, IndicadorUncheckedCreateWithoutPlanosAcaoInput>
    where?: IndicadorWhereInput
  }

  export type IndicadorUpdateToOneWithWhereWithoutPlanosAcaoInput = {
    where?: IndicadorWhereInput
    data: XOR<IndicadorUpdateWithoutPlanosAcaoInput, IndicadorUncheckedUpdateWithoutPlanosAcaoInput>
  }

  export type IndicadorUpdateWithoutPlanosAcaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    metaPadrao?: StringFieldUpdateOperationsInput | string
    temImpacto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidencias?: EvidenciaUpdateManyWithoutIndicadorNestedInput
    relacionados?: IndicadorRelacionadoUpdateManyWithoutIndicadorOrigemNestedInput
    relacionadoA?: IndicadorRelacionadoUpdateManyWithoutIndicadorDestinoNestedInput
  }

  export type IndicadorUncheckedUpdateWithoutPlanosAcaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    metaPadrao?: StringFieldUpdateOperationsInput | string
    temImpacto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidencias?: EvidenciaUncheckedUpdateManyWithoutIndicadorNestedInput
    relacionados?: IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorOrigemNestedInput
    relacionadoA?: IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorDestinoNestedInput
  }

  export type UsuarioUpsertWithoutPlanosInput = {
    update: XOR<UsuarioUpdateWithoutPlanosInput, UsuarioUncheckedUpdateWithoutPlanosInput>
    create: XOR<UsuarioCreateWithoutPlanosInput, UsuarioUncheckedCreateWithoutPlanosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPlanosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPlanosInput, UsuarioUncheckedUpdateWithoutPlanosInput>
  }

  export type UsuarioUpdateWithoutPlanosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmaciasUsuario?: FarmaciaUsuarioUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    evidencias?: EvidenciaUpdateManyWithoutUsuarioNestedInput
    comentariosEvidencia?: ComentarioEvidenciaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPlanosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmaciasUsuario?: FarmaciaUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutUsuarioNestedInput
    comentariosEvidencia?: ComentarioEvidenciaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type AcaoUpsertWithWhereUniqueWithoutPlanoAcaoInput = {
    where: AcaoWhereUniqueInput
    update: XOR<AcaoUpdateWithoutPlanoAcaoInput, AcaoUncheckedUpdateWithoutPlanoAcaoInput>
    create: XOR<AcaoCreateWithoutPlanoAcaoInput, AcaoUncheckedCreateWithoutPlanoAcaoInput>
  }

  export type AcaoUpdateWithWhereUniqueWithoutPlanoAcaoInput = {
    where: AcaoWhereUniqueInput
    data: XOR<AcaoUpdateWithoutPlanoAcaoInput, AcaoUncheckedUpdateWithoutPlanoAcaoInput>
  }

  export type AcaoUpdateManyWithWhereWithoutPlanoAcaoInput = {
    where: AcaoScalarWhereInput
    data: XOR<AcaoUpdateManyMutationInput, AcaoUncheckedUpdateManyWithoutPlanoAcaoInput>
  }

  export type AcaoScalarWhereInput = {
    AND?: AcaoScalarWhereInput | AcaoScalarWhereInput[]
    OR?: AcaoScalarWhereInput[]
    NOT?: AcaoScalarWhereInput | AcaoScalarWhereInput[]
    id?: StringFilter<"Acao"> | string
    descricao?: StringFilter<"Acao"> | string
    prazo?: DateTimeFilter<"Acao"> | Date | string
    concluida?: BoolFilter<"Acao"> | boolean
    atrasada?: BoolFilter<"Acao"> | boolean
    planoAcaoId?: StringFilter<"Acao"> | string
    createdAt?: DateTimeFilter<"Acao"> | Date | string
    updatedAt?: DateTimeFilter<"Acao"> | Date | string
  }

  export type ComentarioUpsertWithWhereUniqueWithoutPlanoAcaoInput = {
    where: ComentarioWhereUniqueInput
    update: XOR<ComentarioUpdateWithoutPlanoAcaoInput, ComentarioUncheckedUpdateWithoutPlanoAcaoInput>
    create: XOR<ComentarioCreateWithoutPlanoAcaoInput, ComentarioUncheckedCreateWithoutPlanoAcaoInput>
  }

  export type ComentarioUpdateWithWhereUniqueWithoutPlanoAcaoInput = {
    where: ComentarioWhereUniqueInput
    data: XOR<ComentarioUpdateWithoutPlanoAcaoInput, ComentarioUncheckedUpdateWithoutPlanoAcaoInput>
  }

  export type ComentarioUpdateManyWithWhereWithoutPlanoAcaoInput = {
    where: ComentarioScalarWhereInput
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyWithoutPlanoAcaoInput>
  }

  export type EvidenciaUpsertWithWhereUniqueWithoutPlanoInput = {
    where: EvidenciaWhereUniqueInput
    update: XOR<EvidenciaUpdateWithoutPlanoInput, EvidenciaUncheckedUpdateWithoutPlanoInput>
    create: XOR<EvidenciaCreateWithoutPlanoInput, EvidenciaUncheckedCreateWithoutPlanoInput>
  }

  export type EvidenciaUpdateWithWhereUniqueWithoutPlanoInput = {
    where: EvidenciaWhereUniqueInput
    data: XOR<EvidenciaUpdateWithoutPlanoInput, EvidenciaUncheckedUpdateWithoutPlanoInput>
  }

  export type EvidenciaUpdateManyWithWhereWithoutPlanoInput = {
    where: EvidenciaScalarWhereInput
    data: XOR<EvidenciaUpdateManyMutationInput, EvidenciaUncheckedUpdateManyWithoutPlanoInput>
  }

  export type PlanoAcaoCreateWithoutAcoesInput = {
    id?: string
    titulo: string
    descricao: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    farmacia: FarmaciaCreateNestedOneWithoutPlanosAcaoInput
    indicador: IndicadorCreateNestedOneWithoutPlanosAcaoInput
    responsavel: UsuarioCreateNestedOneWithoutPlanosInput
    comentarios?: ComentarioCreateNestedManyWithoutPlanoAcaoInput
    evidencias?: EvidenciaCreateNestedManyWithoutPlanoInput
  }

  export type PlanoAcaoUncheckedCreateWithoutAcoesInput = {
    id?: string
    titulo: string
    descricao: string
    farmaciaId: string
    indicadorId: string
    responsavelId: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutPlanoAcaoInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutPlanoInput
  }

  export type PlanoAcaoCreateOrConnectWithoutAcoesInput = {
    where: PlanoAcaoWhereUniqueInput
    create: XOR<PlanoAcaoCreateWithoutAcoesInput, PlanoAcaoUncheckedCreateWithoutAcoesInput>
  }

  export type PlanoAcaoUpsertWithoutAcoesInput = {
    update: XOR<PlanoAcaoUpdateWithoutAcoesInput, PlanoAcaoUncheckedUpdateWithoutAcoesInput>
    create: XOR<PlanoAcaoCreateWithoutAcoesInput, PlanoAcaoUncheckedCreateWithoutAcoesInput>
    where?: PlanoAcaoWhereInput
  }

  export type PlanoAcaoUpdateToOneWithWhereWithoutAcoesInput = {
    where?: PlanoAcaoWhereInput
    data: XOR<PlanoAcaoUpdateWithoutAcoesInput, PlanoAcaoUncheckedUpdateWithoutAcoesInput>
  }

  export type PlanoAcaoUpdateWithoutAcoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmacia?: FarmaciaUpdateOneRequiredWithoutPlanosAcaoNestedInput
    indicador?: IndicadorUpdateOneRequiredWithoutPlanosAcaoNestedInput
    responsavel?: UsuarioUpdateOneRequiredWithoutPlanosNestedInput
    comentarios?: ComentarioUpdateManyWithoutPlanoAcaoNestedInput
    evidencias?: EvidenciaUpdateManyWithoutPlanoNestedInput
  }

  export type PlanoAcaoUncheckedUpdateWithoutAcoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    responsavelId?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comentarios?: ComentarioUncheckedUpdateManyWithoutPlanoAcaoNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutPlanoNestedInput
  }

  export type PlanoAcaoCreateWithoutComentariosInput = {
    id?: string
    titulo: string
    descricao: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    farmacia: FarmaciaCreateNestedOneWithoutPlanosAcaoInput
    indicador: IndicadorCreateNestedOneWithoutPlanosAcaoInput
    responsavel: UsuarioCreateNestedOneWithoutPlanosInput
    acoes?: AcaoCreateNestedManyWithoutPlanoAcaoInput
    evidencias?: EvidenciaCreateNestedManyWithoutPlanoInput
  }

  export type PlanoAcaoUncheckedCreateWithoutComentariosInput = {
    id?: string
    titulo: string
    descricao: string
    farmaciaId: string
    indicadorId: string
    responsavelId: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    acoes?: AcaoUncheckedCreateNestedManyWithoutPlanoAcaoInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutPlanoInput
  }

  export type PlanoAcaoCreateOrConnectWithoutComentariosInput = {
    where: PlanoAcaoWhereUniqueInput
    create: XOR<PlanoAcaoCreateWithoutComentariosInput, PlanoAcaoUncheckedCreateWithoutComentariosInput>
  }

  export type UsuarioCreateWithoutComentariosInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    farmaciasUsuario?: FarmaciaUsuarioCreateNestedManyWithoutUsuarioInput
    planos?: PlanoAcaoCreateNestedManyWithoutResponsavelInput
    evidencias?: EvidenciaCreateNestedManyWithoutUsuarioInput
    comentariosEvidencia?: ComentarioEvidenciaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutComentariosInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    farmaciasUsuario?: FarmaciaUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    planos?: PlanoAcaoUncheckedCreateNestedManyWithoutResponsavelInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutUsuarioInput
    comentariosEvidencia?: ComentarioEvidenciaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutComentariosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
  }

  export type PlanoAcaoUpsertWithoutComentariosInput = {
    update: XOR<PlanoAcaoUpdateWithoutComentariosInput, PlanoAcaoUncheckedUpdateWithoutComentariosInput>
    create: XOR<PlanoAcaoCreateWithoutComentariosInput, PlanoAcaoUncheckedCreateWithoutComentariosInput>
    where?: PlanoAcaoWhereInput
  }

  export type PlanoAcaoUpdateToOneWithWhereWithoutComentariosInput = {
    where?: PlanoAcaoWhereInput
    data: XOR<PlanoAcaoUpdateWithoutComentariosInput, PlanoAcaoUncheckedUpdateWithoutComentariosInput>
  }

  export type PlanoAcaoUpdateWithoutComentariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmacia?: FarmaciaUpdateOneRequiredWithoutPlanosAcaoNestedInput
    indicador?: IndicadorUpdateOneRequiredWithoutPlanosAcaoNestedInput
    responsavel?: UsuarioUpdateOneRequiredWithoutPlanosNestedInput
    acoes?: AcaoUpdateManyWithoutPlanoAcaoNestedInput
    evidencias?: EvidenciaUpdateManyWithoutPlanoNestedInput
  }

  export type PlanoAcaoUncheckedUpdateWithoutComentariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    responsavelId?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acoes?: AcaoUncheckedUpdateManyWithoutPlanoAcaoNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutPlanoNestedInput
  }

  export type UsuarioUpsertWithoutComentariosInput = {
    update: XOR<UsuarioUpdateWithoutComentariosInput, UsuarioUncheckedUpdateWithoutComentariosInput>
    create: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutComentariosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutComentariosInput, UsuarioUncheckedUpdateWithoutComentariosInput>
  }

  export type UsuarioUpdateWithoutComentariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmaciasUsuario?: FarmaciaUsuarioUpdateManyWithoutUsuarioNestedInput
    planos?: PlanoAcaoUpdateManyWithoutResponsavelNestedInput
    evidencias?: EvidenciaUpdateManyWithoutUsuarioNestedInput
    comentariosEvidencia?: ComentarioEvidenciaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutComentariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmaciasUsuario?: FarmaciaUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    planos?: PlanoAcaoUncheckedUpdateManyWithoutResponsavelNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutUsuarioNestedInput
    comentariosEvidencia?: ComentarioEvidenciaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type PlanoAcaoCreateWithoutEvidenciasInput = {
    id?: string
    titulo: string
    descricao: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    farmacia: FarmaciaCreateNestedOneWithoutPlanosAcaoInput
    indicador: IndicadorCreateNestedOneWithoutPlanosAcaoInput
    responsavel: UsuarioCreateNestedOneWithoutPlanosInput
    acoes?: AcaoCreateNestedManyWithoutPlanoAcaoInput
    comentarios?: ComentarioCreateNestedManyWithoutPlanoAcaoInput
  }

  export type PlanoAcaoUncheckedCreateWithoutEvidenciasInput = {
    id?: string
    titulo: string
    descricao: string
    farmaciaId: string
    indicadorId: string
    responsavelId: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    acoes?: AcaoUncheckedCreateNestedManyWithoutPlanoAcaoInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutPlanoAcaoInput
  }

  export type PlanoAcaoCreateOrConnectWithoutEvidenciasInput = {
    where: PlanoAcaoWhereUniqueInput
    create: XOR<PlanoAcaoCreateWithoutEvidenciasInput, PlanoAcaoUncheckedCreateWithoutEvidenciasInput>
  }

  export type FarmaciaCreateWithoutEvidenciasInput = {
    id?: string
    nome: string
    cnpj: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    corPrincipal?: string
    corSecundaria?: string
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usuariosAssociados?: FarmaciaUsuarioCreateNestedManyWithoutFarmaciaInput
    planosAcao?: PlanoAcaoCreateNestedManyWithoutFarmaciaInput
    medicamentos?: MedicamentoCreateNestedManyWithoutFarmaciaInput
  }

  export type FarmaciaUncheckedCreateWithoutEvidenciasInput = {
    id?: string
    nome: string
    cnpj: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    corPrincipal?: string
    corSecundaria?: string
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usuariosAssociados?: FarmaciaUsuarioUncheckedCreateNestedManyWithoutFarmaciaInput
    planosAcao?: PlanoAcaoUncheckedCreateNestedManyWithoutFarmaciaInput
    medicamentos?: MedicamentoUncheckedCreateNestedManyWithoutFarmaciaInput
  }

  export type FarmaciaCreateOrConnectWithoutEvidenciasInput = {
    where: FarmaciaWhereUniqueInput
    create: XOR<FarmaciaCreateWithoutEvidenciasInput, FarmaciaUncheckedCreateWithoutEvidenciasInput>
  }

  export type IndicadorCreateWithoutEvidenciasInput = {
    id?: string
    codigo: string
    nome: string
    categoria: string
    unidade: string
    metaPadrao: string
    temImpacto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planosAcao?: PlanoAcaoCreateNestedManyWithoutIndicadorInput
    relacionados?: IndicadorRelacionadoCreateNestedManyWithoutIndicadorOrigemInput
    relacionadoA?: IndicadorRelacionadoCreateNestedManyWithoutIndicadorDestinoInput
  }

  export type IndicadorUncheckedCreateWithoutEvidenciasInput = {
    id?: string
    codigo: string
    nome: string
    categoria: string
    unidade: string
    metaPadrao: string
    temImpacto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planosAcao?: PlanoAcaoUncheckedCreateNestedManyWithoutIndicadorInput
    relacionados?: IndicadorRelacionadoUncheckedCreateNestedManyWithoutIndicadorOrigemInput
    relacionadoA?: IndicadorRelacionadoUncheckedCreateNestedManyWithoutIndicadorDestinoInput
  }

  export type IndicadorCreateOrConnectWithoutEvidenciasInput = {
    where: IndicadorWhereUniqueInput
    create: XOR<IndicadorCreateWithoutEvidenciasInput, IndicadorUncheckedCreateWithoutEvidenciasInput>
  }

  export type UsuarioCreateWithoutEvidenciasInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    farmaciasUsuario?: FarmaciaUsuarioCreateNestedManyWithoutUsuarioInput
    planos?: PlanoAcaoCreateNestedManyWithoutResponsavelInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    comentariosEvidencia?: ComentarioEvidenciaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutEvidenciasInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    farmaciasUsuario?: FarmaciaUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    planos?: PlanoAcaoUncheckedCreateNestedManyWithoutResponsavelInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    comentariosEvidencia?: ComentarioEvidenciaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutEvidenciasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEvidenciasInput, UsuarioUncheckedCreateWithoutEvidenciasInput>
  }

  export type ComentarioEvidenciaCreateWithoutEvidenciaInput = {
    id?: string
    texto: string
    data?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutComentariosEvidenciaInput
  }

  export type ComentarioEvidenciaUncheckedCreateWithoutEvidenciaInput = {
    id?: string
    texto: string
    data?: Date | string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentarioEvidenciaCreateOrConnectWithoutEvidenciaInput = {
    where: ComentarioEvidenciaWhereUniqueInput
    create: XOR<ComentarioEvidenciaCreateWithoutEvidenciaInput, ComentarioEvidenciaUncheckedCreateWithoutEvidenciaInput>
  }

  export type ComentarioEvidenciaCreateManyEvidenciaInputEnvelope = {
    data: ComentarioEvidenciaCreateManyEvidenciaInput | ComentarioEvidenciaCreateManyEvidenciaInput[]
    skipDuplicates?: boolean
  }

  export type PlanoAcaoUpsertWithoutEvidenciasInput = {
    update: XOR<PlanoAcaoUpdateWithoutEvidenciasInput, PlanoAcaoUncheckedUpdateWithoutEvidenciasInput>
    create: XOR<PlanoAcaoCreateWithoutEvidenciasInput, PlanoAcaoUncheckedCreateWithoutEvidenciasInput>
    where?: PlanoAcaoWhereInput
  }

  export type PlanoAcaoUpdateToOneWithWhereWithoutEvidenciasInput = {
    where?: PlanoAcaoWhereInput
    data: XOR<PlanoAcaoUpdateWithoutEvidenciasInput, PlanoAcaoUncheckedUpdateWithoutEvidenciasInput>
  }

  export type PlanoAcaoUpdateWithoutEvidenciasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmacia?: FarmaciaUpdateOneRequiredWithoutPlanosAcaoNestedInput
    indicador?: IndicadorUpdateOneRequiredWithoutPlanosAcaoNestedInput
    responsavel?: UsuarioUpdateOneRequiredWithoutPlanosNestedInput
    acoes?: AcaoUpdateManyWithoutPlanoAcaoNestedInput
    comentarios?: ComentarioUpdateManyWithoutPlanoAcaoNestedInput
  }

  export type PlanoAcaoUncheckedUpdateWithoutEvidenciasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    responsavelId?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acoes?: AcaoUncheckedUpdateManyWithoutPlanoAcaoNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutPlanoAcaoNestedInput
  }

  export type FarmaciaUpsertWithoutEvidenciasInput = {
    update: XOR<FarmaciaUpdateWithoutEvidenciasInput, FarmaciaUncheckedUpdateWithoutEvidenciasInput>
    create: XOR<FarmaciaCreateWithoutEvidenciasInput, FarmaciaUncheckedCreateWithoutEvidenciasInput>
    where?: FarmaciaWhereInput
  }

  export type FarmaciaUpdateToOneWithWhereWithoutEvidenciasInput = {
    where?: FarmaciaWhereInput
    data: XOR<FarmaciaUpdateWithoutEvidenciasInput, FarmaciaUncheckedUpdateWithoutEvidenciasInput>
  }

  export type FarmaciaUpdateWithoutEvidenciasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    corPrincipal?: StringFieldUpdateOperationsInput | string
    corSecundaria?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosAssociados?: FarmaciaUsuarioUpdateManyWithoutFarmaciaNestedInput
    planosAcao?: PlanoAcaoUpdateManyWithoutFarmaciaNestedInput
    medicamentos?: MedicamentoUpdateManyWithoutFarmaciaNestedInput
  }

  export type FarmaciaUncheckedUpdateWithoutEvidenciasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    corPrincipal?: StringFieldUpdateOperationsInput | string
    corSecundaria?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosAssociados?: FarmaciaUsuarioUncheckedUpdateManyWithoutFarmaciaNestedInput
    planosAcao?: PlanoAcaoUncheckedUpdateManyWithoutFarmaciaNestedInput
    medicamentos?: MedicamentoUncheckedUpdateManyWithoutFarmaciaNestedInput
  }

  export type IndicadorUpsertWithoutEvidenciasInput = {
    update: XOR<IndicadorUpdateWithoutEvidenciasInput, IndicadorUncheckedUpdateWithoutEvidenciasInput>
    create: XOR<IndicadorCreateWithoutEvidenciasInput, IndicadorUncheckedCreateWithoutEvidenciasInput>
    where?: IndicadorWhereInput
  }

  export type IndicadorUpdateToOneWithWhereWithoutEvidenciasInput = {
    where?: IndicadorWhereInput
    data: XOR<IndicadorUpdateWithoutEvidenciasInput, IndicadorUncheckedUpdateWithoutEvidenciasInput>
  }

  export type IndicadorUpdateWithoutEvidenciasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    metaPadrao?: StringFieldUpdateOperationsInput | string
    temImpacto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planosAcao?: PlanoAcaoUpdateManyWithoutIndicadorNestedInput
    relacionados?: IndicadorRelacionadoUpdateManyWithoutIndicadorOrigemNestedInput
    relacionadoA?: IndicadorRelacionadoUpdateManyWithoutIndicadorDestinoNestedInput
  }

  export type IndicadorUncheckedUpdateWithoutEvidenciasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    metaPadrao?: StringFieldUpdateOperationsInput | string
    temImpacto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planosAcao?: PlanoAcaoUncheckedUpdateManyWithoutIndicadorNestedInput
    relacionados?: IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorOrigemNestedInput
    relacionadoA?: IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorDestinoNestedInput
  }

  export type UsuarioUpsertWithoutEvidenciasInput = {
    update: XOR<UsuarioUpdateWithoutEvidenciasInput, UsuarioUncheckedUpdateWithoutEvidenciasInput>
    create: XOR<UsuarioCreateWithoutEvidenciasInput, UsuarioUncheckedCreateWithoutEvidenciasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEvidenciasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEvidenciasInput, UsuarioUncheckedUpdateWithoutEvidenciasInput>
  }

  export type UsuarioUpdateWithoutEvidenciasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmaciasUsuario?: FarmaciaUsuarioUpdateManyWithoutUsuarioNestedInput
    planos?: PlanoAcaoUpdateManyWithoutResponsavelNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    comentariosEvidencia?: ComentarioEvidenciaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEvidenciasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmaciasUsuario?: FarmaciaUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    planos?: PlanoAcaoUncheckedUpdateManyWithoutResponsavelNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    comentariosEvidencia?: ComentarioEvidenciaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ComentarioEvidenciaUpsertWithWhereUniqueWithoutEvidenciaInput = {
    where: ComentarioEvidenciaWhereUniqueInput
    update: XOR<ComentarioEvidenciaUpdateWithoutEvidenciaInput, ComentarioEvidenciaUncheckedUpdateWithoutEvidenciaInput>
    create: XOR<ComentarioEvidenciaCreateWithoutEvidenciaInput, ComentarioEvidenciaUncheckedCreateWithoutEvidenciaInput>
  }

  export type ComentarioEvidenciaUpdateWithWhereUniqueWithoutEvidenciaInput = {
    where: ComentarioEvidenciaWhereUniqueInput
    data: XOR<ComentarioEvidenciaUpdateWithoutEvidenciaInput, ComentarioEvidenciaUncheckedUpdateWithoutEvidenciaInput>
  }

  export type ComentarioEvidenciaUpdateManyWithWhereWithoutEvidenciaInput = {
    where: ComentarioEvidenciaScalarWhereInput
    data: XOR<ComentarioEvidenciaUpdateManyMutationInput, ComentarioEvidenciaUncheckedUpdateManyWithoutEvidenciaInput>
  }

  export type EvidenciaCreateWithoutComentariosInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plano: PlanoAcaoCreateNestedOneWithoutEvidenciasInput
    farmacia: FarmaciaCreateNestedOneWithoutEvidenciasInput
    indicador: IndicadorCreateNestedOneWithoutEvidenciasInput
    usuario: UsuarioCreateNestedOneWithoutEvidenciasInput
  }

  export type EvidenciaUncheckedCreateWithoutComentariosInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    planoId: string
    farmaciaId: string
    indicadorId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenciaCreateOrConnectWithoutComentariosInput = {
    where: EvidenciaWhereUniqueInput
    create: XOR<EvidenciaCreateWithoutComentariosInput, EvidenciaUncheckedCreateWithoutComentariosInput>
  }

  export type UsuarioCreateWithoutComentariosEvidenciaInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    farmaciasUsuario?: FarmaciaUsuarioCreateNestedManyWithoutUsuarioInput
    planos?: PlanoAcaoCreateNestedManyWithoutResponsavelInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    evidencias?: EvidenciaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutComentariosEvidenciaInput = {
    id?: string
    nome: string
    email: string
    senha: string
    perfil: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    farmaciasUsuario?: FarmaciaUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    planos?: PlanoAcaoUncheckedCreateNestedManyWithoutResponsavelInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutComentariosEvidenciaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutComentariosEvidenciaInput, UsuarioUncheckedCreateWithoutComentariosEvidenciaInput>
  }

  export type EvidenciaUpsertWithoutComentariosInput = {
    update: XOR<EvidenciaUpdateWithoutComentariosInput, EvidenciaUncheckedUpdateWithoutComentariosInput>
    create: XOR<EvidenciaCreateWithoutComentariosInput, EvidenciaUncheckedCreateWithoutComentariosInput>
    where?: EvidenciaWhereInput
  }

  export type EvidenciaUpdateToOneWithWhereWithoutComentariosInput = {
    where?: EvidenciaWhereInput
    data: XOR<EvidenciaUpdateWithoutComentariosInput, EvidenciaUncheckedUpdateWithoutComentariosInput>
  }

  export type EvidenciaUpdateWithoutComentariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plano?: PlanoAcaoUpdateOneRequiredWithoutEvidenciasNestedInput
    farmacia?: FarmaciaUpdateOneRequiredWithoutEvidenciasNestedInput
    indicador?: IndicadorUpdateOneRequiredWithoutEvidenciasNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutEvidenciasNestedInput
  }

  export type EvidenciaUncheckedUpdateWithoutComentariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    planoId?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUpsertWithoutComentariosEvidenciaInput = {
    update: XOR<UsuarioUpdateWithoutComentariosEvidenciaInput, UsuarioUncheckedUpdateWithoutComentariosEvidenciaInput>
    create: XOR<UsuarioCreateWithoutComentariosEvidenciaInput, UsuarioUncheckedCreateWithoutComentariosEvidenciaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutComentariosEvidenciaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutComentariosEvidenciaInput, UsuarioUncheckedUpdateWithoutComentariosEvidenciaInput>
  }

  export type UsuarioUpdateWithoutComentariosEvidenciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmaciasUsuario?: FarmaciaUsuarioUpdateManyWithoutUsuarioNestedInput
    planos?: PlanoAcaoUpdateManyWithoutResponsavelNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    evidencias?: EvidenciaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutComentariosEvidenciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmaciasUsuario?: FarmaciaUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    planos?: PlanoAcaoUncheckedUpdateManyWithoutResponsavelNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type FarmaciaCreateWithoutMedicamentosInput = {
    id?: string
    nome: string
    cnpj: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    corPrincipal?: string
    corSecundaria?: string
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usuariosAssociados?: FarmaciaUsuarioCreateNestedManyWithoutFarmaciaInput
    planosAcao?: PlanoAcaoCreateNestedManyWithoutFarmaciaInput
    evidencias?: EvidenciaCreateNestedManyWithoutFarmaciaInput
  }

  export type FarmaciaUncheckedCreateWithoutMedicamentosInput = {
    id?: string
    nome: string
    cnpj: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    corPrincipal?: string
    corSecundaria?: string
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usuariosAssociados?: FarmaciaUsuarioUncheckedCreateNestedManyWithoutFarmaciaInput
    planosAcao?: PlanoAcaoUncheckedCreateNestedManyWithoutFarmaciaInput
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutFarmaciaInput
  }

  export type FarmaciaCreateOrConnectWithoutMedicamentosInput = {
    where: FarmaciaWhereUniqueInput
    create: XOR<FarmaciaCreateWithoutMedicamentosInput, FarmaciaUncheckedCreateWithoutMedicamentosInput>
  }

  export type ClienteCreateWithoutMedicamentosInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClienteUncheckedCreateWithoutMedicamentosInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClienteCreateOrConnectWithoutMedicamentosInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutMedicamentosInput, ClienteUncheckedCreateWithoutMedicamentosInput>
  }

  export type FarmaciaUpsertWithoutMedicamentosInput = {
    update: XOR<FarmaciaUpdateWithoutMedicamentosInput, FarmaciaUncheckedUpdateWithoutMedicamentosInput>
    create: XOR<FarmaciaCreateWithoutMedicamentosInput, FarmaciaUncheckedCreateWithoutMedicamentosInput>
    where?: FarmaciaWhereInput
  }

  export type FarmaciaUpdateToOneWithWhereWithoutMedicamentosInput = {
    where?: FarmaciaWhereInput
    data: XOR<FarmaciaUpdateWithoutMedicamentosInput, FarmaciaUncheckedUpdateWithoutMedicamentosInput>
  }

  export type FarmaciaUpdateWithoutMedicamentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    corPrincipal?: StringFieldUpdateOperationsInput | string
    corSecundaria?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosAssociados?: FarmaciaUsuarioUpdateManyWithoutFarmaciaNestedInput
    planosAcao?: PlanoAcaoUpdateManyWithoutFarmaciaNestedInput
    evidencias?: EvidenciaUpdateManyWithoutFarmaciaNestedInput
  }

  export type FarmaciaUncheckedUpdateWithoutMedicamentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    corPrincipal?: StringFieldUpdateOperationsInput | string
    corSecundaria?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosAssociados?: FarmaciaUsuarioUncheckedUpdateManyWithoutFarmaciaNestedInput
    planosAcao?: PlanoAcaoUncheckedUpdateManyWithoutFarmaciaNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutFarmaciaNestedInput
  }

  export type ClienteUpsertWithoutMedicamentosInput = {
    update: XOR<ClienteUpdateWithoutMedicamentosInput, ClienteUncheckedUpdateWithoutMedicamentosInput>
    create: XOR<ClienteCreateWithoutMedicamentosInput, ClienteUncheckedCreateWithoutMedicamentosInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutMedicamentosInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutMedicamentosInput, ClienteUncheckedUpdateWithoutMedicamentosInput>
  }

  export type ClienteUpdateWithoutMedicamentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteUncheckedUpdateWithoutMedicamentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentoCreateWithoutClienteInput = {
    id?: string
    codigo: string
    nome: string
    tipo: string
    ultimaCompra: Date | string
    proximaCompra: Date | string
    duracaoDias: number
    lembreteEnviado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    farmacia: FarmaciaCreateNestedOneWithoutMedicamentosInput
  }

  export type MedicamentoUncheckedCreateWithoutClienteInput = {
    id?: string
    codigo: string
    nome: string
    tipo: string
    ultimaCompra: Date | string
    proximaCompra: Date | string
    duracaoDias: number
    lembreteEnviado?: boolean
    farmaciaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicamentoCreateOrConnectWithoutClienteInput = {
    where: MedicamentoWhereUniqueInput
    create: XOR<MedicamentoCreateWithoutClienteInput, MedicamentoUncheckedCreateWithoutClienteInput>
  }

  export type MedicamentoCreateManyClienteInputEnvelope = {
    data: MedicamentoCreateManyClienteInput | MedicamentoCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type MedicamentoUpsertWithWhereUniqueWithoutClienteInput = {
    where: MedicamentoWhereUniqueInput
    update: XOR<MedicamentoUpdateWithoutClienteInput, MedicamentoUncheckedUpdateWithoutClienteInput>
    create: XOR<MedicamentoCreateWithoutClienteInput, MedicamentoUncheckedCreateWithoutClienteInput>
  }

  export type MedicamentoUpdateWithWhereUniqueWithoutClienteInput = {
    where: MedicamentoWhereUniqueInput
    data: XOR<MedicamentoUpdateWithoutClienteInput, MedicamentoUncheckedUpdateWithoutClienteInput>
  }

  export type MedicamentoUpdateManyWithWhereWithoutClienteInput = {
    where: MedicamentoScalarWhereInput
    data: XOR<MedicamentoUpdateManyMutationInput, MedicamentoUncheckedUpdateManyWithoutClienteInput>
  }

  export type FarmaciaUsuarioCreateManyUsuarioInput = {
    id?: string
    farmaciaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanoAcaoCreateManyResponsavelInput = {
    id?: string
    titulo: string
    descricao: string
    farmaciaId: string
    indicadorId: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentarioCreateManyUsuarioInput = {
    id?: string
    texto: string
    data?: Date | string
    planoAcaoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenciaCreateManyUsuarioInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    planoId: string
    farmaciaId: string
    indicadorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentarioEvidenciaCreateManyUsuarioInput = {
    id?: string
    texto: string
    data?: Date | string
    evidenciaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FarmaciaUsuarioUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmacia?: FarmaciaUpdateOneRequiredWithoutUsuariosAssociadosNestedInput
  }

  export type FarmaciaUsuarioUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FarmaciaUsuarioUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanoAcaoUpdateWithoutResponsavelInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmacia?: FarmaciaUpdateOneRequiredWithoutPlanosAcaoNestedInput
    indicador?: IndicadorUpdateOneRequiredWithoutPlanosAcaoNestedInput
    acoes?: AcaoUpdateManyWithoutPlanoAcaoNestedInput
    comentarios?: ComentarioUpdateManyWithoutPlanoAcaoNestedInput
    evidencias?: EvidenciaUpdateManyWithoutPlanoNestedInput
  }

  export type PlanoAcaoUncheckedUpdateWithoutResponsavelInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acoes?: AcaoUncheckedUpdateManyWithoutPlanoAcaoNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutPlanoAcaoNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutPlanoNestedInput
  }

  export type PlanoAcaoUncheckedUpdateManyWithoutResponsavelInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planoAcao?: PlanoAcaoUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    planoAcaoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    planoAcaoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenciaUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plano?: PlanoAcaoUpdateOneRequiredWithoutEvidenciasNestedInput
    farmacia?: FarmaciaUpdateOneRequiredWithoutEvidenciasNestedInput
    indicador?: IndicadorUpdateOneRequiredWithoutEvidenciasNestedInput
    comentarios?: ComentarioEvidenciaUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    planoId?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comentarios?: ComentarioEvidenciaUncheckedUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    planoId?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioEvidenciaUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidencia?: EvidenciaUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioEvidenciaUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    evidenciaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioEvidenciaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    evidenciaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FarmaciaUsuarioCreateManyFarmaciaInput = {
    id?: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanoAcaoCreateManyFarmaciaInput = {
    id?: string
    titulo: string
    descricao: string
    indicadorId: string
    responsavelId: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenciaCreateManyFarmaciaInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    planoId: string
    indicadorId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicamentoCreateManyFarmaciaInput = {
    id?: string
    codigo: string
    nome: string
    tipo: string
    ultimaCompra: Date | string
    proximaCompra: Date | string
    duracaoDias: number
    lembreteEnviado?: boolean
    clienteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FarmaciaUsuarioUpdateWithoutFarmaciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutFarmaciasUsuarioNestedInput
  }

  export type FarmaciaUsuarioUncheckedUpdateWithoutFarmaciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FarmaciaUsuarioUncheckedUpdateManyWithoutFarmaciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanoAcaoUpdateWithoutFarmaciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicador?: IndicadorUpdateOneRequiredWithoutPlanosAcaoNestedInput
    responsavel?: UsuarioUpdateOneRequiredWithoutPlanosNestedInput
    acoes?: AcaoUpdateManyWithoutPlanoAcaoNestedInput
    comentarios?: ComentarioUpdateManyWithoutPlanoAcaoNestedInput
    evidencias?: EvidenciaUpdateManyWithoutPlanoNestedInput
  }

  export type PlanoAcaoUncheckedUpdateWithoutFarmaciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    responsavelId?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acoes?: AcaoUncheckedUpdateManyWithoutPlanoAcaoNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutPlanoAcaoNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutPlanoNestedInput
  }

  export type PlanoAcaoUncheckedUpdateManyWithoutFarmaciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    responsavelId?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenciaUpdateWithoutFarmaciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plano?: PlanoAcaoUpdateOneRequiredWithoutEvidenciasNestedInput
    indicador?: IndicadorUpdateOneRequiredWithoutEvidenciasNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutEvidenciasNestedInput
    comentarios?: ComentarioEvidenciaUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateWithoutFarmaciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    planoId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comentarios?: ComentarioEvidenciaUncheckedUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateManyWithoutFarmaciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    planoId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentoUpdateWithoutFarmaciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ultimaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    proximaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    duracaoDias?: IntFieldUpdateOperationsInput | number
    lembreteEnviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutMedicamentosNestedInput
  }

  export type MedicamentoUncheckedUpdateWithoutFarmaciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ultimaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    proximaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    duracaoDias?: IntFieldUpdateOperationsInput | number
    lembreteEnviado?: BoolFieldUpdateOperationsInput | boolean
    clienteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentoUncheckedUpdateManyWithoutFarmaciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ultimaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    proximaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    duracaoDias?: IntFieldUpdateOperationsInput | number
    lembreteEnviado?: BoolFieldUpdateOperationsInput | boolean
    clienteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanoAcaoCreateManyIndicadorInput = {
    id?: string
    titulo: string
    descricao: string
    farmaciaId: string
    responsavelId: string
    dataCriacao?: Date | string
    prazo: Date | string
    status?: string
    percentualConcluido?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenciaCreateManyIndicadorInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    planoId: string
    farmaciaId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicadorRelacionadoCreateManyIndicadorOrigemInput = {
    id?: string
    indicadorDestinoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicadorRelacionadoCreateManyIndicadorDestinoInput = {
    id?: string
    indicadorOrigemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanoAcaoUpdateWithoutIndicadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmacia?: FarmaciaUpdateOneRequiredWithoutPlanosAcaoNestedInput
    responsavel?: UsuarioUpdateOneRequiredWithoutPlanosNestedInput
    acoes?: AcaoUpdateManyWithoutPlanoAcaoNestedInput
    comentarios?: ComentarioUpdateManyWithoutPlanoAcaoNestedInput
    evidencias?: EvidenciaUpdateManyWithoutPlanoNestedInput
  }

  export type PlanoAcaoUncheckedUpdateWithoutIndicadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    responsavelId?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acoes?: AcaoUncheckedUpdateManyWithoutPlanoAcaoNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutPlanoAcaoNestedInput
    evidencias?: EvidenciaUncheckedUpdateManyWithoutPlanoNestedInput
  }

  export type PlanoAcaoUncheckedUpdateManyWithoutIndicadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    responsavelId?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    percentualConcluido?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenciaUpdateWithoutIndicadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plano?: PlanoAcaoUpdateOneRequiredWithoutEvidenciasNestedInput
    farmacia?: FarmaciaUpdateOneRequiredWithoutEvidenciasNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutEvidenciasNestedInput
    comentarios?: ComentarioEvidenciaUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateWithoutIndicadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    planoId?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comentarios?: ComentarioEvidenciaUncheckedUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateManyWithoutIndicadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    planoId?: StringFieldUpdateOperationsInput | string
    farmaciaId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicadorRelacionadoUpdateWithoutIndicadorOrigemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadorDestino?: IndicadorUpdateOneRequiredWithoutRelacionadoANestedInput
  }

  export type IndicadorRelacionadoUncheckedUpdateWithoutIndicadorOrigemInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicadorDestinoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorOrigemInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicadorDestinoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicadorRelacionadoUpdateWithoutIndicadorDestinoInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadorOrigem?: IndicadorUpdateOneRequiredWithoutRelacionadosNestedInput
  }

  export type IndicadorRelacionadoUncheckedUpdateWithoutIndicadorDestinoInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicadorOrigemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicadorRelacionadoUncheckedUpdateManyWithoutIndicadorDestinoInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicadorOrigemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcaoCreateManyPlanoAcaoInput = {
    id?: string
    descricao: string
    prazo: Date | string
    concluida?: boolean
    atrasada?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentarioCreateManyPlanoAcaoInput = {
    id?: string
    texto: string
    data?: Date | string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenciaCreateManyPlanoInput = {
    id?: string
    url: string
    descricao?: string | null
    dataCriacao?: Date | string
    status?: string
    dataValidacao?: Date | string | null
    validadoPorId?: string | null
    motivoReprovacao?: string | null
    farmaciaId: string
    indicadorId: string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcaoUpdateWithoutPlanoAcaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    concluida?: BoolFieldUpdateOperationsInput | boolean
    atrasada?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcaoUncheckedUpdateWithoutPlanoAcaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    concluida?: BoolFieldUpdateOperationsInput | boolean
    atrasada?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcaoUncheckedUpdateManyWithoutPlanoAcaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    concluida?: BoolFieldUpdateOperationsInput | boolean
    atrasada?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioUpdateWithoutPlanoAcaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioUncheckedUpdateWithoutPlanoAcaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioUncheckedUpdateManyWithoutPlanoAcaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenciaUpdateWithoutPlanoInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmacia?: FarmaciaUpdateOneRequiredWithoutEvidenciasNestedInput
    indicador?: IndicadorUpdateOneRequiredWithoutEvidenciasNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutEvidenciasNestedInput
    comentarios?: ComentarioEvidenciaUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateWithoutPlanoInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comentarios?: ComentarioEvidenciaUncheckedUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateManyWithoutPlanoInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    dataValidacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    motivoReprovacao?: NullableStringFieldUpdateOperationsInput | string | null
    farmaciaId?: StringFieldUpdateOperationsInput | string
    indicadorId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioEvidenciaCreateManyEvidenciaInput = {
    id?: string
    texto: string
    data?: Date | string
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentarioEvidenciaUpdateWithoutEvidenciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutComentariosEvidenciaNestedInput
  }

  export type ComentarioEvidenciaUncheckedUpdateWithoutEvidenciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioEvidenciaUncheckedUpdateManyWithoutEvidenciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentoCreateManyClienteInput = {
    id?: string
    codigo: string
    nome: string
    tipo: string
    ultimaCompra: Date | string
    proximaCompra: Date | string
    duracaoDias: number
    lembreteEnviado?: boolean
    farmaciaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicamentoUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ultimaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    proximaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    duracaoDias?: IntFieldUpdateOperationsInput | number
    lembreteEnviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmacia?: FarmaciaUpdateOneRequiredWithoutMedicamentosNestedInput
  }

  export type MedicamentoUncheckedUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ultimaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    proximaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    duracaoDias?: IntFieldUpdateOperationsInput | number
    lembreteEnviado?: BoolFieldUpdateOperationsInput | boolean
    farmaciaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentoUncheckedUpdateManyWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ultimaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    proximaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    duracaoDias?: IntFieldUpdateOperationsInput | number
    lembreteEnviado?: BoolFieldUpdateOperationsInput | boolean
    farmaciaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FarmaciaCountOutputTypeDefaultArgs instead
     */
    export type FarmaciaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FarmaciaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicadorCountOutputTypeDefaultArgs instead
     */
    export type IndicadorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicadorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanoAcaoCountOutputTypeDefaultArgs instead
     */
    export type PlanoAcaoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanoAcaoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvidenciaCountOutputTypeDefaultArgs instead
     */
    export type EvidenciaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvidenciaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteCountOutputTypeDefaultArgs instead
     */
    export type ClienteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FarmaciaDefaultArgs instead
     */
    export type FarmaciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FarmaciaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FarmaciaUsuarioDefaultArgs instead
     */
    export type FarmaciaUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FarmaciaUsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicadorDefaultArgs instead
     */
    export type IndicadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicadorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicadorRelacionadoDefaultArgs instead
     */
    export type IndicadorRelacionadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicadorRelacionadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanoAcaoDefaultArgs instead
     */
    export type PlanoAcaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanoAcaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcaoDefaultArgs instead
     */
    export type AcaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComentarioDefaultArgs instead
     */
    export type ComentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComentarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvidenciaDefaultArgs instead
     */
    export type EvidenciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvidenciaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComentarioEvidenciaDefaultArgs instead
     */
    export type ComentarioEvidenciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComentarioEvidenciaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicamentoDefaultArgs instead
     */
    export type MedicamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteDefaultArgs instead
     */
    export type ClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}